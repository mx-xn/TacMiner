Require Import Category.Lib.
Require Import Category.Lib.TList.
Require Import Category.Theory.Category.
Require Import Category.Theory.Isomorphism.
Require Import Category.Theory.Functor.
Require Import Category.Theory.Adjunction.
Require Import Category.Instance.Sets.

Generalizable All Variables.

Section Free.

Universes o h p.
Context {C : Category@{o h p}}.

(* Wikipedia: "In mathematics, the free category or path category generated by
   a directed graph or quiver is the category that results from freely
   concatenating arrows together, whenever the target of one arrow is the
   source of the next."
   
   "More precisely, the objects of the category are the vertices of the
   quiver, and the morphisms are paths between objects. Here, a path is
   defined as a finite sequence " *)

Program Definition Free@{fo fh fp} : Category@{fo fh fp} := {|
  obj     := C;
  hom     := tlist hom;
  homset  := fun _ _ => {| equiv := eq |};
  id      := fun _ => tnil;
  compose := fun _ _ _ f g => g +++ f
|}.
Next Obligation. equivalence; congruence. Qed.
Next Obligation. now apply tlist_app_tnil_r. Qed.
Next Obligation. now apply tlist_app_assoc. Qed.
Next Obligation. now symmetry; apply tlist_app_assoc. Qed.

Definition composition {x y : C} : tlist hom x y → x ~{C}~> y.
Proof.
  intros.
  induction X.
  - exact id.
  - exact (compose IHX b).
Defined.

Definition composition_tnil {x : C} : composition tnil ≈ id[x].
Proof. now cat. Qed.

Definition composition_tapp {x y z : C}
  (g : tlist hom y z) (f : tlist hom x y) :
  composition (f +++ g) ≈ composition g ∘ composition f.
Proof.
  induction f; simpl.
  - rewrite tlist_app_tnil_l.
    now cat.
  - rewrite <- tlist_app_comm_cons.
    simpl.
    rewrite IHf.
    now cat.
Qed.

#[local] Obligation Tactic := cat_simpl; try reflexivity.

Program Definition FreeFunctor : Free ⟶ C := {|
  fobj := fun x => x;
  fmap := fun _ _ f => composition f;
  fmap_id := fun _ => composition_tnil;
  fmap_comp := fun _ _ _ => composition_tapp
|}.

(**************************************************************************)

Inductive Mor : C → C → Type :=
  | Ident {x} : Mor x x
  | Morph {x y} (f : x ~> y) : Mor x y
  | Comp  {x y z} (f : Mor y z) (g : Mor x y) : Mor x z.

Fixpoint morD `(t : Mor x y) : x ~> y :=
  match t with
  | Ident => id
  | Morph f => f
  | Comp f g => morD f ∘ morD g
  end.

Fixpoint morDA `(t : Mor x y) : tlist hom x y :=
  match t with
  | Ident => tnil
  | Morph f => tcons _ f tnil
  | Comp f g => morDA g +++ morDA f
  end.

Program Instance Mor_Setoid {x y} : Setoid (Mor x y) := {
  equiv f g := morDA f = morDA g
}.

Lemma morD_sound `{t : Mor x y} :
  morD t ≈ composition (morDA t).
Proof.
  induction t; simpl; cat.
  rewrite IHt1, IHt2; simpl.
  now rewrite composition_tapp.
Qed.

Fixpoint tlistDA `(t : tlist hom x y) : Mor x y :=
  match t with
  | tnil => Ident
  | tcons _ f fs => Comp (tlistDA fs) (Morph f)
  end.

(* Note that this yields an equality. *)
Lemma morDA_tlistDA `{f : tlist hom x y} :
  morDA (tlistDA f) = f.
Proof.
  induction f; simpl; auto.
  rewrite <- tlist_app_cons.
  now rewrite IHf.
Qed.

(* While this is merely an equivalence. Such is the essence of adjointness
   between pseudocategories. *)
Lemma tlistDA_morDA `{f : Mor x y} :
  tlistDA (morDA f) ≈ f.
Proof.
  induction f; simpl; auto.
  rewrite <- IHf1, <- IHf2.
  now rewrite morDA_tlistDA.
Qed.

Program Definition FreeSyntax : Category := {|
  obj     := C;
  hom     := Mor;
  homset  := @Mor_Setoid;
  id      := fun _ => Ident;
  compose := fun _ _ _ => Comp
|}.
Next Obligation. now apply tlist_app_tnil_r. Qed.
Next Obligation. now apply tlist_app_assoc. Qed.
Next Obligation. now symmetry; apply tlist_app_assoc. Qed.

(**************************************************************************)

Program Instance ForgetSyntax : FreeSyntax ⟶ Free := {
  fobj := λ x, x;
  fmap := λ x y f, morDA f;
}.

Program Instance CanonicalMap : Free ⟶ FreeSyntax := {
  fobj := λ x, x;
  fmap := λ x y f, tlistDA f;
}.
Next Obligation.
  generalize dependent f.
  generalize dependent z.
  induction g; simpl; intros.
  - now rewrite !tlist_app_tnil_l.
  - rewrite <- tlist_app_cons.
    rewrite <- !tlist_app_comm_cons.
    simpl.
    rewrite <- tlist_app_cons.
    now rewrite <- IHg.
Qed.

(**************************************************************************)

Program Instance ForgetSyntax_CanonicalMap :
  ForgetSyntax ⊣ CanonicalMap := {
  adj := λ x y,
    {| to   := {| morphism := tlistDA |}
     ; from := {| morphism := morDA |} |}
}.
Next Obligation.
  simpl; intros;
  now rewrite tlistDA_morDA.
Qed.
Next Obligation.
  simpl; intros;
  now rewrite morDA_tlistDA.
Qed.
Next Obligation.
  now rewrite !morDA_tlistDA.
Qed.
Next Obligation.
  now rewrite !morDA_tlistDA.
Qed.
Next Obligation.
  now rewrite !morDA_tlistDA.
Qed.

End Free.
