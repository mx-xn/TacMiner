[
    {
        "lemma_name": "eq_nval",
        "proof": [
            {
                "tactic_sig": "Definition eq_nval ( x y : nval ) : { x = y } + { x <> y } .",
                "tactic_sig_no_out_arg": "Definition eq_nval ( x y : nval ) : { x = y } + { x <> y } .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : sumbool (eq x y) (not (eq x y))",
                    "c1_y : nval",
                    "c1_x : nval"
                ]
            },
            {
                "tactic_sig": "decide equality .",
                "tactic_sig_no_out_arg": "decide equality .",
                "tactic_args": [
                    "c1_goal : sumbool (eq x y) (not (eq x y))"
                ],
                "tactic_res": [
                    "c2_goal : sumbool (eq m m0) (not (eq m m0))",
                    "c2_m0 : Int.int",
                    "c2_m : Int.int"
                ]
            },
            {
                "tactic_sig": "apply Int.eq_dec .",
                "tactic_sig_no_out_arg": "apply Int.eq_dec .",
                "tactic_args": [
                    "c2_goal : sumbool (eq m m0) (not (eq m m0))",
                    "_global_1 : Z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "vagree_same",
        "proof": [
            {
                "tactic_sig": "Lemma vagree_same : forall v x , vagree v v x .",
                "tactic_sig_no_out_arg": "Lemma vagree_same : forall v x , vagree v v x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v : val) (x : nval), vagree v v x"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (v : val) (x : nval), vagree v v x"
                ],
                "tactic_res": [
                    "c2_goal : vagree v v x",
                    "c2_v : val",
                    "c2_x : nval"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | _o | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c2_goal : vagree v v x",
                    "c2_x : nval"
                ],
                "tactic_res": [
                    "c3_goal : vagree v v Nothing",
                    "c4_goal : vagree v v (I m)",
                    "c4_m : Int.int",
                    "c5_goal : vagree v v All"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : vagree v v Nothing"
                ],
                "tactic_res": [
                    "c6_goal : True"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : vagree v v (I m)"
                ],
                "tactic_res": [
                    "c7_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | _o | _o | _o | _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c7_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend",
                    "c2_v : val"
                ],
                "tactic_res": [
                    "c8_goal : True",
                    "c9_goal : iagree i i m",
                    "c9_i : Int.int",
                    "c10_goal : True",
                    "c10_i : Int64.int",
                    "c11_goal : True",
                    "c11_f : float",
                    "c12_goal : True",
                    "c12_f : float32",
                    "c13_goal : True",
                    "c13_i : Ptrofs.int",
                    "c13_b : block"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : vagree v v All"
                ],
                "tactic_res": [
                    "c14_goal : Val.lessdef v v"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : Val.lessdef v v"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c9_goal : iagree i i m"
                ],
                "tactic_res": [
                    "c15_goal : forall (i0 : Z) (_ : Logic.and (Z.le 0 i0) (Z.lt i0 Int.zwordsize))\n  (_ : eq (Int.testbit m i0) true),\neq (Int.testbit i i0) (Int.testbit i i0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : forall (i0 : Z) (_ : Logic.and (Z.le 0 i0) (Z.lt i0 Int.zwordsize))\n  (_ : eq (Int.testbit m i0) true),\neq (Int.testbit i i0) (Int.testbit i i0)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "vagree_lessdef",
        "proof": [
            {
                "tactic_sig": "Lemma vagree_lessdef : forall v w x , Val.lessdef v w -> vagree v w x .",
                "tactic_sig_no_out_arg": "Lemma vagree_lessdef : forall v w x , Val.lessdef v w -> vagree v w x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (x : nval) (_ : Val.lessdef v w), vagree v w x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (x : nval) (_ : Val.lessdef v w), vagree v w x"
                ],
                "tactic_res": [
                    "c2_goal : vagree v w x",
                    "c2_v : val",
                    "c2_w : val",
                    "c2_x : nval",
                    "c2_H : Val.lessdef v w"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c2_goal : vagree v w x",
                    "c2_H : Val.lessdef v w"
                ],
                "tactic_res": [
                    "c3_goal : vagree w w x",
                    "c4_goal : vagree Vundef w x"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : vagree w w x",
                    "_global_1 : Z",
                    "_global_vagree_same : forall (v : val) (x : nval), vagree v v x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  | _o | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c4_goal : vagree Vundef w x",
                    "c2_x : nval"
                ],
                "tactic_res": [
                    "c5_goal : vagree Vundef w Nothing",
                    "c6_goal : vagree Vundef w (I m)",
                    "c6_m : Int.int",
                    "c7_goal : vagree Vundef w All"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : vagree Vundef w Nothing"
                ],
                "tactic_res": [
                    "c8_goal : True"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c6_goal : vagree Vundef w (I m)"
                ],
                "tactic_res": [
                    "c9_goal : True"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c7_goal : vagree Vundef w All"
                ],
                "tactic_res": [
                    "c10_goal : Val.lessdef Vundef w"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : Val.lessdef Vundef w"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "lessdef_vagree",
        "proof": [
            {
                "tactic_sig": "Lemma lessdef_vagree : forall v w , vagree v w All -> Val.lessdef v w .",
                "tactic_sig_no_out_arg": "Lemma lessdef_vagree : forall v w , vagree v w All -> Val.lessdef v w .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (_ : vagree v w All), Val.lessdef v w"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (_ : vagree v w All), Val.lessdef v w"
                ],
                "tactic_res": [
                    "c2_goal : Val.lessdef v w",
                    "c2_v : val",
                    "c2_w : val",
                    "c2_H : vagree v w All"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "c2_H : vagree v w All"
                ],
                "tactic_res": [
                    "c2_H : Val.lessdef v w"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c2_goal : Val.lessdef v w"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "lessdef_vagree_list",
        "proof": [
            {
                "tactic_sig": "Lemma lessdef_vagree_list : forall vl1 vl2 , vagree_list vl1 vl2 nil -> Val.lessdef_list vl1 vl2 .",
                "tactic_sig_no_out_arg": "Lemma lessdef_vagree_list : forall vl1 vl2 , vagree_list vl1 vl2 nil -> Val.lessdef_list vl1 vl2 .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (vl1 vl2 : list val) (_ : vagree_list vl1 vl2 nil),\nVal.lessdef_list vl1 vl2"
                ]
            },
            {
                "tactic_sig": "induction vl1 .",
                "tactic_sig_no_out_arg": "induction vl1 .",
                "tactic_args": [
                    "c1_goal : forall (vl1 vl2 : list val) (_ : vagree_list vl1 vl2 nil),\nVal.lessdef_list vl1 vl2"
                ],
                "tactic_res": [
                    "c2_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2",
                    "c3_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2",
                    "c3_IHvl1 : forall (vl2 : list val) (_ : vagree_list vl1 vl2 nil),\nVal.lessdef_list vl1 vl2",
                    "c3_vl1 : list val",
                    "c3_a : val"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                    "c4_goal : Val.lessdef_list nil vl2",
                    "c4_vl2 : list val",
                    "c4_H : vagree_list nil vl2 nil"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c4_goal : Val.lessdef_list nil vl2",
                    "c4_H : vagree_list nil vl2 nil"
                ],
                "tactic_res": [
                    "c5_goal : Val.lessdef_list nil nil"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c5_goal : Val.lessdef_list nil nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                    "c6_goal : Val.lessdef_list (cons a vl1) vl2",
                    "c6_vl2 : list val",
                    "c6_H : vagree_list (cons a vl1) vl2 nil"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c6_goal : Val.lessdef_list (cons a vl1) vl2",
                    "c6_H : vagree_list (cons a vl1) vl2 nil"
                ],
                "tactic_res": [
                    "c7_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                    "c7_H4 : vagree_list vl1 vl3 nil",
                    "c7_H2 : vagree a v2 All",
                    "c7_vl3 : list val",
                    "c7_v2 : val"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": [
                    "c8_goal : Val.lessdef a v2",
                    "c9_goal : Val.lessdef_list vl1 vl3"
                ]
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c8_goal : Val.lessdef a v2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c9_goal : Val.lessdef_list vl1 vl3"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "vagree_lessdef_list",
        "proof": [
            {
                "tactic_sig": "Lemma vagree_lessdef_list : forall vl1 vl2 , Val.lessdef_list vl1 vl2 -> forall nvl , vagree_list vl1 vl2 nvl .",
                "tactic_sig_no_out_arg": "Lemma vagree_lessdef_list : forall vl1 vl2 , Val.lessdef_list vl1 vl2 -> forall nvl , vagree_list vl1 vl2 nvl .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (vl1 vl2 : list val) (_ : Val.lessdef_list vl1 vl2)\n  (nvl : list nval), vagree_list vl1 vl2 nvl"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (vl1 vl2 : list val) (_ : Val.lessdef_list vl1 vl2)\n  (nvl : list nval), vagree_list vl1 vl2 nvl"
                ],
                "tactic_res": [
                    "c2_goal : forall nvl : list nval, vagree_list nil nil nvl",
                    "c3_goal : forall nvl : list nval, vagree_list (cons v1 vl1) (cons v2 vl2) nvl",
                    "c3_IHlessdef_list : forall nvl : list nval, vagree_list vl1 vl2 nvl",
                    "c3_H0 : Val.lessdef_list vl1 vl2",
                    "c3_H : Val.lessdef v1 v2",
                    "c3_vl2 : list val",
                    "c3_vl1 : list val",
                    "c3_v2 : val",
                    "c3_v1 : val"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": [
                    "c4_goal : vagree_list nil nil nvl",
                    "c4_nvl : list nval"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall nvl : list nval, vagree_list (cons v1 vl1) (cons v2 vl2) nvl"
                ],
                "tactic_res": [
                    "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nvl",
                    "c5_nvl : list nval"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : vagree_list nil nil nvl"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nvl",
                    "c5_nvl : list nval"
                ],
                "tactic_res": [
                    "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil",
                    "c7_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)",
                    "c7_n : nval"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": [
                    "c8_goal : vagree v1 v2 All",
                    "c9_goal : vagree_list vl1 vl2 nil"
                ]
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c8_goal : vagree v1 v2 All"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c9_goal : vagree_list vl1 vl2 nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": [
                    "c10_goal : vagree v1 v2 n",
                    "c11_goal : vagree_list vl1 vl2 nvl"
                ]
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c10_goal : vagree v1 v2 n"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c11_goal : vagree_list vl1 vl2 nvl"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nge_refl",
        "proof": [
            {
                "tactic_sig": "Lemma nge_refl : forall x , nge x x .",
                "tactic_sig_no_out_arg": "Lemma nge_refl : forall x , nge x x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : nval, nge x x"
                ]
            },
            {
                "tactic_sig": "destruct x as [  | _o | ] .",
                "tactic_sig_no_out_arg": "destruct x .",
                "tactic_args": [
                    "c1_goal : forall x : nval, nge x x"
                ],
                "tactic_res": [
                    "c2_goal : nge Nothing Nothing",
                    "c3_goal : nge (I m) (I m)",
                    "c3_m : Int.int",
                    "c4_goal : nge All All"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c2_goal : nge Nothing Nothing"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c3_goal : nge (I m) (I m)"
                ],
                "tactic_res": [
                    "c5_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true), eq (Int.testbit m i) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true), eq (Int.testbit m i) true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c4_goal : nge All All"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nge_trans",
        "proof": [
            {
                "tactic_sig": "Lemma nge_trans : forall x y , nge x y -> forall z , nge y z -> nge x z .",
                "tactic_sig_no_out_arg": "Lemma nge_trans : forall x y , nge x y -> forall z , nge y z -> nge x z .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y : nval) (_ : nge x y) (z : nval) (_ : nge y z), nge x z"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (x y : nval) (_ : nge x y) (z : nval) (_ : nge y z), nge x z"
                ],
                "tactic_res": [
                    "c2_goal : forall (z : nval) (_ : nge x z), nge All z",
                    "c2_x : nval",
                    "c3_goal : forall (z : nval) (_ : nge Nothing z), nge x z",
                    "c3_x : nval",
                    "c4_goal : forall (z : nval) (_ : nge (I m2) z), nge (I m1) z",
                    "c4_H : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m2 i) true), eq (Int.testbit m1 i) true",
                    "c4_m2 : Int.int",
                    "c4_m1 : Int.int"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros w VG .",
                "tactic_args": [
                    "c2_goal : forall (z : nval) (_ : nge x z), nge All z"
                ],
                "tactic_res": [
                    "c5_goal : nge All w",
                    "c5_w : nval",
                    "c5_VG : nge x w"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c5_goal : nge All w",
                    "c5_VG : nge x w"
                ],
                "tactic_res": [
                    "c6_goal : nge All w",
                    "c7_goal : nge All Nothing",
                    "c8_goal : nge All (I m2)",
                    "c8_H : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m2 i) true), eq (Int.testbit m1 i) true",
                    "c8_m2 : Int.int",
                    "c8_m1 : Int.int"
                ]
            },
            {
                "tactic_sig": "eauto with na .",
                "tactic_sig_no_out_arg": "eauto with na .",
                "tactic_args": [
                    "c6_goal : nge All w"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with na .",
                "tactic_sig_no_out_arg": "eauto with na .",
                "tactic_args": [
                    "c7_goal : nge All Nothing"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with na .",
                "tactic_sig_no_out_arg": "eauto with na .",
                "tactic_args": [
                    "c8_goal : nge All (I m2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros w VG .",
                "tactic_args": [
                    "c3_goal : forall (z : nval) (_ : nge Nothing z), nge x z"
                ],
                "tactic_res": [
                    "c9_goal : nge x w",
                    "c9_w : nval",
                    "c9_VG : nge Nothing w"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c9_goal : nge x w",
                    "c9_VG : nge Nothing w"
                ],
                "tactic_res": [
                    "c10_goal : nge x Nothing"
                ]
            },
            {
                "tactic_sig": "eauto with na .",
                "tactic_sig_no_out_arg": "eauto with na .",
                "tactic_args": [
                    "c10_goal : nge x Nothing"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros w VG .",
                "tactic_args": [
                    "c4_goal : forall (z : nval) (_ : nge (I m2) z), nge (I m1) z"
                ],
                "tactic_res": [
                    "c11_goal : nge (I m1) w",
                    "c11_w : nval",
                    "c11_VG : nge (I m2) w"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c11_goal : nge (I m1) w",
                    "c11_VG : nge (I m2) w"
                ],
                "tactic_res": [
                    "c12_goal : nge (I m1) Nothing",
                    "c13_goal : nge (I m1) (I m3)",
                    "c13_H1 : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m3 i) true), eq (Int.testbit m2 i) true",
                    "c13_m3 : Int.int"
                ]
            },
            {
                "tactic_sig": "eauto with na .",
                "tactic_sig_no_out_arg": "eauto with na .",
                "tactic_args": [
                    "c12_goal : nge (I m1) Nothing"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto with na .",
                "tactic_sig_no_out_arg": "eauto with na .",
                "tactic_args": [
                    "c13_goal : nge (I m1) (I m3)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nge_agree",
        "proof": [
            {
                "tactic_sig": "Lemma nge_agree : forall v w x y , nge x y -> vagree v w x -> vagree v w y .",
                "tactic_sig_no_out_arg": "Lemma nge_agree : forall v w x y , nge x y -> vagree v w x -> vagree v w y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (x y : nval) (_ : nge x y) (_ : vagree v w x),\nvagree v w y"
                ]
            },
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (x y : nval) (_ : nge x y) (_ : vagree v w x),\nvagree v w y"
                ],
                "tactic_res": [
                    "c2_goal : forall _ : vagree v w All, vagree v w x",
                    "c2_x : nval",
                    "c2_w : val",
                    "c2_v : val",
                    "c3_goal : forall _ : vagree v w x, vagree v w Nothing",
                    "c3_x : nval",
                    "c3_w : val",
                    "c3_v : val",
                    "c4_goal : forall _ : vagree v w (I m1), vagree v w (I m2)",
                    "c4_H : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m2 i) true), eq (Int.testbit m1 i) true",
                    "c4_m2 : Int.int",
                    "c4_m1 : Int.int",
                    "c4_w : val",
                    "c4_v : val"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : forall _ : vagree v w All, vagree v w x"
                ],
                "tactic_res": [
                    "c5_goal : forall _ : Val.lessdef v w, vagree v w x"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall _ : vagree v w x, vagree v w Nothing"
                ],
                "tactic_res": [
                    "c6_goal : forall _ : vagree v w x, True"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall _ : vagree v w x, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : forall _ : vagree v w (I m1), vagree v w (I m2)"
                ],
                "tactic_res": [
                    "c7_goal : forall\n  _ : match v with\n      | Vint p =>\n          match w with\n          | Vint q => iagree p q m1\n          | _ => False\n          end\n      | _ => True\n      end,\nmatch v with\n| Vint p => match w with\n            | Vint q => iagree p q m2\n            | _ => False\n            end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | _o | _o | _o | _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c5_goal : forall _ : Val.lessdef v w, vagree v w x",
                    "c2_v : val"
                ],
                "tactic_res": [
                    "c8_goal : forall _ : Val.lessdef Vundef w, vagree Vundef w x",
                    "c9_goal : forall _ : Val.lessdef (Vint i) w, vagree (Vint i) w x",
                    "c9_i : Int.int",
                    "c10_goal : forall _ : Val.lessdef (Vlong i) w, vagree (Vlong i) w x",
                    "c10_i : Int64.int",
                    "c11_goal : forall _ : Val.lessdef (Vfloat f) w, vagree (Vfloat f) w x",
                    "c11_f : float",
                    "c12_goal : forall _ : Val.lessdef (Vsingle f) w, vagree (Vsingle f) w x",
                    "c12_f : float32",
                    "c13_goal : forall _ : Val.lessdef (Vptr b i) w, vagree (Vptr b i) w x",
                    "c13_i : Ptrofs.int",
                    "c13_b : block"
                ]
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c8_goal : forall _ : Val.lessdef Vundef w, vagree Vundef w x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c9_goal : forall _ : Val.lessdef (Vint i) w, vagree (Vint i) w x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c10_goal : forall _ : Val.lessdef (Vlong i) w, vagree (Vlong i) w x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c11_goal : forall _ : Val.lessdef (Vfloat f) w, vagree (Vfloat f) w x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c12_goal : forall _ : Val.lessdef (Vsingle f) w, vagree (Vsingle f) w x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c13_goal : forall _ : Val.lessdef (Vptr b i) w, vagree (Vptr b i) w x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i , _i as [  | _o | _o | _o | _o | _o _o | _o | _o _o | _o _o | _o _o | _o _o | _o _o _o | _o | _o _o | _o _o | _o _o | _o _o | _o _o _o | _o | _o _o | _o _o | _o _o | _o _o | _o _o _o | _o | _o _o | _o _o | _o _o | _o _o | _o _o _o | _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i , _i .",
                "tactic_args": [
                    "c7_goal : forall\n  _ : match v with\n      | Vint p =>\n          match w with\n          | Vint q => iagree p q m1\n          | _ => False\n          end\n      | _ => True\n      end,\nmatch v with\n| Vint p => match w with\n            | Vint q => iagree p q m2\n            | _ => False\n            end\n| _ => True\nend",
                    "c2_v : val",
                    "c2_w : val"
                ],
                "tactic_res": [
                    "c14_goal : forall _ : True, True",
                    "c15_goal : forall _ : True, True",
                    "c15_i : Int.int",
                    "c16_goal : forall _ : True, True",
                    "c16_i : Int64.int",
                    "c17_goal : forall _ : True, True",
                    "c17_f : float",
                    "c18_goal : forall _ : True, True",
                    "c18_f : float32",
                    "c19_goal : forall _ : True, True",
                    "c19_i : Ptrofs.int",
                    "c19_b : block",
                    "c20_goal : forall _ : False, False",
                    "c20_i : Int.int",
                    "c21_goal : forall _ : iagree i i0 m1, iagree i i0 m2",
                    "c21_i0 : Int.int",
                    "c21_i : Int.int",
                    "c22_goal : forall _ : False, False",
                    "c22_i0 : Int64.int",
                    "c22_i : Int.int",
                    "c23_goal : forall _ : False, False",
                    "c23_f : float",
                    "c23_i : Int.int",
                    "c24_goal : forall _ : False, False",
                    "c24_f : float32",
                    "c24_i : Int.int",
                    "c25_goal : forall _ : False, False",
                    "c25_i0 : Ptrofs.int",
                    "c25_b : block",
                    "c25_i : Int.int",
                    "c26_goal : forall _ : True, True",
                    "c26_i : Int64.int",
                    "c27_goal : forall _ : True, True",
                    "c27_i0 : Int.int",
                    "c27_i : Int64.int",
                    "c28_goal : forall _ : True, True",
                    "c28_i0 : Int64.int",
                    "c28_i : Int64.int",
                    "c29_goal : forall _ : True, True",
                    "c29_f : float",
                    "c29_i : Int64.int",
                    "c30_goal : forall _ : True, True",
                    "c30_f : float32",
                    "c30_i : Int64.int",
                    "c31_goal : forall _ : True, True",
                    "c31_i0 : Ptrofs.int",
                    "c31_b : block",
                    "c31_i : Int64.int",
                    "c32_goal : forall _ : True, True",
                    "c32_f : float",
                    "c33_goal : forall _ : True, True",
                    "c33_i : Int.int",
                    "c33_f : float",
                    "c34_goal : forall _ : True, True",
                    "c34_i : Int64.int",
                    "c34_f : float",
                    "c35_goal : forall _ : True, True",
                    "c35_f0 : float",
                    "c35_f : float",
                    "c36_goal : forall _ : True, True",
                    "c36_f0 : float32",
                    "c36_f : float",
                    "c37_goal : forall _ : True, True",
                    "c37_i : Ptrofs.int",
                    "c37_b : block",
                    "c37_f : float",
                    "c38_goal : forall _ : True, True",
                    "c38_f : float32",
                    "c39_goal : forall _ : True, True",
                    "c39_i : Int.int",
                    "c39_f : float32",
                    "c40_goal : forall _ : True, True",
                    "c40_i : Int64.int",
                    "c40_f : float32",
                    "c41_goal : forall _ : True, True",
                    "c41_f0 : float",
                    "c41_f : float32",
                    "c42_goal : forall _ : True, True",
                    "c42_f0 : float32",
                    "c42_f : float32",
                    "c43_goal : forall _ : True, True",
                    "c43_i : Ptrofs.int",
                    "c43_b : block",
                    "c43_f : float32",
                    "c44_goal : forall _ : True, True",
                    "c44_i : Ptrofs.int",
                    "c44_b : block",
                    "c45_goal : forall _ : True, True",
                    "c45_i0 : Int.int",
                    "c45_i : Ptrofs.int",
                    "c45_b : block",
                    "c46_goal : forall _ : True, True",
                    "c46_i0 : Int64.int",
                    "c46_i : Ptrofs.int",
                    "c46_b : block",
                    "c47_goal : forall _ : True, True",
                    "c47_f : float",
                    "c47_i : Ptrofs.int",
                    "c47_b : block",
                    "c48_goal : forall _ : True, True",
                    "c48_f : float32",
                    "c48_i : Ptrofs.int",
                    "c48_b : block",
                    "c49_goal : forall _ : True, True",
                    "c49_i0 : Ptrofs.int",
                    "c49_b0 : block",
                    "c49_i : Ptrofs.int",
                    "c49_b : block"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c14_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c15_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c16_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c17_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c18_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c19_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c20_goal : forall _ : False, False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c21_goal : forall _ : iagree i i0 m1, iagree i i0 m2"
                ],
                "tactic_res": [
                    "c50_goal : iagree i i0 m2",
                    "c50_H0 : iagree i i0 m1"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c22_goal : forall _ : False, False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c23_goal : forall _ : False, False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c24_goal : forall _ : False, False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c25_goal : forall _ : False, False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c26_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c27_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c28_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c29_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c30_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c31_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c32_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c33_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c34_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c35_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c36_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c37_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c38_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c39_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c40_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c41_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c42_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c43_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c44_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c45_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c46_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c47_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c48_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c49_goal : forall _ : True, True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c50_goal : iagree i i0 m2"
                ],
                "tactic_res": [
                    "c51_goal : forall (i1 : Z) (_ : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize))\n  (_ : eq (Int.testbit m2 i1) true),\neq (Int.testbit i i1) (Int.testbit i0 i1)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c51_goal : forall (i1 : Z) (_ : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize))\n  (_ : eq (Int.testbit m2 i1) true),\neq (Int.testbit i i1) (Int.testbit i0 i1)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nge_lub_l",
        "proof": [
            {
                "tactic_sig": "Lemma nge_lub_l : forall x y , nge ( nlub x y ) x .",
                "tactic_sig_no_out_arg": "Lemma nge_lub_l : forall x y , nge ( nlub x y ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : nval, nge (nlub x y) x"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall x y : nval, nge (nlub x y) x",
                    "_global_1 : Z",
                    "_global_nlub : forall (_ : nval) (_ : nval), nval"
                ],
                "tactic_res": [
                    "c2_goal : forall x y : nval,\nnge\n  match x with\n  | Nothing => y\n  | I m1 =>\n      match y with\n      | Nothing => x\n      | I m2 => I (Int.or m1 m2)\n      | All => All\n      end\n  | All => match y with\n           | Nothing => x\n           | _ => All\n           end\n  end x"
                ]
            },
            {
                "tactic_sig": "destruct x , y as [  | _o | | _o | _o _o | _o | | _o | ] .",
                "tactic_sig_no_out_arg": "destruct x , y .",
                "tactic_args": [
                    "c2_goal : forall x y : nval,\nnge\n  match x with\n  | Nothing => y\n  | I m1 =>\n      match y with\n      | Nothing => x\n      | I m2 => I (Int.or m1 m2)\n      | All => All\n      end\n  | All => match y with\n           | Nothing => x\n           | _ => All\n           end\n  end x"
                ],
                "tactic_res": [
                    "c3_goal : nge Nothing Nothing",
                    "c4_goal : nge (I m) Nothing",
                    "c4_m : Int.int",
                    "c5_goal : nge All Nothing",
                    "c6_goal : nge (I m) (I m)",
                    "c6_m : Int.int",
                    "c7_goal : nge (I (Int.or m m0)) (I m)",
                    "c7_m0 : Int.int",
                    "c7_m : Int.int",
                    "c8_goal : nge All (I m)",
                    "c8_m : Int.int",
                    "c9_goal : nge All All",
                    "c10_goal : nge All All",
                    "c10_m : Int.int",
                    "c11_goal : nge All All"
                ]
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c3_goal : nge Nothing Nothing"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c4_goal : nge (I m) Nothing"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c5_goal : nge All Nothing"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c6_goal : nge (I m) (I m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c8_goal : nge All (I m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c9_goal : nge All All"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c10_goal : nge All All"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c11_goal : nge All All"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : nge (I (Int.or m m0)) (I m)"
                ],
                "tactic_res": [
                    "c12_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true),\neq (Int.testbit (Int.or m m0) i) true"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c12_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true),\neq (Int.testbit (Int.or m m0) i) true"
                ],
                "tactic_res": [
                    "c13_goal : eq (Int.testbit (Int.or m m0) i) true",
                    "c13_i : Z",
                    "c13_H : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                    "c13_H0 : eq (Int.testbit m i) true"
                ]
            },
            {
                "tactic_sig": "autorewrite with ints .",
                "tactic_sig_no_out_arg": "autorewrite with ints .",
                "tactic_args": [
                    "c13_goal : eq (Int.testbit (Int.or m m0) i) true"
                ],
                "tactic_res": [
                    "c14_goal : eq (orb (Int.testbit m i) (Int.testbit m0 i)) true",
                    "c15_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c14_goal : eq (orb (Int.testbit m i) (Int.testbit m0 i)) true",
                    "_global_1 : Z",
                    "c13_H0 : eq (Int.testbit m i) true"
                ],
                "tactic_res": [
                    "c16_goal : eq (orb true (Int.testbit m0 i)) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : eq (orb true (Int.testbit m0 i)) true"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nge_lub_r",
        "proof": [
            {
                "tactic_sig": "Lemma nge_lub_r : forall x y , nge ( nlub x y ) y .",
                "tactic_sig_no_out_arg": "Lemma nge_lub_r : forall x y , nge ( nlub x y ) y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : nval, nge (nlub x y) y"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall x y : nval, nge (nlub x y) y",
                    "_global_1 : Z",
                    "_global_nlub : forall (_ : nval) (_ : nval), nval"
                ],
                "tactic_res": [
                    "c2_goal : forall x y : nval,\nnge\n  match x with\n  | Nothing => y\n  | I m1 =>\n      match y with\n      | Nothing => x\n      | I m2 => I (Int.or m1 m2)\n      | All => All\n      end\n  | All => match y with\n           | Nothing => x\n           | _ => All\n           end\n  end y"
                ]
            },
            {
                "tactic_sig": "destruct x , y as [  | _o | | _o | _o _o | _o | | _o | ] .",
                "tactic_sig_no_out_arg": "destruct x , y .",
                "tactic_args": [
                    "c2_goal : forall x y : nval,\nnge\n  match x with\n  | Nothing => y\n  | I m1 =>\n      match y with\n      | Nothing => x\n      | I m2 => I (Int.or m1 m2)\n      | All => All\n      end\n  | All => match y with\n           | Nothing => x\n           | _ => All\n           end\n  end y"
                ],
                "tactic_res": [
                    "c3_goal : nge Nothing Nothing",
                    "c4_goal : nge (I m) (I m)",
                    "c4_m : Int.int",
                    "c5_goal : nge All All",
                    "c6_goal : nge (I m) Nothing",
                    "c6_m : Int.int",
                    "c7_goal : nge (I (Int.or m m0)) (I m0)",
                    "c7_m0 : Int.int",
                    "c7_m : Int.int",
                    "c8_goal : nge All All",
                    "c8_m : Int.int",
                    "c9_goal : nge All Nothing",
                    "c10_goal : nge All (I m)",
                    "c10_m : Int.int",
                    "c11_goal : nge All All"
                ]
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c3_goal : nge Nothing Nothing"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c4_goal : nge (I m) (I m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c5_goal : nge All All"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c6_goal : nge (I m) Nothing"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c8_goal : nge All All"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c9_goal : nge All Nothing"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c10_goal : nge All (I m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c11_goal : nge All All"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : nge (I (Int.or m m0)) (I m0)"
                ],
                "tactic_res": [
                    "c12_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m0 i) true),\neq (Int.testbit (Int.or m m0) i) true"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c12_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m0 i) true),\neq (Int.testbit (Int.or m m0) i) true"
                ],
                "tactic_res": [
                    "c13_goal : eq (Int.testbit (Int.or m m0) i) true",
                    "c13_i : Z",
                    "c13_H : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                    "c13_H0 : eq (Int.testbit m0 i) true"
                ]
            },
            {
                "tactic_sig": "autorewrite with ints .",
                "tactic_sig_no_out_arg": "autorewrite with ints .",
                "tactic_args": [
                    "c13_goal : eq (Int.testbit (Int.or m m0) i) true"
                ],
                "tactic_res": [
                    "c14_goal : eq (orb (Int.testbit m i) (Int.testbit m0 i)) true",
                    "c15_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c14_goal : eq (orb (Int.testbit m i) (Int.testbit m0 i)) true",
                    "_global_1 : Z",
                    "c13_H0 : eq (Int.testbit m0 i) true"
                ],
                "tactic_res": [
                    "c16_goal : eq (orb (Int.testbit m i) true) true"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c16_goal : eq (orb (Int.testbit m i) true) true",
                    "_global_1 : Z",
                    "_global_orb_true_r : forall b : bool, eq (orb b true) true"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "iagree_refl",
        "proof": [
            {
                "tactic_sig": "Lemma iagree_refl : forall p m , iagree p p m .",
                "tactic_sig_no_out_arg": "Lemma iagree_refl : forall p m , iagree p p m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall p m : Int.int, iagree p p m"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall p m : Int.int, iagree p p m"
                ],
                "tactic_res": [
                    "c2_goal : iagree p p m",
                    "c2_p : Int.int",
                    "c2_m : Int.int"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : iagree p p m"
                ],
                "tactic_res": [
                    "c3_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true),\neq (Int.testbit p i) (Int.testbit p i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true),\neq (Int.testbit p i) (Int.testbit p i)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eq_same_bits",
        "proof": [
            {
                "tactic_sig": "Remark eq_same_bits : forall i x y , x = y -> Int.testbit x i = Int.testbit y i .",
                "tactic_sig_no_out_arg": "Remark eq_same_bits : forall i x y , x = y -> Int.testbit x i = Int.testbit y i .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (i : Z) (x y : Int.int) (_ : eq x y),\neq (Int.testbit x i) (Int.testbit y i)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (i : Z) (x y : Int.int) (_ : eq x y),\neq (Int.testbit x i) (Int.testbit y i)"
                ],
                "tactic_res": [
                    "c2_goal : eq (Int.testbit x i) (Int.testbit y i)",
                    "c2_i : Z",
                    "c2_x : Int.int",
                    "c2_y : Int.int",
                    "c2_H : eq x y"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c2_goal : eq (Int.testbit x i) (Int.testbit y i)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "iagree_and_eq",
        "proof": [
            {
                "tactic_sig": "Lemma iagree_and_eq : forall x y mask , iagree x y mask <- > Int.and x mask = Int.and y mask .",
                "tactic_sig_no_out_arg": "Lemma iagree_and_eq : forall x y mask , iagree x y mask <- > Int.and x mask = Int.and y mask .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y mask : Int.int,\niff (iagree x y mask) (eq (Int.and x mask) (Int.and y mask))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall x y mask : Int.int,\niff (iagree x y mask) (eq (Int.and x mask) (Int.and y mask))"
                ],
                "tactic_res": [
                    "c2_goal : iff (iagree x y mask) (eq (Int.and x mask) (Int.and y mask))",
                    "c2_x : Int.int",
                    "c2_y : Int.int",
                    "c2_mask : Int.int"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c2_goal : iff (iagree x y mask) (eq (Int.and x mask) (Int.and y mask))"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : iagree x y mask, eq (Int.and x mask) (Int.and y mask)",
                    "c4_goal : forall _ : eq (Int.and x mask) (Int.and y mask), iagree x y mask"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall _ : iagree x y mask, eq (Int.and x mask) (Int.and y mask)"
                ],
                "tactic_res": [
                    "c5_goal : eq (Int.and x mask) (Int.and y mask)",
                    "c5_H : iagree x y mask"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall _ : eq (Int.and x mask) (Int.and y mask), iagree x y mask"
                ],
                "tactic_res": [
                    "c6_goal : iagree x y mask",
                    "c6_H : eq (Int.and x mask) (Int.and y mask)"
                ]
            },
            {
                "tactic_sig": "Int.bit_solve .",
                "tactic_sig_no_out_arg": "Int.bit_solve .",
                "tactic_args": [
                    "c5_goal : eq (Int.and x mask) (Int.and y mask)"
                ],
                "tactic_res": [
                    "c7_goal : eq (andb (Int.testbit x i) (Int.testbit mask i))\n  (andb (Int.testbit y i) (Int.testbit mask i))",
                    "c7_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                    "c7_i : Z"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i _i ) .",
                "tactic_args": [
                    "c5_H : iagree x y mask",
                    "c7_i : Z",
                    "c7_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)"
                ],
                "tactic_res": [
                    "c7_H : forall _ : eq (Int.testbit mask i) true,\neq (Int.testbit x i) (Int.testbit y i)"
                ]
            },
            {
                "tactic_sig": "destruct ( Int.testbit _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Int.testbit _i _i ) .",
                "tactic_args": [
                    "c7_goal : eq (andb (Int.testbit x i) (Int.testbit mask i))\n  (andb (Int.testbit y i) (Int.testbit mask i))",
                    "c2_mask : Int.int",
                    "c7_i : Z"
                ],
                "tactic_res": [
                    "c8_goal : eq (andb (Int.testbit x i) true) (andb (Int.testbit y i) true)",
                    "c8_H : forall _ : eq true true, eq (Int.testbit x i) (Int.testbit y i)",
                    "c9_goal : eq (andb (Int.testbit x i) false) (andb (Int.testbit y i) false)",
                    "c9_H : forall _ : eq false true, eq (Int.testbit x i) (Int.testbit y i)"
                ]
            },
            {
                "tactic_sig": "rewrite ! _i .",
                "tactic_sig_no_out_arg": "rewrite ! _i .",
                "tactic_args": [
                    "c8_goal : eq (andb (Int.testbit x i) true) (andb (Int.testbit y i) true)",
                    "_global_1 : Z",
                    "_global_andb_true_r : forall b : bool, eq (andb b true) b"
                ],
                "tactic_res": [
                    "c10_goal : eq (Int.testbit x i) (Int.testbit y i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : eq (Int.testbit x i) (Int.testbit y i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ! _i .",
                "tactic_sig_no_out_arg": "rewrite ! _i .",
                "tactic_args": [
                    "c9_goal : eq (andb (Int.testbit x i) false) (andb (Int.testbit y i) false)",
                    "_global_1 : Z",
                    "_global_andb_false_r : forall b : bool, eq (andb b false) false"
                ],
                "tactic_res": [
                    "c11_goal : eq false false"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : eq false false"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c6_goal : iagree x y mask"
                ],
                "tactic_res": [
                    "c12_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit mask i) true),\neq (Int.testbit x i) (Int.testbit y i)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c12_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit mask i) true),\neq (Int.testbit x i) (Int.testbit y i)"
                ],
                "tactic_res": [
                    "c13_goal : eq (Int.testbit x i) (Int.testbit y i)",
                    "c13_i : Z",
                    "c13_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                    "c13_H1 : eq (Int.testbit mask i) true"
                ]
            },
            {
                "tactic_sig": "exploit ( eq_same_bits _i ) .",
                "tactic_sig_no_out_arg": "exploit ( eq_same_bits _i ) .",
                "tactic_args": [
                    "c13_goal : eq (Int.testbit x i) (Int.testbit y i)",
                    "c13_i : Z"
                ],
                "tactic_res": [
                    "c14_goal : eq ?Goal ?Goal0",
                    "c15_goal : forall _ : eq (Int.testbit ?Goal i) (Int.testbit ?Goal0 i),\neq (Int.testbit x i) (Int.testbit y i)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c14_goal : eq ?Goal ?Goal0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "autorewrite with ints .",
                "tactic_sig_no_out_arg": "autorewrite with ints .",
                "tactic_args": [
                    "c15_goal : forall\n  _ : eq (Int.testbit (Int.and x mask) i)\n        (Int.testbit (Int.and y mask) i),\neq (Int.testbit x i) (Int.testbit y i)"
                ],
                "tactic_res": [
                    "c16_goal : forall\n  _ : eq (andb (Int.testbit x i) (Int.testbit mask i))\n        (andb (Int.testbit y i) (Int.testbit mask i)),\neq (Int.testbit x i) (Int.testbit y i)",
                    "c17_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                    "c18_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c16_goal : forall\n  _ : eq (andb (Int.testbit x i) (Int.testbit mask i))\n        (andb (Int.testbit y i) (Int.testbit mask i)),\neq (Int.testbit x i) (Int.testbit y i)",
                    "_global_1 : Z",
                    "c13_H1 : eq (Int.testbit mask i) true"
                ],
                "tactic_res": [
                    "c19_goal : forall\n  _ : eq (andb (Int.testbit x i) true) (andb (Int.testbit y i) true),\neq (Int.testbit x i) (Int.testbit y i)"
                ]
            },
            {
                "tactic_sig": "rewrite ! _i .",
                "tactic_sig_no_out_arg": "rewrite ! _i .",
                "tactic_args": [
                    "c19_goal : forall\n  _ : eq (andb (Int.testbit x i) true) (andb (Int.testbit y i) true),\neq (Int.testbit x i) (Int.testbit y i)",
                    "_global_1 : Z",
                    "_global_andb_true_r : forall b : bool, eq (andb b true) b"
                ],
                "tactic_res": [
                    "c20_goal : forall _ : eq (Int.testbit x i) (Int.testbit y i),\neq (Int.testbit x i) (Int.testbit y i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c20_goal : forall _ : eq (Int.testbit x i) (Int.testbit y i),\neq (Int.testbit x i) (Int.testbit y i)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "iagree_mone",
        "proof": [
            {
                "tactic_sig": "Lemma iagree_mone : forall p q , iagree p q Int.mone -> p = q .",
                "tactic_sig_no_out_arg": "Lemma iagree_mone : forall p q , iagree p q Int.mone -> p = q .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (p q : Int.int) (_ : iagree p q Int.mone), eq p q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (p q : Int.int) (_ : iagree p q Int.mone), eq p q"
                ],
                "tactic_res": [
                    "c2_goal : eq p q",
                    "c2_p : Int.int",
                    "c2_q : Int.int",
                    "c2_H : iagree p q Int.mone"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "_global_iagree_and_eq : forall x y mask : Int.int,\n       iff (iagree x y mask) (eq (Int.and x mask) (Int.and y mask))",
                    "c2_H : iagree p q Int.mone"
                ],
                "tactic_res": [
                    "c2_H : eq (Int.and p Int.mone) (Int.and q Int.mone)"
                ]
            },
            {
                "tactic_sig": "rewrite ! Int.and_mone in _i .",
                "tactic_sig_no_out_arg": "rewrite ! Int.and_mone in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c2_H : iagree p q Int.mone"
                ],
                "tactic_res": [
                    "c2_H : eq p q"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c2_goal : eq p q"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "iagree_zero",
        "proof": [
            {
                "tactic_sig": "Lemma iagree_zero : forall p q , iagree p q Int.zero .",
                "tactic_sig_no_out_arg": "Lemma iagree_zero : forall p q , iagree p q Int.zero .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall p q : Int.int, iagree p q Int.zero"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall p q : Int.int, iagree p q Int.zero"
                ],
                "tactic_res": [
                    "c2_goal : iagree p q Int.zero",
                    "c2_p : Int.int",
                    "c2_q : Int.int"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c2_goal : iagree p q Int.zero",
                    "_global_1 : Z",
                    "_global_iagree_and_eq : forall x y mask : Int.int,\n       iff (iagree x y mask) (eq (Int.and x mask) (Int.and y mask))"
                ],
                "tactic_res": [
                    "c3_goal : eq (Int.and p Int.zero) (Int.and q Int.zero)"
                ]
            },
            {
                "tactic_sig": "rewrite ! Int.and_zero .",
                "tactic_sig_no_out_arg": "rewrite ! Int.and_zero .",
                "tactic_args": [
                    "c3_goal : eq (Int.and p Int.zero) (Int.and q Int.zero)",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c4_goal : eq Int.zero Int.zero"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : eq Int.zero Int.zero"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "iagree_and",
        "proof": [
            {
                "tactic_sig": "Lemma iagree_and : forall x y n m , iagree x y ( Int.and m n ) -> iagree ( Int.and x n ) ( Int.and y n ) m .",
                "tactic_sig_no_out_arg": "Lemma iagree_and : forall x y n m , iagree x y ( Int.and m n ) -> iagree ( Int.and x n ) ( Int.and y n ) m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m n)),\niagree (Int.and x n) (Int.and y n) m"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m n)),\niagree (Int.and x n) (Int.and y n) m"
                ],
                "tactic_res": [
                    "c2_goal : iagree (Int.and x n) (Int.and y n) m",
                    "c2_x : Int.int",
                    "c2_y : Int.int",
                    "c2_n : Int.int",
                    "c2_m : Int.int",
                    "c2_H : iagree x y (Int.and m n)"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "c2_goal : iagree (Int.and x n) (Int.and y n) m",
                    "_global_1 : Z",
                    "_global_iagree_and_eq : forall x y mask : Int.int,\n       iff (iagree x y mask) (eq (Int.and x mask) (Int.and y mask))"
                ],
                "tactic_res": [
                    "c3_goal : eq (Int.and (Int.and x n) m) (Int.and (Int.and y n) m)",
                    "c3_H : eq (Int.and x (Int.and m n)) (Int.and y (Int.and m n))"
                ]
            },
            {
                "tactic_sig": "rewrite ! Int._i .",
                "tactic_sig_no_out_arg": "rewrite ! Int._i .",
                "tactic_args": [
                    "c3_goal : eq (Int.and (Int.and x n) m) (Int.and (Int.and y n) m)",
                    "_global_1 : Z",
                    "_global_and_assoc : forall A B C : Prop,\n       iff (Logic.and (Logic.and A B) C) (Logic.and A (Logic.and B C))"
                ],
                "tactic_res": [
                    "c4_goal : eq (Int.and x (Int.and n m)) (Int.and y (Int.and n m))"
                ]
            },
            {
                "tactic_sig": "rewrite ( Int.and_commut _i ) .",
                "tactic_sig_no_out_arg": "rewrite ( Int.and_commut _i ) .",
                "tactic_args": [
                    "c4_goal : eq (Int.and x (Int.and n m)) (Int.and y (Int.and n m))",
                    "_global_1 : Z",
                    "c2_n : Int.int"
                ],
                "tactic_res": [
                    "c5_goal : eq (Int.and x (Int.and m n)) (Int.and y (Int.and m n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : eq (Int.and x (Int.and m n)) (Int.and y (Int.and m n))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "iagree_not",
        "proof": [
            {
                "tactic_sig": "Lemma iagree_not : forall x y m , iagree x y m -> iagree ( Int.not x ) ( Int.not y ) m .",
                "tactic_sig_no_out_arg": "Lemma iagree_not : forall x y m , iagree x y m -> iagree ( Int.not x ) ( Int.not y ) m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                    "c2_goal : iagree (Int.not x) (Int.not y) m",
                    "c2_x : Int.int",
                    "c2_y : Int.int",
                    "c2_m : Int.int",
                    "c2_H : iagree x y m"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                    "c3_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true),\neq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true),\neq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
                ],
                "tactic_res": [
                    "c4_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                    "c4_i : Z",
                    "c4_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                    "c4_H1 : eq (Int.testbit m i) true"
                ]
            },
            {
                "tactic_sig": "autorewrite with ints .",
                "tactic_sig_no_out_arg": "autorewrite with ints .",
                "tactic_args": [
                    "c4_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
                ],
                "tactic_res": [
                    "c5_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                    "c6_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                    "c7_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c5_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": [
                    "c8_goal : eq (Int.testbit x i) (Int.testbit y i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : eq (Int.testbit x i) (Int.testbit y i)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "iagree_not'",
        "proof": [
            {
                "tactic_sig": "Lemma iagree_not' : forall x y m , iagree ( Int.not x ) ( Int.not y ) m -> iagree x y m .",
                "tactic_sig_no_out_arg": "Lemma iagree_not' : forall x y m , iagree ( Int.not x ) ( Int.not y ) m -> iagree x y m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y m : Int.int) (_ : iagree (Int.not x) (Int.not y) m),\niagree x y m"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (x y m : Int.int) (_ : iagree (Int.not x) (Int.not y) m),\niagree x y m"
                ],
                "tactic_res": [
                    "c2_goal : iagree x y m",
                    "c2_x : Int.int",
                    "c2_y : Int.int",
                    "c2_m : Int.int",
                    "c2_H : iagree (Int.not x) (Int.not y) m"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( Int.not_involutive _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( Int.not_involutive _i ) .",
                "tactic_args": [
                    "c2_goal : iagree x y m",
                    "_global_1 : Z",
                    "c2_x : Int.int"
                ],
                "tactic_res": [
                    "c3_goal : iagree (Int.not (Int.not x)) y m"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( Int.not_involutive _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( Int.not_involutive _i ) .",
                "tactic_args": [
                    "c3_goal : iagree (Int.not (Int.not x)) y m",
                    "_global_1 : Z",
                    "c2_y : Int.int"
                ],
                "tactic_res": [
                    "c4_goal : iagree (Int.not (Int.not x)) (Int.not (Int.not y)) m"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : iagree (Int.not (Int.not x)) (Int.not (Int.not y)) m",
                    "_global_1 : Z",
                    "_global_iagree_not : forall (x y m : Int.int) (_ : iagree x y m),\n       iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                    "c5_goal : iagree (Int.not x) (Int.not y) m"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "iagree_or",
        "proof": [
            {
                "tactic_sig": "Lemma iagree_or : forall x y n m , iagree x y ( Int.and m ( Int.not n ) ) -> iagree ( Int.or x n ) ( Int.or y n ) m .",
                "tactic_sig_no_out_arg": "Lemma iagree_or : forall x y n m , iagree x y ( Int.and m ( Int.not n ) ) -> iagree ( Int.or x n ) ( Int.or y n ) m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
                ],
                "tactic_res": [
                    "c2_goal : iagree (Int.or x n) (Int.or y n) m",
                    "c2_x : Int.int",
                    "c2_y : Int.int",
                    "c2_n : Int.int",
                    "c2_m : Int.int",
                    "c2_H : iagree x y (Int.and m (Int.not n))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : iagree (Int.or x n) (Int.or y n) m",
                    "_global_1 : Z",
                    "_global_iagree_not' : forall (x y m : Int.int) (_ : iagree (Int.not x) (Int.not y) m),\n       iagree x y m"
                ],
                "tactic_res": [
                    "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ]
            },
            {
                "tactic_sig": "rewrite ! Int.not_or_and_not .",
                "tactic_sig_no_out_arg": "rewrite ! Int.not_or_and_not .",
                "tactic_args": [
                    "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c4_goal : iagree (Int.and (Int.not x) (Int.not n))\n  (Int.and (Int.not y) (Int.not n)) m"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : iagree (Int.and (Int.not x) (Int.not n))\n  (Int.and (Int.not y) (Int.not n)) m",
                    "_global_1 : Z",
                    "_global_iagree_and : forall (x y n m : Int.int) (_ : iagree x y (Int.and m n)),\n       iagree (Int.and x n) (Int.and y n) m"
                ],
                "tactic_res": [
                    "c5_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))",
                    "_global_1 : Z",
                    "_global_iagree_not : forall (x y m : Int.int) (_ : iagree x y m),\n       iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                    "c6_goal : iagree x y (Int.and m (Int.not n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : iagree x y (Int.and m (Int.not n))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "iagree_bitwise_binop",
        "proof": [
            {
                "tactic_sig": "Lemma iagree_bitwise_binop : forall sem f , ( forall x y i , 0 <= i < Int.zwordsize -> Int.testbit ( f x y ) i = sem ( Int.testbit x i ) ( Int.testbit y i ) ) -> forall x1 x2 y1 y2 m , iagree x1 y1 m -> iagree x2 y2 m -> iagree ( f x1 x2 ) ( f y1 y2 ) m .",
                "tactic_sig_no_out_arg": "Lemma iagree_bitwise_binop : forall sem f , ( forall x y i , 0 <= i < Int.zwordsize -> Int.testbit ( f x y ) i = sem ( Int.testbit x i ) ( Int.testbit y i ) ) -> forall x1 x2 y1 y2 m , iagree x1 y1 m -> iagree x2 y2 m -> iagree ( f x1 x2 ) ( f y1 y2 ) m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
                ],
                "tactic_res": [
                    "c2_goal : iagree (f x1 x2) (f y1 y2) m",
                    "c2_sem : forall (_ : bool) (_ : bool), bool",
                    "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                    "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                    "c2_x1 : Int.int",
                    "c2_x2 : Int.int",
                    "c2_y1 : Int.int",
                    "c2_y2 : Int.int",
                    "c2_m : Int.int",
                    "c2_H0 : iagree x1 y1 m",
                    "c2_H1 : iagree x2 y2 m"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : iagree (f x1 x2) (f y1 y2) m"
                ],
                "tactic_res": [
                    "c3_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true),\neq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true),\neq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)"
                ],
                "tactic_res": [
                    "c4_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                    "c4_i : Z",
                    "c4_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                    "c4_H3 : eq (Int.testbit m i) true"
                ]
            },
            {
                "tactic_sig": "rewrite ! _i by auto .",
                "tactic_sig_no_out_arg": "rewrite ! _i by auto .",
                "tactic_args": [
                    "c4_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                    "_global_1 : Z",
                    "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))"
                ],
                "tactic_res": [
                    "c5_goal : eq (sem (Int.testbit x1 i) (Int.testbit x2 i))\n  (sem (Int.testbit y1 i) (Int.testbit y2 i))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c5_goal : eq (sem (Int.testbit x1 i) (Int.testbit x2 i))\n  (sem (Int.testbit y1 i) (Int.testbit y2 i))"
                ],
                "tactic_res": [
                    "c6_goal : eq (Int.testbit x1 i) (Int.testbit y1 i)",
                    "c7_goal : eq (Int.testbit x2 i) (Int.testbit y2 i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : eq (Int.testbit x1 i) (Int.testbit y1 i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : eq (Int.testbit x2 i) (Int.testbit y2 i)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "iagree_shl",
        "proof": [
            {
                "tactic_sig": "Lemma iagree_shl : forall x y m n , iagree x y ( Int.shru m n ) -> iagree ( Int.shl x n ) ( Int.shl y n ) m .",
                "tactic_sig_no_out_arg": "Lemma iagree_shl : forall x y m n , iagree x y ( Int.shru m n ) -> iagree ( Int.shl x n ) ( Int.shl y n ) m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y m n : Int.int) (_ : iagree x y (Int.shru m n)),\niagree (Int.shl x n) (Int.shl y n) m"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (x y m n : Int.int) (_ : iagree x y (Int.shru m n)),\niagree (Int.shl x n) (Int.shl y n) m"
                ],
                "tactic_res": [
                    "c2_goal : iagree (Int.shl x n) (Int.shl y n) m",
                    "c2_x : Int.int",
                    "c2_y : Int.int",
                    "c2_m : Int.int",
                    "c2_n : Int.int",
                    "c2_H : iagree x y (Int.shru m n)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : iagree (Int.shl x n) (Int.shl y n) m"
                ],
                "tactic_res": [
                    "c3_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true),\neq (Int.testbit (Int.shl x n) i) (Int.testbit (Int.shl y n) i)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true),\neq (Int.testbit (Int.shl x n) i) (Int.testbit (Int.shl y n) i)"
                ],
                "tactic_res": [
                    "c4_goal : eq (Int.testbit (Int.shl x n) i) (Int.testbit (Int.shl y n) i)",
                    "c4_i : Z",
                    "c4_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                    "c4_H1 : eq (Int.testbit m i) true"
                ]
            },
            {
                "tactic_sig": "autorewrite with ints .",
                "tactic_sig_no_out_arg": "autorewrite with ints .",
                "tactic_args": [
                    "c4_goal : eq (Int.testbit (Int.shl x n) i) (Int.testbit (Int.shl y n) i)"
                ],
                "tactic_res": [
                    "c5_goal : eq\n  (if zlt i (Int.unsigned n)\n   then false\n   else Int.testbit x (Z.sub i (Int.unsigned n)))\n  (if zlt i (Int.unsigned n)\n   then false\n   else Int.testbit y (Z.sub i (Int.unsigned n)))",
                    "c6_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                    "c7_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zlt _i ( Int.unsigned _i ) ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i ( Int.unsigned _i ) ) .",
                "tactic_args": [
                    "c5_goal : eq\n  (if zlt i (Int.unsigned n)\n   then false\n   else Int.testbit x (Z.sub i (Int.unsigned n)))\n  (if zlt i (Int.unsigned n)\n   then false\n   else Int.testbit y (Z.sub i (Int.unsigned n)))",
                    "c4_i : Z",
                    "c2_n : Int.int"
                ],
                "tactic_res": [
                    "c8_goal : eq false false",
                    "c8_l : Z.lt i (Int.unsigned n)",
                    "c9_goal : eq (Int.testbit x (Z.sub i (Int.unsigned n)))\n  (Int.testbit y (Z.sub i (Int.unsigned n)))",
                    "c9_g : Z.ge i (Int.unsigned n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : eq false false"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( Int.unsigned_range _i ) .",
                "tactic_sig_no_out_arg": "generalize ( Int.unsigned_range _i ) .",
                "tactic_args": [
                    "c9_goal : eq (Int.testbit x (Z.sub i (Int.unsigned n)))\n  (Int.testbit y (Z.sub i (Int.unsigned n)))",
                    "c2_n : Int.int"
                ],
                "tactic_res": [
                    "c10_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned n))\n        (Z.lt (Int.unsigned n) Int.modulus),\neq (Int.testbit x (Z.sub i (Int.unsigned n)))\n  (Int.testbit y (Z.sub i (Int.unsigned n)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c10_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned n))\n        (Z.lt (Int.unsigned n) Int.modulus),\neq (Int.testbit x (Z.sub i (Int.unsigned n)))\n  (Int.testbit y (Z.sub i (Int.unsigned n)))"
                ],
                "tactic_res": [
                    "c11_goal : eq (Int.testbit x (Z.sub i (Int.unsigned n)))\n  (Int.testbit y (Z.sub i (Int.unsigned n)))",
                    "c11_H2 : Logic.and (Z.le 0 (Int.unsigned n)) (Z.lt (Int.unsigned n) Int.modulus)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : eq (Int.testbit x (Z.sub i (Int.unsigned n)))\n  (Int.testbit y (Z.sub i (Int.unsigned n)))",
                    "_global_1 : Z",
                    "c2_H : iagree x y (Int.shru m n)"
                ],
                "tactic_res": [
                    "c12_goal : Logic.and (Z.le 0 (Z.sub i (Int.unsigned n)))\n  (Z.lt (Z.sub i (Int.unsigned n)) Int.zwordsize)",
                    "c13_goal : eq (Int.testbit (Int.shru m n) (Z.sub i (Int.unsigned n))) true"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c12_goal : Logic.and (Z.le 0 (Z.sub i (Int.unsigned n)))\n  (Z.lt (Z.sub i (Int.unsigned n)) Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite Int.bits_shru by lia .",
                "tactic_sig_no_out_arg": "rewrite Int.bits_shru by lia .",
                "tactic_args": [
                    "c13_goal : eq (Int.testbit (Int.shru m n) (Z.sub i (Int.unsigned n))) true",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c14_goal : eq\n  (if\n    zlt (Z.add (Z.sub i (Int.unsigned n)) (Int.unsigned n))\n      Int.zwordsize\n   then\n    Int.testbit m (Z.add (Z.sub i (Int.unsigned n)) (Int.unsigned n))\n   else false) true"
                ]
            },
            {
                "tactic_sig": "replace ( _i - Int.unsigned _i + Int.unsigned _i ) with _i by lia .",
                "tactic_sig_no_out_arg": "replace ( _i - Int.unsigned _i + Int.unsigned _i ) with _i by lia .",
                "tactic_args": [
                    "c14_goal : eq\n  (if\n    zlt (Z.add (Z.sub i (Int.unsigned n)) (Int.unsigned n))\n      Int.zwordsize\n   then\n    Int.testbit m (Z.add (Z.sub i (Int.unsigned n)) (Int.unsigned n))\n   else false) true",
                    "c4_i : Z",
                    "c2_n : Int.int",
                    "c2_n : Int.int",
                    "c4_i : Z"
                ],
                "tactic_res": [
                    "c15_goal : eq (if zlt i Int.zwordsize then Int.testbit m i else false) true"
                ]
            },
            {
                "tactic_sig": "rewrite _i by lia .",
                "tactic_sig_no_out_arg": "rewrite _i by lia .",
                "tactic_args": [
                    "c15_goal : eq (if zlt i Int.zwordsize then Int.testbit m i else false) true",
                    "_global_1 : Z",
                    "_global_zlt_true : forall (A : Type) (x y : Z) (a b : A) (_ : Z.lt x y),\n       eq (if zlt x y then a else b) a"
                ],
                "tactic_res": [
                    "c16_goal : eq (Int.testbit m i) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : eq (Int.testbit m i) true"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "iagree_shru",
        "proof": [
            {
                "tactic_sig": "Lemma iagree_shru : forall x y m n , iagree x y ( Int.shl m n ) -> iagree ( Int.shru x n ) ( Int.shru y n ) m .",
                "tactic_sig_no_out_arg": "Lemma iagree_shru : forall x y m n , iagree x y ( Int.shl m n ) -> iagree ( Int.shru x n ) ( Int.shru y n ) m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y m n : Int.int) (_ : iagree x y (Int.shl m n)),\niagree (Int.shru x n) (Int.shru y n) m"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (x y m n : Int.int) (_ : iagree x y (Int.shl m n)),\niagree (Int.shru x n) (Int.shru y n) m"
                ],
                "tactic_res": [
                    "c2_goal : iagree (Int.shru x n) (Int.shru y n) m",
                    "c2_x : Int.int",
                    "c2_y : Int.int",
                    "c2_m : Int.int",
                    "c2_n : Int.int",
                    "c2_H : iagree x y (Int.shl m n)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : iagree (Int.shru x n) (Int.shru y n) m"
                ],
                "tactic_res": [
                    "c3_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true),\neq (Int.testbit (Int.shru x n) i) (Int.testbit (Int.shru y n) i)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true),\neq (Int.testbit (Int.shru x n) i) (Int.testbit (Int.shru y n) i)"
                ],
                "tactic_res": [
                    "c4_goal : eq (Int.testbit (Int.shru x n) i) (Int.testbit (Int.shru y n) i)",
                    "c4_i : Z",
                    "c4_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                    "c4_H1 : eq (Int.testbit m i) true"
                ]
            },
            {
                "tactic_sig": "autorewrite with ints .",
                "tactic_sig_no_out_arg": "autorewrite with ints .",
                "tactic_args": [
                    "c4_goal : eq (Int.testbit (Int.shru x n) i) (Int.testbit (Int.shru y n) i)"
                ],
                "tactic_res": [
                    "c5_goal : eq\n  (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n   then Int.testbit x (Z.add i (Int.unsigned n))\n   else false)\n  (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n   then Int.testbit y (Z.add i (Int.unsigned n))\n   else false)",
                    "c6_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                    "c7_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zlt ( _i + Int.unsigned _i ) Int.zwordsize ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt ( _i + Int.unsigned _i ) Int.zwordsize ) .",
                "tactic_args": [
                    "c5_goal : eq\n  (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n   then Int.testbit x (Z.add i (Int.unsigned n))\n   else false)\n  (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n   then Int.testbit y (Z.add i (Int.unsigned n))\n   else false)",
                    "c4_i : Z",
                    "c2_n : Int.int"
                ],
                "tactic_res": [
                    "c8_goal : eq (Int.testbit x (Z.add i (Int.unsigned n)))\n  (Int.testbit y (Z.add i (Int.unsigned n)))",
                    "c8_l : Z.lt (Z.add i (Int.unsigned n)) Int.zwordsize",
                    "c9_goal : eq false false",
                    "c9_g : Z.ge (Z.add i (Int.unsigned n)) Int.zwordsize"
                ]
            },
            {
                "tactic_sig": "generalize ( Int.unsigned_range _i ) .",
                "tactic_sig_no_out_arg": "generalize ( Int.unsigned_range _i ) .",
                "tactic_args": [
                    "c8_goal : eq (Int.testbit x (Z.add i (Int.unsigned n)))\n  (Int.testbit y (Z.add i (Int.unsigned n)))",
                    "c2_n : Int.int"
                ],
                "tactic_res": [
                    "c10_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned n))\n        (Z.lt (Int.unsigned n) Int.modulus),\neq (Int.testbit x (Z.add i (Int.unsigned n)))\n  (Int.testbit y (Z.add i (Int.unsigned n)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c10_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned n))\n        (Z.lt (Int.unsigned n) Int.modulus),\neq (Int.testbit x (Z.add i (Int.unsigned n)))\n  (Int.testbit y (Z.add i (Int.unsigned n)))"
                ],
                "tactic_res": [
                    "c11_goal : eq (Int.testbit x (Z.add i (Int.unsigned n)))\n  (Int.testbit y (Z.add i (Int.unsigned n)))",
                    "c11_H2 : Logic.and (Z.le 0 (Int.unsigned n)) (Z.lt (Int.unsigned n) Int.modulus)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : eq (Int.testbit x (Z.add i (Int.unsigned n)))\n  (Int.testbit y (Z.add i (Int.unsigned n)))",
                    "_global_1 : Z",
                    "c2_H : iagree x y (Int.shl m n)"
                ],
                "tactic_res": [
                    "c12_goal : Logic.and (Z.le 0 (Z.add i (Int.unsigned n)))\n  (Z.lt (Z.add i (Int.unsigned n)) Int.zwordsize)",
                    "c13_goal : eq (Int.testbit (Int.shl m n) (Z.add i (Int.unsigned n))) true"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c12_goal : Logic.and (Z.le 0 (Z.add i (Int.unsigned n)))\n  (Z.lt (Z.add i (Int.unsigned n)) Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite Int.bits_shl by lia .",
                "tactic_sig_no_out_arg": "rewrite Int.bits_shl by lia .",
                "tactic_args": [
                    "c13_goal : eq (Int.testbit (Int.shl m n) (Z.add i (Int.unsigned n))) true",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c14_goal : eq\n  (if zlt (Z.add i (Int.unsigned n)) (Int.unsigned n)\n   then false\n   else\n    Int.testbit m (Z.sub (Z.add i (Int.unsigned n)) (Int.unsigned n)))\n  true"
                ]
            },
            {
                "tactic_sig": "replace ( _i + Int.unsigned _i - Int.unsigned _i ) with _i by lia .",
                "tactic_sig_no_out_arg": "replace ( _i + Int.unsigned _i - Int.unsigned _i ) with _i by lia .",
                "tactic_args": [
                    "c14_goal : eq\n  (if zlt (Z.add i (Int.unsigned n)) (Int.unsigned n)\n   then false\n   else\n    Int.testbit m (Z.sub (Z.add i (Int.unsigned n)) (Int.unsigned n)))\n  true",
                    "c4_i : Z",
                    "c2_n : Int.int",
                    "c2_n : Int.int",
                    "c4_i : Z"
                ],
                "tactic_res": [
                    "c15_goal : eq\n  (if zlt (Z.add i (Int.unsigned n)) (Int.unsigned n)\n   then false\n   else Int.testbit m i) true"
                ]
            },
            {
                "tactic_sig": "rewrite _i by lia .",
                "tactic_sig_no_out_arg": "rewrite _i by lia .",
                "tactic_args": [
                    "c15_goal : eq\n  (if zlt (Z.add i (Int.unsigned n)) (Int.unsigned n)\n   then false\n   else Int.testbit m i) true",
                    "_global_1 : Z",
                    "_global_zlt_false : forall (A : Type) (x y : Z) (a b : A) (_ : Z.ge x y),\n       eq (if zlt x y then a else b) b"
                ],
                "tactic_res": [
                    "c16_goal : eq (Int.testbit m i) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : eq (Int.testbit m i) true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq false false"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "iagree_shr_1",
        "proof": [
            {
                "tactic_sig": "Lemma iagree_shr_1 : forall x y m n , Int.shru ( Int.shl m n ) n = m -> iagree x y ( Int.shl m n ) -> iagree ( Int.shr x n ) ( Int.shr y n ) m .",
                "tactic_sig_no_out_arg": "Lemma iagree_shr_1 : forall x y m n , Int.shru ( Int.shl m n ) n = m -> iagree x y ( Int.shl m n ) -> iagree ( Int.shr x n ) ( Int.shr y n ) m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y m n : Int.int) (_ : eq (Int.shru (Int.shl m n) n) m)\n  (_ : iagree x y (Int.shl m n)), iagree (Int.shr x n) (Int.shr y n) m"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (x y m n : Int.int) (_ : eq (Int.shru (Int.shl m n) n) m)\n  (_ : iagree x y (Int.shl m n)), iagree (Int.shr x n) (Int.shr y n) m"
                ],
                "tactic_res": [
                    "c2_goal : iagree (Int.shr x n) (Int.shr y n) m",
                    "c2_x : Int.int",
                    "c2_y : Int.int",
                    "c2_m : Int.int",
                    "c2_n : Int.int",
                    "c2_H : eq (Int.shru (Int.shl m n) n) m",
                    "c2_H0 : iagree x y (Int.shl m n)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : iagree (Int.shr x n) (Int.shr y n) m"
                ],
                "tactic_res": [
                    "c3_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true),\neq (Int.testbit (Int.shr x n) i) (Int.testbit (Int.shr y n) i)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true),\neq (Int.testbit (Int.shr x n) i) (Int.testbit (Int.shr y n) i)"
                ],
                "tactic_res": [
                    "c4_goal : eq (Int.testbit (Int.shr x n) i) (Int.testbit (Int.shr y n) i)",
                    "c4_i : Z",
                    "c4_H1 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                    "c4_H2 : eq (Int.testbit m i) true"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i in _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c2_H : eq (Int.shru (Int.shl m n) n) m",
                    "c4_H2 : eq (Int.testbit m i) true"
                ],
                "tactic_res": [
                    "c4_H2 : eq (Int.testbit (Int.shru (Int.shl m n) n) i) true"
                ]
            },
            {
                "tactic_sig": "rewrite Int.bits_shru in _i by auto .",
                "tactic_sig_no_out_arg": "rewrite Int.bits_shru in _i by auto .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c4_H2 : eq (Int.testbit m i) true"
                ],
                "tactic_res": [
                    "c4_H2 : eq\n  (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n   then Int.testbit (Int.shl m n) (Z.add i (Int.unsigned n))\n   else false) true"
                ]
            },
            {
                "tactic_sig": "rewrite ! Int.bits_shr by auto .",
                "tactic_sig_no_out_arg": "rewrite ! Int.bits_shr by auto .",
                "tactic_args": [
                    "c4_goal : eq (Int.testbit (Int.shr x n) i) (Int.testbit (Int.shr y n) i)",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c5_goal : eq\n  (Int.testbit x\n     (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub Int.zwordsize 1))\n  (Int.testbit y\n     (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub Int.zwordsize 1))"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt ( _i + Int.unsigned _i ) Int.zwordsize ) as [  _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt ( _i + Int.unsigned _i ) Int.zwordsize ) .",
                "tactic_args": [
                    "c5_goal : eq\n  (Int.testbit x\n     (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub Int.zwordsize 1))\n  (Int.testbit y\n     (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub Int.zwordsize 1))",
                    "c4_i : Z",
                    "c2_n : Int.int"
                ],
                "tactic_res": [
                    "c6_goal : eq (Int.testbit x (Z.add i (Int.unsigned n)))\n  (Int.testbit y (Z.add i (Int.unsigned n)))",
                    "c6_H2 : eq (Int.testbit (Int.shl m n) (Z.add i (Int.unsigned n))) true",
                    "c6_l : Z.lt (Z.add i (Int.unsigned n)) Int.zwordsize",
                    "c7_goal : eq (Int.testbit x (Z.sub Int.zwordsize 1))\n  (Int.testbit y (Z.sub Int.zwordsize 1))",
                    "c7_H2 : eq false true",
                    "c7_g : Z.ge (Z.add i (Int.unsigned n)) Int.zwordsize"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : eq (Int.testbit x (Z.add i (Int.unsigned n)))\n  (Int.testbit y (Z.add i (Int.unsigned n)))",
                    "_global_1 : Z",
                    "c2_H0 : iagree x y (Int.shl m n)"
                ],
                "tactic_res": [
                    "c8_goal : Logic.and (Z.le 0 (Z.add i (Int.unsigned n)))\n  (Z.lt (Z.add i (Int.unsigned n)) Int.zwordsize)",
                    "c9_goal : eq (Int.testbit (Int.shl m n) (Z.add i (Int.unsigned n))) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq (Int.testbit (Int.shl m n) (Z.add i (Int.unsigned n))) true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( Int.unsigned_range _i ) .",
                "tactic_sig_no_out_arg": "generalize ( Int.unsigned_range _i ) .",
                "tactic_args": [
                    "c8_goal : Logic.and (Z.le 0 (Z.add i (Int.unsigned n)))\n  (Z.lt (Z.add i (Int.unsigned n)) Int.zwordsize)",
                    "c2_n : Int.int"
                ],
                "tactic_res": [
                    "c10_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned n))\n        (Z.lt (Int.unsigned n) Int.modulus),\nLogic.and (Z.le 0 (Z.add i (Int.unsigned n)))\n  (Z.lt (Z.add i (Int.unsigned n)) Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c10_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned n))\n        (Z.lt (Int.unsigned n) Int.modulus),\nLogic.and (Z.le 0 (Z.add i (Int.unsigned n)))\n  (Z.lt (Z.add i (Int.unsigned n)) Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c7_goal : eq (Int.testbit x (Z.sub Int.zwordsize 1))\n  (Int.testbit y (Z.sub Int.zwordsize 1))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "iagree_shr",
        "proof": [
            {
                "tactic_sig": "Lemma iagree_shr : forall x y m n , iagree x y ( Int.or ( Int.shl m n ) ( Int.repr Int.min_signed ) ) -> iagree ( Int.shr x n ) ( Int.shr y n ) m .",
                "tactic_sig_no_out_arg": "Lemma iagree_shr : forall x y m n , iagree x y ( Int.or ( Int.shl m n ) ( Int.repr Int.min_signed ) ) -> iagree ( Int.shr x n ) ( Int.shr y n ) m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y m n : Int.int)\n  (_ : iagree x y (Int.or (Int.shl m n) (Int.repr Int.min_signed))),\niagree (Int.shr x n) (Int.shr y n) m"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (x y m n : Int.int)\n  (_ : iagree x y (Int.or (Int.shl m n) (Int.repr Int.min_signed))),\niagree (Int.shr x n) (Int.shr y n) m"
                ],
                "tactic_res": [
                    "c2_goal : iagree (Int.shr x n) (Int.shr y n) m",
                    "c2_x : Int.int",
                    "c2_y : Int.int",
                    "c2_m : Int.int",
                    "c2_n : Int.int",
                    "c2_H : iagree x y (Int.or (Int.shl m n) (Int.repr Int.min_signed))"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : iagree (Int.shr x n) (Int.shr y n) m"
                ],
                "tactic_res": [
                    "c3_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true),\neq (Int.testbit (Int.shr x n) i) (Int.testbit (Int.shr y n) i)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true),\neq (Int.testbit (Int.shr x n) i) (Int.testbit (Int.shr y n) i)"
                ],
                "tactic_res": [
                    "c4_goal : eq (Int.testbit (Int.shr x n) i) (Int.testbit (Int.shr y n) i)",
                    "c4_i : Z",
                    "c4_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                    "c4_H1 : eq (Int.testbit m i) true"
                ]
            },
            {
                "tactic_sig": "rewrite ! Int.bits_shr by auto .",
                "tactic_sig_no_out_arg": "rewrite ! Int.bits_shr by auto .",
                "tactic_args": [
                    "c4_goal : eq (Int.testbit (Int.shr x n) i) (Int.testbit (Int.shr y n) i)",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c5_goal : eq\n  (Int.testbit x\n     (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub Int.zwordsize 1))\n  (Int.testbit y\n     (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub Int.zwordsize 1))"
                ]
            },
            {
                "tactic_sig": "generalize ( Int.unsigned_range _i ) .",
                "tactic_sig_no_out_arg": "generalize ( Int.unsigned_range _i ) .",
                "tactic_args": [
                    "c5_goal : eq\n  (Int.testbit x\n     (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub Int.zwordsize 1))\n  (Int.testbit y\n     (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub Int.zwordsize 1))",
                    "c2_n : Int.int"
                ],
                "tactic_res": [
                    "c6_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned n))\n        (Z.lt (Int.unsigned n) Int.modulus),\neq\n  (Int.testbit x\n     (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub Int.zwordsize 1))\n  (Int.testbit y\n     (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub Int.zwordsize 1))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned n))\n        (Z.lt (Int.unsigned n) Int.modulus),\neq\n  (Int.testbit x\n     (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub Int.zwordsize 1))\n  (Int.testbit y\n     (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub Int.zwordsize 1))"
                ],
                "tactic_res": [
                    "c7_goal : eq\n  (Int.testbit x\n     (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub Int.zwordsize 1))\n  (Int.testbit y\n     (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub Int.zwordsize 1))",
                    "c7_H2 : Logic.and (Z.le 0 (Int.unsigned n)) (Z.lt (Int.unsigned n) Int.modulus)"
                ]
            },
            {
                "tactic_sig": "set ( j := if zlt ( _i + Int.unsigned _i ) Int.zwordsize then _i + Int.unsigned _i else Int.zwordsize - 1 ) .",
                "tactic_sig_no_out_arg": "set ( j := if zlt ( _i + Int.unsigned _i ) Int.zwordsize then _i + Int.unsigned _i else Int.zwordsize - 1 ) .",
                "tactic_args": [
                    "c7_goal : eq\n  (Int.testbit x\n     (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub Int.zwordsize 1))\n  (Int.testbit y\n     (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub Int.zwordsize 1))",
                    "c4_i : Z",
                    "c2_n : Int.int",
                    "c4_i : Z",
                    "c2_n : Int.int"
                ],
                "tactic_res": [
                    "c8_goal : eq (Int.testbit x j) (Int.testbit y j)",
                    "c8_j : Z"
                ]
            },
            {
                "tactic_sig": "assert ( 0 <= _i < Int.zwordsize ) .",
                "tactic_sig_no_out_arg": "assert ( 0 <= _i < Int.zwordsize ) .",
                "tactic_args": [
                    "c8_goal : eq (Int.testbit x j) (Int.testbit y j)",
                    "c8_j : Z"
                ],
                "tactic_res": [
                    "c9_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)",
                    "c10_goal : eq (Int.testbit x j) (Int.testbit y j)",
                    "c10_H3 : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c9_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)",
                    "_global_1 : Z",
                    "c8_j : Z"
                ],
                "tactic_res": [
                    "c11_goal : Logic.and\n  (Z.le 0\n     (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub Int.zwordsize 1))\n  (Z.lt\n     (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub Int.zwordsize 1) Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt ( _i + Int.unsigned _i ) Int.zwordsize ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt ( _i + Int.unsigned _i ) Int.zwordsize ) .",
                "tactic_args": [
                    "c11_goal : Logic.and\n  (Z.le 0\n     (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub Int.zwordsize 1))\n  (Z.lt\n     (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub Int.zwordsize 1) Int.zwordsize)",
                    "c4_i : Z",
                    "c2_n : Int.int"
                ],
                "tactic_res": [
                    "c12_goal : Logic.and (Z.le 0 (Z.add i (Int.unsigned n)))\n  (Z.lt (Z.add i (Int.unsigned n)) Int.zwordsize)",
                    "c12_l : Z.lt (Z.add i (Int.unsigned n)) Int.zwordsize",
                    "c13_goal : Logic.and (Z.le 0 (Z.sub Int.zwordsize 1))\n  (Z.lt (Z.sub Int.zwordsize 1) Int.zwordsize)",
                    "c13_g : Z.ge (Z.add i (Int.unsigned n)) Int.zwordsize"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c12_goal : Logic.and (Z.le 0 (Z.add i (Int.unsigned n)))\n  (Z.lt (Z.add i (Int.unsigned n)) Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c13_goal : Logic.and (Z.le 0 (Z.sub Int.zwordsize 1))\n  (Z.lt (Z.sub Int.zwordsize 1) Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : eq (Int.testbit x j) (Int.testbit y j)",
                    "_global_1 : Z",
                    "c2_H : iagree x y (Int.or (Int.shl m n) (Int.repr Int.min_signed))"
                ],
                "tactic_res": [
                    "c14_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)",
                    "c15_goal : eq (Int.testbit (Int.or (Int.shl m n) (Int.repr Int.min_signed)) j)\n  true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "autorewrite with ints .",
                "tactic_sig_no_out_arg": "autorewrite with ints .",
                "tactic_args": [
                    "c15_goal : eq (Int.testbit (Int.or (Int.shl m n) (Int.repr Int.min_signed)) j)\n  true"
                ],
                "tactic_res": [
                    "c16_goal : eq\n  (orb\n     (if zlt j (Int.unsigned n)\n      then false\n      else Int.testbit m (Z.sub j (Int.unsigned n)))\n     (Int.testbit (Int.repr Int.min_signed) j)) true",
                    "c17_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)",
                    "c18_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c16_goal : eq\n  (orb\n     (if zlt j (Int.unsigned n)\n      then false\n      else Int.testbit m (Z.sub j (Int.unsigned n)))\n     (Int.testbit (Int.repr Int.min_signed) j)) true",
                    "_global_1 : Z",
                    "_global_orb_true_intro : forall (b1 b2 : bool) (_ : Logic.or (eq b1 true) (eq b2 true)),\n       eq (orb b1 b2) true"
                ],
                "tactic_res": [
                    "c19_goal : Logic.or\n  (eq\n     (if zlt j (Int.unsigned n)\n      then false\n      else Int.testbit m (Z.sub j (Int.unsigned n))) true)\n  (eq (Int.testbit (Int.repr Int.min_signed) j) true)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c19_goal : Logic.or\n  (eq\n     (if zlt j (Int.unsigned n)\n      then false\n      else Int.testbit m (Z.sub j (Int.unsigned n))) true)\n  (eq (Int.testbit (Int.repr Int.min_signed) j) true)",
                    "_global_1 : Z",
                    "c8_j : Z"
                ],
                "tactic_res": [
                    "c20_goal : Logic.or\n  (eq\n     (if\n       zlt\n         (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n          then Z.add i (Int.unsigned n)\n          else Z.sub Int.zwordsize 1) (Int.unsigned n)\n      then false\n      else\n       Int.testbit m\n         (Z.sub\n            (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n             then Z.add i (Int.unsigned n)\n             else Z.sub Int.zwordsize 1) (Int.unsigned n))) true)\n  (eq\n     (Int.testbit (Int.repr Int.min_signed)\n        (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n         then Z.add i (Int.unsigned n)\n         else Z.sub Int.zwordsize 1)) true)"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt ( _i + Int.unsigned _i ) Int.zwordsize ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt ( _i + Int.unsigned _i ) Int.zwordsize ) .",
                "tactic_args": [
                    "c20_goal : Logic.or\n  (eq\n     (if\n       zlt\n         (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n          then Z.add i (Int.unsigned n)\n          else Z.sub Int.zwordsize 1) (Int.unsigned n)\n      then false\n      else\n       Int.testbit m\n         (Z.sub\n            (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n             then Z.add i (Int.unsigned n)\n             else Z.sub Int.zwordsize 1) (Int.unsigned n))) true)\n  (eq\n     (Int.testbit (Int.repr Int.min_signed)\n        (if zlt (Z.add i (Int.unsigned n)) Int.zwordsize\n         then Z.add i (Int.unsigned n)\n         else Z.sub Int.zwordsize 1)) true)",
                    "c4_i : Z",
                    "c2_n : Int.int"
                ],
                "tactic_res": [
                    "c21_goal : Logic.or\n  (eq\n     (if zlt (Z.add i (Int.unsigned n)) (Int.unsigned n)\n      then false\n      else\n       Int.testbit m\n         (Z.sub (Z.add i (Int.unsigned n)) (Int.unsigned n))) true)\n  (eq\n     (Int.testbit (Int.repr Int.min_signed) (Z.add i (Int.unsigned n)))\n     true)",
                    "c21_l : Z.lt (Z.add i (Int.unsigned n)) Int.zwordsize",
                    "c22_goal : Logic.or\n  (eq\n     (if zlt (Z.sub Int.zwordsize 1) (Int.unsigned n)\n      then false\n      else\n       Int.testbit m (Z.sub (Z.sub Int.zwordsize 1) (Int.unsigned n)))\n     true)\n  (eq (Int.testbit (Int.repr Int.min_signed) (Z.sub Int.zwordsize 1))\n     true)",
                    "c22_g : Z.ge (Z.add i (Int.unsigned n)) Int.zwordsize"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c21_goal : Logic.or\n  (eq\n     (if zlt (Z.add i (Int.unsigned n)) (Int.unsigned n)\n      then false\n      else\n       Int.testbit m\n         (Z.sub (Z.add i (Int.unsigned n)) (Int.unsigned n))) true)\n  (eq\n     (Int.testbit (Int.repr Int.min_signed) (Z.add i (Int.unsigned n)))\n     true)"
                ],
                "tactic_res": [
                    "c23_goal : eq\n  (if zlt (Z.add i (Int.unsigned n)) (Int.unsigned n)\n   then false\n   else\n    Int.testbit m (Z.sub (Z.add i (Int.unsigned n)) (Int.unsigned n)))\n  true"
                ]
            },
            {
                "tactic_sig": "rewrite _i by lia .",
                "tactic_sig_no_out_arg": "rewrite _i by lia .",
                "tactic_args": [
                    "c23_goal : eq\n  (if zlt (Z.add i (Int.unsigned n)) (Int.unsigned n)\n   then false\n   else\n    Int.testbit m (Z.sub (Z.add i (Int.unsigned n)) (Int.unsigned n)))\n  true",
                    "_global_1 : Z",
                    "_global_zlt_false : forall (A : Type) (x y : Z) (a b : A) (_ : Z.ge x y),\n       eq (if zlt x y then a else b) b"
                ],
                "tactic_res": [
                    "c24_goal : eq (Int.testbit m (Z.sub (Z.add i (Int.unsigned n)) (Int.unsigned n)))\n  true"
                ]
            },
            {
                "tactic_sig": "replace ( _i + Int.unsigned _i - Int.unsigned _i ) with _i by lia .",
                "tactic_sig_no_out_arg": "replace ( _i + Int.unsigned _i - Int.unsigned _i ) with _i by lia .",
                "tactic_args": [
                    "c24_goal : eq (Int.testbit m (Z.sub (Z.add i (Int.unsigned n)) (Int.unsigned n)))\n  true",
                    "c4_i : Z",
                    "c2_n : Int.int",
                    "c2_n : Int.int",
                    "c4_i : Z"
                ],
                "tactic_res": [
                    "c25_goal : eq (Int.testbit m i) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : eq (Int.testbit m i) true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c22_goal : Logic.or\n  (eq\n     (if zlt (Z.sub Int.zwordsize 1) (Int.unsigned n)\n      then false\n      else\n       Int.testbit m (Z.sub (Z.sub Int.zwordsize 1) (Int.unsigned n)))\n     true)\n  (eq (Int.testbit (Int.repr Int.min_signed) (Z.sub Int.zwordsize 1))\n     true)"
                ],
                "tactic_res": [
                    "c26_goal : eq (Int.testbit (Int.repr Int.min_signed) (Z.sub Int.zwordsize 1)) true"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c26_goal : eq (Int.testbit (Int.repr Int.min_signed) (Z.sub Int.zwordsize 1)) true"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "iagree_rol",
        "proof": [
            {
                "tactic_sig": "Lemma iagree_rol : forall p q m amount , iagree p q ( Int.ror m amount ) -> iagree ( Int.rol p amount ) ( Int.rol q amount ) m .",
                "tactic_sig_no_out_arg": "Lemma iagree_rol : forall p q m amount , iagree p q ( Int.ror m amount ) -> iagree ( Int.rol p amount ) ( Int.rol q amount ) m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (p q m amount : Int.int) (_ : iagree p q (Int.ror m amount)),\niagree (Int.rol p amount) (Int.rol q amount) m"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (p q m amount : Int.int) (_ : iagree p q (Int.ror m amount)),\niagree (Int.rol p amount) (Int.rol q amount) m"
                ],
                "tactic_res": [
                    "c2_goal : iagree (Int.rol p amount) (Int.rol q amount) m",
                    "c2_p : Int.int",
                    "c2_q : Int.int",
                    "c2_m : Int.int",
                    "c2_amount : Int.int",
                    "c2_H : iagree p q (Int.ror m amount)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : iagree (Int.rol p amount) (Int.rol q amount) m"
                ],
                "tactic_res": [
                    "c3_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true),\neq (Int.testbit (Int.rol p amount) i)\n  (Int.testbit (Int.rol q amount) i)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true),\neq (Int.testbit (Int.rol p amount) i)\n  (Int.testbit (Int.rol q amount) i)"
                ],
                "tactic_res": [
                    "c4_goal : eq (Int.testbit (Int.rol p amount) i)\n  (Int.testbit (Int.rol q amount) i)",
                    "c4_i : Z",
                    "c4_H1 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                    "c4_H2 : eq (Int.testbit m i) true"
                ]
            },
            {
                "tactic_sig": "rewrite ! Int.bits_rol by auto .",
                "tactic_sig_no_out_arg": "rewrite ! Int.bits_rol by auto .",
                "tactic_args": [
                    "c4_goal : eq (Int.testbit (Int.rol p amount) i)\n  (Int.testbit (Int.rol q amount) i)",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c5_goal : eq\n  (Int.testbit p\n     (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize))\n  (Int.testbit q\n     (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : eq\n  (Int.testbit p\n     (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize))\n  (Int.testbit q\n     (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize))",
                    "_global_1 : Z",
                    "c2_H : iagree p q (Int.ror m amount)"
                ],
                "tactic_res": [
                    "c6_goal : Logic.and\n  (Z.le 0 (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize))\n  (Z.lt (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)\n     Int.zwordsize)",
                    "c7_goal : eq\n  (Int.testbit (Int.ror m amount)\n     (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)) true"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c6_goal : Logic.and\n  (Z.le 0 (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize))\n  (Z.lt (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)\n     Int.zwordsize)",
                    "_global_1 : Z",
                    "_global_Z_mod_lt : forall (a b : Z) (_ : Z.gt b 0),\n       Logic.and (Z.le 0 (Z.modulo a b)) (Z.lt (Z.modulo a b) b)"
                ],
                "tactic_res": [
                    "c8_goal : Z.gt Int.zwordsize 0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : Z.gt Int.zwordsize 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite Int.bits_ror .",
                "tactic_sig_no_out_arg": "rewrite Int.bits_ror .",
                "tactic_args": [
                    "c7_goal : eq\n  (Int.testbit (Int.ror m amount)\n     (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)) true",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c9_goal : eq\n  (Int.testbit m\n     (Z.modulo\n        (Z.add (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)\n           (Int.unsigned amount)) Int.zwordsize)) true",
                    "c10_goal : Logic.and\n  (Z.le 0 (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize))\n  (Z.lt (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)\n     Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "replace ( ( ( _i - Int.unsigned _i ) mod Int.zwordsize + Int.unsigned _i ) mod Int.zwordsize ) with _i .",
                "tactic_sig_no_out_arg": "replace ( ( ( _i - Int.unsigned _i ) mod Int.zwordsize + Int.unsigned _i ) mod Int.zwordsize ) with _i .",
                "tactic_args": [
                    "c9_goal : eq\n  (Int.testbit m\n     (Z.modulo\n        (Z.add (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)\n           (Int.unsigned amount)) Int.zwordsize)) true",
                    "c4_i : Z",
                    "c2_amount : Int.int",
                    "c2_amount : Int.int",
                    "c4_i : Z"
                ],
                "tactic_res": [
                    "c11_goal : eq (Int.testbit m i) true",
                    "c12_goal : eq i\n  (Z.modulo\n     (Z.add (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)\n        (Int.unsigned amount)) Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : eq (Int.testbit m i) true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with Int.zwordsize .",
                "tactic_sig_no_out_arg": "apply _i with Int.zwordsize .",
                "tactic_args": [
                    "c12_goal : eq i\n  (Z.modulo\n     (Z.add (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)\n        (Int.unsigned amount)) Int.zwordsize)",
                    "_global_1 : Z",
                    "_global_eqmod_small_eq : forall (modul x y : Z) (_ : eqmod modul x y)\n         (_ : Logic.and (Z.le 0 x) (Z.lt x modul))\n         (_ : Logic.and (Z.le 0 y) (Z.lt y modul)), \n       eq x y"
                ],
                "tactic_res": [
                    "c13_goal : eqmod Int.zwordsize i\n  (Z.modulo\n     (Z.add (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)\n        (Int.unsigned amount)) Int.zwordsize)",
                    "c14_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                    "c15_goal : Logic.and\n  (Z.le 0\n     (Z.modulo\n        (Z.add (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)\n           (Int.unsigned amount)) Int.zwordsize))\n  (Z.lt\n     (Z.modulo\n        (Z.add (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)\n           (Int.unsigned amount)) Int.zwordsize) Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i with ( ( _i - Int.unsigned _i ) + Int.unsigned _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( ( _i - Int.unsigned _i ) + Int.unsigned _i ) .",
                "tactic_args": [
                    "c13_goal : eqmod Int.zwordsize i\n  (Z.modulo\n     (Z.add (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)\n        (Int.unsigned amount)) Int.zwordsize)",
                    "_global_1 : Z",
                    "_global_eqmod_trans : forall (modul x y z : Z) (_ : eqmod modul x y) (_ : eqmod modul y z),\n       eqmod modul x z",
                    "c4_i : Z",
                    "c2_amount : Int.int",
                    "c2_amount : Int.int"
                ],
                "tactic_res": [
                    "c16_goal : eqmod Int.zwordsize i\n  (Z.add (Z.sub i (Int.unsigned amount)) (Int.unsigned amount))",
                    "c17_goal : eqmod Int.zwordsize\n  (Z.add (Z.sub i (Int.unsigned amount)) (Int.unsigned amount))\n  (Z.modulo\n     (Z.add (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)\n        (Int.unsigned amount)) Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c16_goal : eqmod Int.zwordsize i\n  (Z.add (Z.sub i (Int.unsigned amount)) (Int.unsigned amount))",
                    "_global_1 : Z",
                    "_global_eqmod_refl2 : forall (modul x y : Z) (_ : eq x y), eqmod modul x y"
                ],
                "tactic_res": [
                    "c18_goal : eq i (Z.add (Z.sub i (Int.unsigned amount)) (Int.unsigned amount))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c18_goal : eq i (Z.add (Z.sub i (Int.unsigned amount)) (Int.unsigned amount))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c17_goal : eqmod Int.zwordsize\n  (Z.add (Z.sub i (Int.unsigned amount)) (Int.unsigned amount))\n  (Z.modulo\n     (Z.add (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)\n        (Int.unsigned amount)) Int.zwordsize)",
                    "_global_1 : Z",
                    "_global_eqmod_trans : forall (modul x y z : Z) (_ : eqmod modul x y) (_ : eqmod modul y z),\n       eqmod modul x z"
                ],
                "tactic_res": [
                    "c19_goal : eqmod Int.zwordsize\n  (Z.add (Z.sub i (Int.unsigned amount)) (Int.unsigned amount)) \n  ?y",
                    "c20_goal : eqmod Int.zwordsize ?y\n  (Z.modulo\n     (Z.add (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)\n        (Int.unsigned amount)) Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c20_goal : eqmod Int.zwordsize ?y\n  (Z.modulo\n     (Z.add (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)\n        (Int.unsigned amount)) Int.zwordsize)",
                    "_global_2 : Z",
                    "_global_eqmod_mod : forall (modul : Z) (_ : Z.gt modul 0) (x : Z),\n       eqmod modul x (Z.modulo x modul)"
                ],
                "tactic_res": [
                    "c21_goal : Z.gt Int.zwordsize 0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : Z.gt Int.zwordsize 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c19_goal : eqmod Int.zwordsize\n  (Z.add (Z.sub i (Int.unsigned amount)) (Int.unsigned amount))\n  (Z.add (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)\n     (Int.unsigned amount))",
                    "_global_1 : Z",
                    "_global_eqmod_add : forall (modul a b c d : Z) (_ : eqmod modul a b) (_ : eqmod modul c d),\n       eqmod modul (Z.add a c) (Z.add b d)"
                ],
                "tactic_res": [
                    "c22_goal : eqmod Int.zwordsize (Z.sub i (Int.unsigned amount))\n  (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)",
                    "c23_goal : eqmod Int.zwordsize (Int.unsigned amount) (Int.unsigned amount)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c22_goal : eqmod Int.zwordsize (Z.sub i (Int.unsigned amount))\n  (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)",
                    "_global_1 : Z",
                    "_global_eqmod_mod : forall (modul : Z) (_ : Z.gt modul 0) (x : Z),\n       eqmod modul x (Z.modulo x modul)"
                ],
                "tactic_res": [
                    "c24_goal : Z.gt Int.zwordsize 0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : Z.gt Int.zwordsize 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c23_goal : eqmod Int.zwordsize (Int.unsigned amount) (Int.unsigned amount)",
                    "_global_1 : Z",
                    "_global_eqmod_refl : forall modul x : Z, eqmod modul x x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : Logic.and\n  (Z.le 0\n     (Z.modulo\n        (Z.add (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)\n           (Int.unsigned amount)) Int.zwordsize))\n  (Z.lt\n     (Z.modulo\n        (Z.add (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)\n           (Int.unsigned amount)) Int.zwordsize) Int.zwordsize)",
                    "_global_1 : Z",
                    "_global_Z_mod_lt : forall (a b : Z) (_ : Z.gt b 0),\n       Logic.and (Z.le 0 (Z.modulo a b)) (Z.lt (Z.modulo a b) b)"
                ],
                "tactic_res": [
                    "c25_goal : Z.gt Int.zwordsize 0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : Z.gt Int.zwordsize 0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : Logic.and\n  (Z.le 0 (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize))\n  (Z.lt (Z.modulo (Z.sub i (Int.unsigned amount)) Int.zwordsize)\n     Int.zwordsize)",
                    "_global_1 : Z",
                    "_global_Z_mod_lt : forall (a b : Z) (_ : Z.gt b 0),\n       Logic.and (Z.le 0 (Z.modulo a b)) (Z.lt (Z.modulo a b) b)"
                ],
                "tactic_res": [
                    "c26_goal : Z.gt Int.zwordsize 0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c26_goal : Z.gt Int.zwordsize 0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "iagree_ror",
        "proof": [
            {
                "tactic_sig": "Lemma iagree_ror : forall p q m amount , iagree p q ( Int.rol m amount ) -> iagree ( Int.ror p amount ) ( Int.ror q amount ) m .",
                "tactic_sig_no_out_arg": "Lemma iagree_ror : forall p q m amount , iagree p q ( Int.rol m amount ) -> iagree ( Int.ror p amount ) ( Int.ror q amount ) m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (p q m amount : Int.int) (_ : iagree p q (Int.rol m amount)),\niagree (Int.ror p amount) (Int.ror q amount) m"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (p q m amount : Int.int) (_ : iagree p q (Int.rol m amount)),\niagree (Int.ror p amount) (Int.ror q amount) m"
                ],
                "tactic_res": [
                    "c2_goal : iagree (Int.ror p amount) (Int.ror q amount) m",
                    "c2_p : Int.int",
                    "c2_q : Int.int",
                    "c2_m : Int.int",
                    "c2_amount : Int.int",
                    "c2_H : iagree p q (Int.rol m amount)"
                ]
            },
            {
                "tactic_sig": "rewrite ! Int.ror_rol_neg by apply _i .",
                "tactic_sig_no_out_arg": "rewrite ! Int.ror_rol_neg by apply _i .",
                "tactic_args": [
                    "c2_goal : iagree (Int.ror p amount) (Int.ror q amount) m",
                    "_global_1 : Z",
                    "_global_int_wordsize_divides_modulus : Z.divide (Z.of_nat Int.wordsize) Int.modulus"
                ],
                "tactic_res": [
                    "c3_goal : iagree (Int.rol p (Int.neg amount)) (Int.rol q (Int.neg amount)) m"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : iagree (Int.rol p (Int.neg amount)) (Int.rol q (Int.neg amount)) m",
                    "_global_1 : Z",
                    "_global_iagree_rol : forall (p q m amount : Int.int) (_ : iagree p q (Int.ror m amount)),\n       iagree (Int.rol p amount) (Int.rol q amount) m"
                ],
                "tactic_res": [
                    "c4_goal : iagree p q (Int.ror m (Int.neg amount))"
                ]
            },
            {
                "tactic_sig": "rewrite Int.ror_rol_neg by apply _i .",
                "tactic_sig_no_out_arg": "rewrite Int.ror_rol_neg by apply _i .",
                "tactic_args": [
                    "c4_goal : iagree p q (Int.ror m (Int.neg amount))",
                    "_global_1 : Z",
                    "_global_int_wordsize_divides_modulus : Z.divide (Z.of_nat Int.wordsize) Int.modulus"
                ],
                "tactic_res": [
                    "c5_goal : iagree p q (Int.rol m (Int.neg (Int.neg amount)))"
                ]
            },
            {
                "tactic_sig": "rewrite Int.neg_involutive .",
                "tactic_sig_no_out_arg": "rewrite Int.neg_involutive .",
                "tactic_args": [
                    "c5_goal : iagree p q (Int.rol m (Int.neg (Int.neg amount)))",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c6_goal : iagree p q (Int.rol m amount)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : iagree p q (Int.rol m amount)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eqmod_iagree",
        "proof": [
            {
                "tactic_sig": "Lemma eqmod_iagree : forall m x y , eqmod ( two_p ( Int.size m ) ) x y -> iagree ( Int.repr x ) ( Int.repr y ) m .",
                "tactic_sig_no_out_arg": "Lemma eqmod_iagree : forall m x y , eqmod ( two_p ( Int.size m ) ) x y -> iagree ( Int.repr x ) ( Int.repr y ) m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (m : Int.int) (x y : Z) (_ : eqmod (two_p (Int.size m)) x y),\niagree (Int.repr x) (Int.repr y) m"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (m : Int.int) (x y : Z) (_ : eqmod (two_p (Int.size m)) x y),\niagree (Int.repr x) (Int.repr y) m"
                ],
                "tactic_res": [
                    "c2_goal : iagree (Int.repr x) (Int.repr y) m",
                    "c2_m : Int.int",
                    "c2_x : Z",
                    "c2_y : Z",
                    "c2_H : eqmod (two_p (Int.size m)) x y"
                ]
            },
            {
                "tactic_sig": "set ( p := Z.to_nat ( Int.size _i ) ) .",
                "tactic_sig_no_out_arg": "set ( p := Z.to_nat ( Int.size _i ) ) .",
                "tactic_args": [
                    "c2_m : Int.int"
                ],
                "tactic_res": [
                    "c2_p : nat"
                ]
            },
            {
                "tactic_sig": "generalize ( Int.size_range _i ) .",
                "tactic_sig_no_out_arg": "generalize ( Int.size_range _i ) .",
                "tactic_args": [
                    "c2_goal : iagree (Int.repr x) (Int.repr y) m",
                    "c2_m : Int.int"
                ],
                "tactic_res": [
                    "c3_goal : forall\n  _ : Logic.and (Z.le 0 (Int.size m)) (Z.le (Int.size m) Int.zwordsize),\niagree (Int.repr x) (Int.repr y) m"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros RANGE .",
                "tactic_args": [
                    "c3_goal : forall\n  _ : Logic.and (Z.le 0 (Int.size m)) (Z.le (Int.size m) Int.zwordsize),\niagree (Int.repr x) (Int.repr y) m"
                ],
                "tactic_res": [
                    "c4_goal : iagree (Int.repr x) (Int.repr y) m",
                    "c4_RANGE : Logic.and (Z.le 0 (Int.size m)) (Z.le (Int.size m) Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "assert ( EQ : Int.size _i = Z.of_nat _i ) .",
                "tactic_sig_no_out_arg": "assert ( EQ : Int.size _i = Z.of_nat _i ) .",
                "tactic_args": [
                    "c4_goal : iagree (Int.repr x) (Int.repr y) m",
                    "c2_m : Int.int",
                    "c2_p : nat"
                ],
                "tactic_res": [
                    "c5_goal : eq (Int.size m) (Z.of_nat p)",
                    "c6_goal : iagree (Int.repr x) (Int.repr y) m",
                    "c6_EQ : eq (Int.size m) (Z.of_nat p)"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c5_goal : eq (Int.size m) (Z.of_nat p)"
                ],
                "tactic_res": [
                    "c7_goal : eq (Z.of_nat p) (Int.size m)"
                ]
            },
            {
                "tactic_sig": "apply Z2Nat._i .",
                "tactic_sig_no_out_arg": "apply Z2Nat._i .",
                "tactic_args": [
                    "c7_goal : eq (Z.of_nat p) (Int.size m)",
                    "_global_1 : Z",
                    "_global_id : forall _ : ?A, ?A\nwhere\n?A : [m : Int.int\n      x : Z\n      y : Z\n      H : eqmod (two_p (Int.size m)) x y\n      p := Z.to_nat (Int.size m) : nat\n      RANGE : Logic.and (Z.le 0 (Int.size m))\n                (Z.le (Int.size m) Int.zwordsize) |- Type]"
                ],
                "tactic_res": [
                    "c8_goal : Z.le 0 (Int.size m)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c8_goal : Z.le 0 (Int.size m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c6_EQ : eq (Int.size m) (Z.of_nat p)",
                    "c2_H : eqmod (two_p (Int.size m)) x y"
                ],
                "tactic_res": [
                    "c6_H : eqmod (two_p (Z.of_nat p)) x y"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i in _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "_global_two_power_nat_two_p : forall x : nat, eq (two_power_nat x) (two_p (Z.of_nat x))",
                    "c2_H : eqmod (two_p (Int.size m)) x y"
                ],
                "tactic_res": [
                    "c6_H : eqmod (two_power_nat p) x y"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c6_goal : iagree (Int.repr x) (Int.repr y) m"
                ],
                "tactic_res": [
                    "c9_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true),\neq (Int.testbit (Int.repr x) i) (Int.testbit (Int.repr y) i)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c9_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize))\n  (_ : eq (Int.testbit m i) true),\neq (Int.testbit (Int.repr x) i) (Int.testbit (Int.repr y) i)"
                ],
                "tactic_res": [
                    "c10_goal : eq (Int.testbit (Int.repr x) i) (Int.testbit (Int.repr y) i)",
                    "c10_i : Z",
                    "c10_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                    "c10_H1 : eq (Int.testbit m i) true"
                ]
            },
            {
                "tactic_sig": "rewrite ! Int.testbit_repr by auto .",
                "tactic_sig_no_out_arg": "rewrite ! Int.testbit_repr by auto .",
                "tactic_args": [
                    "c10_goal : eq (Int.testbit (Int.repr x) i) (Int.testbit (Int.repr y) i)",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c11_goal : eq (Z.testbit x i) (Z.testbit y i)"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt _i ( Int.size _i ) ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i ( Int.size _i ) ) .",
                "tactic_args": [
                    "c11_goal : eq (Z.testbit x i) (Z.testbit y i)",
                    "c10_i : Z",
                    "c2_m : Int.int"
                ],
                "tactic_res": [
                    "c12_goal : eq (Z.testbit x i) (Z.testbit y i)",
                    "c12_l : Z.lt i (Int.size m)",
                    "c13_goal : eq (Z.testbit x i) (Z.testbit y i)",
                    "c13_g : Z.ge i (Int.size m)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c12_goal : eq (Z.testbit x i) (Z.testbit y i)",
                    "_global_1 : Z",
                    "_global_same_bits_eqmod : forall (n : nat) (x y i : Z) (_ : eqmod (two_power_nat n) x y)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i (Z.of_nat n))),\n       eq (Z.testbit x i) (Z.testbit y i)"
                ],
                "tactic_res": [
                    "c14_goal : eqmod (two_power_nat ?n) x y",
                    "c15_goal : Logic.and (Z.le 0 i) (Z.lt i (Z.of_nat ?n))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c14_goal : eqmod (two_power_nat ?n) x y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c15_goal : Logic.and (Z.le 0 i) (Z.lt i (Z.of_nat p))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( Int.testbit _i _i = false ) by ( eapply Int.bits_size_2 ; lia ) .",
                "tactic_sig_no_out_arg": "assert ( Int.testbit _i _i = false ) by ( eapply Int.bits_size_2 ; lia ) .",
                "tactic_args": [
                    "c2_m : Int.int",
                    "c10_i : Z"
                ],
                "tactic_res": [
                    "c13_H2 : eq (Int.testbit m i) false"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c13_goal : eq (Z.testbit x i) (Z.testbit y i)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "iagree_eqmod",
        "proof": [
            {
                "tactic_sig": "Lemma iagree_eqmod : forall x y m , iagree x y ( complete_mask m ) -> eqmod ( two_p ( Int.size m ) ) ( Int.unsigned x ) ( Int.unsigned y ) .",
                "tactic_sig_no_out_arg": "Lemma iagree_eqmod : forall x y m , iagree x y ( complete_mask m ) -> eqmod ( two_p ( Int.size m ) ) ( Int.unsigned x ) ( Int.unsigned y ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y m : Int.int) (_ : iagree x y (complete_mask m)),\neqmod (two_p (Int.size m)) (Int.unsigned x) (Int.unsigned y)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (x y m : Int.int) (_ : iagree x y (complete_mask m)),\neqmod (two_p (Int.size m)) (Int.unsigned x) (Int.unsigned y)"
                ],
                "tactic_res": [
                    "c2_goal : eqmod (two_p (Int.size m)) (Int.unsigned x) (Int.unsigned y)",
                    "c2_x : Int.int",
                    "c2_y : Int.int",
                    "c2_m : Int.int",
                    "c2_H : iagree x y (complete_mask m)"
                ]
            },
            {
                "tactic_sig": "set ( p := Z.to_nat ( Int.size _i ) ) .",
                "tactic_sig_no_out_arg": "set ( p := Z.to_nat ( Int.size _i ) ) .",
                "tactic_args": [
                    "c2_m : Int.int"
                ],
                "tactic_res": [
                    "c2_p : nat"
                ]
            },
            {
                "tactic_sig": "generalize ( Int.size_range _i ) .",
                "tactic_sig_no_out_arg": "generalize ( Int.size_range _i ) .",
                "tactic_args": [
                    "c2_goal : eqmod (two_p (Int.size m)) (Int.unsigned x) (Int.unsigned y)",
                    "c2_m : Int.int"
                ],
                "tactic_res": [
                    "c3_goal : forall\n  _ : Logic.and (Z.le 0 (Int.size m)) (Z.le (Int.size m) Int.zwordsize),\neqmod (two_p (Int.size m)) (Int.unsigned x) (Int.unsigned y)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros RANGE .",
                "tactic_args": [
                    "c3_goal : forall\n  _ : Logic.and (Z.le 0 (Int.size m)) (Z.le (Int.size m) Int.zwordsize),\neqmod (two_p (Int.size m)) (Int.unsigned x) (Int.unsigned y)"
                ],
                "tactic_res": [
                    "c4_goal : eqmod (two_p (Int.size m)) (Int.unsigned x) (Int.unsigned y)",
                    "c4_RANGE : Logic.and (Z.le 0 (Int.size m)) (Z.le (Int.size m) Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "assert ( EQ : Int.size _i = Z.of_nat _i ) .",
                "tactic_sig_no_out_arg": "assert ( EQ : Int.size _i = Z.of_nat _i ) .",
                "tactic_args": [
                    "c4_goal : eqmod (two_p (Int.size m)) (Int.unsigned x) (Int.unsigned y)",
                    "c2_m : Int.int",
                    "c2_p : nat"
                ],
                "tactic_res": [
                    "c5_goal : eq (Int.size m) (Z.of_nat p)",
                    "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned x) (Int.unsigned y)",
                    "c6_EQ : eq (Int.size m) (Z.of_nat p)"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "c5_goal : eq (Int.size m) (Z.of_nat p)"
                ],
                "tactic_res": [
                    "c7_goal : eq (Z.of_nat p) (Int.size m)"
                ]
            },
            {
                "tactic_sig": "apply Z2Nat._i .",
                "tactic_sig_no_out_arg": "apply Z2Nat._i .",
                "tactic_args": [
                    "c7_goal : eq (Z.of_nat p) (Int.size m)",
                    "_global_1 : Z",
                    "_global_id : forall _ : ?A, ?A\nwhere\n?A : [x : Int.int\n      y : Int.int\n      m : Int.int\n      H : iagree x y (complete_mask m)\n      p := Z.to_nat (Int.size m) : nat\n      RANGE : Logic.and (Z.le 0 (Int.size m))\n                (Z.le (Int.size m) Int.zwordsize) |- Type]"
                ],
                "tactic_res": [
                    "c8_goal : Z.le 0 (Int.size m)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c8_goal : Z.le 0 (Int.size m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned x) (Int.unsigned y)",
                    "_global_1 : Z",
                    "c6_EQ : eq (Int.size m) (Z.of_nat p)"
                ],
                "tactic_res": [
                    "c9_goal : eqmod (two_p (Z.of_nat p)) (Int.unsigned x) (Int.unsigned y)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c9_goal : eqmod (two_p (Z.of_nat p)) (Int.unsigned x) (Int.unsigned y)",
                    "_global_1 : Z",
                    "_global_two_power_nat_two_p : forall x : nat, eq (two_power_nat x) (two_p (Z.of_nat x))"
                ],
                "tactic_res": [
                    "c10_goal : eqmod (two_power_nat p) (Int.unsigned x) (Int.unsigned y)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : eqmod (two_power_nat p) (Int.unsigned x) (Int.unsigned y)",
                    "_global_1 : Z",
                    "_global_eqmod_same_bits : forall (n : nat) (x y : Z)\n         (_ : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i (Z.of_nat n))),\n              eq (Z.testbit x i) (Z.testbit y i)),\n       eqmod (two_power_nat n) x y"
                ],
                "tactic_res": [
                    "c11_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i (Z.of_nat p))),\neq (Z.testbit (Int.unsigned x) i) (Z.testbit (Int.unsigned y) i)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c11_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i (Z.of_nat p))),\neq (Z.testbit (Int.unsigned x) i) (Z.testbit (Int.unsigned y) i)"
                ],
                "tactic_res": [
                    "c12_goal : eq (Z.testbit (Int.unsigned x) i) (Z.testbit (Int.unsigned y) i)",
                    "c12_i : Z",
                    "c12_H0 : Logic.and (Z.le 0 i) (Z.lt i (Z.of_nat p))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : eq (Z.testbit (Int.unsigned x) i) (Z.testbit (Int.unsigned y) i)",
                    "_global_1 : Z",
                    "c2_H : iagree x y (complete_mask m)"
                ],
                "tactic_res": [
                    "c13_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                    "c14_goal : eq (Int.testbit (complete_mask m) i) true"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c13_goal : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c14_goal : eq (Int.testbit (complete_mask m) i) true",
                    "_global_1 : Z",
                    "_global_complete_mask : forall _ : Int.int, Int.int"
                ],
                "tactic_res": [
                    "c15_goal : eq (Int.testbit (Int.zero_ext (Int.size m) Int.mone) i) true"
                ]
            },
            {
                "tactic_sig": "rewrite Int.bits_zero_ext by lia .",
                "tactic_sig_no_out_arg": "rewrite Int.bits_zero_ext by lia .",
                "tactic_args": [
                    "c15_goal : eq (Int.testbit (Int.zero_ext (Int.size m) Int.mone) i) true",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c16_goal : eq (if zlt i (Int.size m) then Int.testbit Int.mone i else false) true"
                ]
            },
            {
                "tactic_sig": "rewrite _i by lia .",
                "tactic_sig_no_out_arg": "rewrite _i by lia .",
                "tactic_args": [
                    "c16_goal : eq (if zlt i (Int.size m) then Int.testbit Int.mone i else false) true",
                    "_global_1 : Z",
                    "_global_zlt_true : forall (A : Type) (x y : Z) (a b : A) (_ : Z.lt x y),\n       eq (if zlt x y then a else b) a"
                ],
                "tactic_res": [
                    "c17_goal : eq (Int.testbit Int.mone i) true"
                ]
            },
            {
                "tactic_sig": "rewrite Int.bits_mone by lia .",
                "tactic_sig_no_out_arg": "rewrite Int.bits_mone by lia .",
                "tactic_args": [
                    "c17_goal : eq (Int.testbit Int.mone i) true",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c18_goal : eq true true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : eq true true"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "complete_mask_idem",
        "proof": [
            {
                "tactic_sig": "Lemma complete_mask_idem : forall m , complete_mask ( complete_mask m ) = complete_mask m .",
                "tactic_sig_no_out_arg": "Lemma complete_mask_idem : forall m , complete_mask ( complete_mask m ) = complete_mask m .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall m : Int.int,\neq (complete_mask (complete_mask m)) (complete_mask m)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall m : Int.int,\neq (complete_mask (complete_mask m)) (complete_mask m)",
                    "_global_1 : Z",
                    "_global_complete_mask : forall _ : Int.int, Int.int"
                ],
                "tactic_res": [
                    "c2_goal : forall m : Int.int,\neq\n  (Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone))\n     Int.mone) (Int.zero_ext (Int.size m) Int.mone)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall m : Int.int,\neq\n  (Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone))\n     Int.mone) (Int.zero_ext (Int.size m) Int.mone)"
                ],
                "tactic_res": [
                    "c3_goal : eq\n  (Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone))\n     Int.mone) (Int.zero_ext (Int.size m) Int.mone)",
                    "c3_m : Int.int"
                ]
            },
            {
                "tactic_sig": "destruct ( Int.eq_dec _i Int.zero ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Int.eq_dec _i Int.zero ) .",
                "tactic_args": [
                    "c3_goal : eq\n  (Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone))\n     Int.mone) (Int.zero_ext (Int.size m) Int.mone)",
                    "c3_m : Int.int"
                ],
                "tactic_res": [
                    "c4_goal : eq\n  (Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone))\n     Int.mone) (Int.zero_ext (Int.size m) Int.mone)",
                    "c4_e : eq m Int.zero",
                    "c5_goal : eq\n  (Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone))\n     Int.mone) (Int.zero_ext (Int.size m) Int.mone)",
                    "c5_n : not (eq m Int.zero)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c4_goal : eq\n  (Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone))\n     Int.mone) (Int.zero_ext (Int.size m) Int.mone)",
                    "c3_m : Int.int"
                ],
                "tactic_res": [
                    "c6_goal : eq\n  (Int.zero_ext (Int.size (Int.zero_ext (Int.size Int.zero) Int.mone))\n     Int.mone) (Int.zero_ext (Int.size Int.zero) Int.mone)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c6_goal : eq\n  (Int.zero_ext (Int.size (Int.zero_ext (Int.size Int.zero) Int.mone))\n     Int.mone) (Int.zero_ext (Int.size Int.zero) Int.mone)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( Int.unsigned _i <> 0 ) .",
                "tactic_sig_no_out_arg": "assert ( Int.unsigned _i <> 0 ) .",
                "tactic_args": [
                    "c5_goal : eq\n  (Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone))\n     Int.mone) (Int.zero_ext (Int.size m) Int.mone)",
                    "c3_m : Int.int"
                ],
                "tactic_res": [
                    "c7_goal : not (eq (Int.unsigned m) 0)",
                    "c8_goal : eq\n  (Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone))\n     Int.mone) (Int.zero_ext (Int.size m) Int.mone)",
                    "c8_H : not (eq (Int.unsigned m) 0)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c7_goal : not (eq (Int.unsigned m) 0)"
                ],
                "tactic_res": [
                    "c9_goal : forall _ : eq (Int.unsigned m) 0, False"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c9_goal : forall _ : eq (Int.unsigned m) 0, False"
                ],
                "tactic_res": [
                    "c10_goal : False",
                    "c10_H : eq (Int.unsigned m) 0"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c10_goal : False",
                    "c5_n : not (eq m Int.zero)"
                ],
                "tactic_res": [
                    "c11_goal : eq m Int.zero"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( Int.repr_unsigned _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( Int.repr_unsigned _i ) .",
                "tactic_args": [
                    "c11_goal : eq m Int.zero",
                    "_global_1 : Z",
                    "c3_m : Int.int"
                ],
                "tactic_res": [
                    "c12_goal : eq (Int.repr (Int.unsigned m)) Int.zero"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c12_goal : eq (Int.repr (Int.unsigned m)) Int.zero",
                    "_global_1 : Z",
                    "c8_H : not (eq (Int.unsigned m) 0)"
                ],
                "tactic_res": [
                    "c13_goal : eq (Int.repr 0) Int.zero"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : eq (Int.repr 0) Int.zero"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( 0 < Int.size _i ) .",
                "tactic_sig_no_out_arg": "assert ( 0 < Int.size _i ) .",
                "tactic_args": [
                    "c8_goal : eq\n  (Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone))\n     Int.mone) (Int.zero_ext (Int.size m) Int.mone)",
                    "c3_m : Int.int"
                ],
                "tactic_res": [
                    "c14_goal : Z.lt 0 (Int.size m)",
                    "c15_goal : eq\n  (Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone))\n     Int.mone) (Int.zero_ext (Int.size m) Int.mone)",
                    "c15_H0 : Z.lt 0 (Int.size m)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : Z.lt 0 (Int.size m)",
                    "_global_1 : Z",
                    "_global_Zsize_pos' : forall (x : Z) (_ : Z.lt 0 x), Z.lt 0 (Zsize x)"
                ],
                "tactic_res": [
                    "c16_goal : Z.lt 0 (Int.unsigned m)"
                ]
            },
            {
                "tactic_sig": "generalize ( Int.unsigned_range _i ) .",
                "tactic_sig_no_out_arg": "generalize ( Int.unsigned_range _i ) .",
                "tactic_args": [
                    "c16_goal : Z.lt 0 (Int.unsigned m)",
                    "c3_m : Int.int"
                ],
                "tactic_res": [
                    "c17_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned m))\n        (Z.lt (Int.unsigned m) Int.modulus), Z.lt 0 (Int.unsigned m)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c17_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned m))\n        (Z.lt (Int.unsigned m) Int.modulus), Z.lt 0 (Int.unsigned m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( Int.size_range _i ) .",
                "tactic_sig_no_out_arg": "generalize ( Int.size_range _i ) .",
                "tactic_args": [
                    "c15_goal : eq\n  (Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone))\n     Int.mone) (Int.zero_ext (Int.size m) Int.mone)",
                    "c3_m : Int.int"
                ],
                "tactic_res": [
                    "c18_goal : forall\n  _ : Logic.and (Z.le 0 (Int.size m)) (Z.le (Int.size m) Int.zwordsize),\neq\n  (Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone))\n     Int.mone) (Int.zero_ext (Int.size m) Int.mone)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c18_goal : forall\n  _ : Logic.and (Z.le 0 (Int.size m)) (Z.le (Int.size m) Int.zwordsize),\neq\n  (Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone))\n     Int.mone) (Int.zero_ext (Int.size m) Int.mone)"
                ],
                "tactic_res": [
                    "c19_goal : eq\n  (Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone))\n     Int.mone) (Int.zero_ext (Int.size m) Int.mone)",
                    "c19_H1 : Logic.and (Z.le 0 (Int.size m)) (Z.le (Int.size m) Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c19_goal : eq\n  (Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone))\n     Int.mone) (Int.zero_ext (Int.size m) Int.mone)"
                ],
                "tactic_res": [
                    "c20_goal : eq (Int.size (Int.zero_ext (Int.size m) Int.mone)) (Int.size m)"
                ]
            },
            {
                "tactic_sig": "apply Int.bits_size_4 .",
                "tactic_sig_no_out_arg": "apply Int.bits_size_4 .",
                "tactic_args": [
                    "c20_goal : eq (Int.size (Int.zero_ext (Int.size m) Int.mone)) (Int.size m)",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c21_goal : Z.le 0 (Int.size m)",
                    "c22_goal : eq\n  (Int.testbit (Int.zero_ext (Int.size m) Int.mone)\n     (Z.pred (Int.size m))) true",
                    "c23_goal : forall (i : Z)\n  (_ : Logic.and (Z.le (Int.size m) i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (Int.zero_ext (Int.size m) Int.mone) i) false"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c21_goal : Z.le 0 (Int.size m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite Int.bits_zero_ext by lia .",
                "tactic_sig_no_out_arg": "rewrite Int.bits_zero_ext by lia .",
                "tactic_args": [
                    "c22_goal : eq\n  (Int.testbit (Int.zero_ext (Int.size m) Int.mone)\n     (Z.pred (Int.size m))) true",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c24_goal : eq\n  (if zlt (Z.pred (Int.size m)) (Int.size m)\n   then Int.testbit Int.mone (Z.pred (Int.size m))\n   else false) true"
                ]
            },
            {
                "tactic_sig": "rewrite _i by lia .",
                "tactic_sig_no_out_arg": "rewrite _i by lia .",
                "tactic_args": [
                    "c24_goal : eq\n  (if zlt (Z.pred (Int.size m)) (Int.size m)\n   then Int.testbit Int.mone (Z.pred (Int.size m))\n   else false) true",
                    "_global_1 : Z",
                    "_global_zlt_true : forall (A : Type) (x y : Z) (a b : A) (_ : Z.lt x y),\n       eq (if zlt x y then a else b) a"
                ],
                "tactic_res": [
                    "c25_goal : eq (Int.testbit Int.mone (Z.pred (Int.size m))) true"
                ]
            },
            {
                "tactic_sig": "apply Int.bits_mone .",
                "tactic_sig_no_out_arg": "apply Int.bits_mone .",
                "tactic_args": [
                    "c25_goal : eq (Int.testbit Int.mone (Z.pred (Int.size m))) true",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c26_goal : Logic.and (Z.le 0 (Z.pred (Int.size m)))\n  (Z.lt (Z.pred (Int.size m)) Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c26_goal : Logic.and (Z.le 0 (Z.pred (Int.size m)))\n  (Z.lt (Z.pred (Int.size m)) Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c23_goal : forall (i : Z)\n  (_ : Logic.and (Z.le (Int.size m) i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (Int.zero_ext (Int.size m) Int.mone) i) false"
                ],
                "tactic_res": [
                    "c27_goal : eq (Int.testbit (Int.zero_ext (Int.size m) Int.mone) i) false",
                    "c27_i : Z",
                    "c27_H2 : Logic.and (Z.le (Int.size m) i) (Z.lt i Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "rewrite Int.bits_zero_ext by lia .",
                "tactic_sig_no_out_arg": "rewrite Int.bits_zero_ext by lia .",
                "tactic_args": [
                    "c27_goal : eq (Int.testbit (Int.zero_ext (Int.size m) Int.mone) i) false",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c28_goal : eq (if zlt i (Int.size m) then Int.testbit Int.mone i else false) false"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c28_goal : eq (if zlt i (Int.size m) then Int.testbit Int.mone i else false) false",
                    "_global_1 : Z",
                    "_global_zlt_false : forall (A : Type) (x y : Z) (a b : A) (_ : Z.ge x y),\n       eq (if zlt x y then a else b) b"
                ],
                "tactic_res": [
                    "c29_goal : Z.ge i (Int.size m)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c29_goal : Z.ge i (Int.size m)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "andimm_sound",
        "proof": [
            {
                "tactic_sig": "Lemma andimm_sound : forall v w x n , vagree v w ( andimm x n ) -> vagree ( Val.and v ( Vint n ) ) ( Val.and w ( Vint n ) ) x .",
                "tactic_sig_no_out_arg": "Lemma andimm_sound : forall v w x n , vagree v w ( andimm x n ) -> vagree ( Val.and v ( Vint n ) ) ( Val.and w ( Vint n ) ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x",
                    "_global_1 : Z",
                    "_global_andimm : forall (_ : nval) (_ : Int.int), nval"
                ],
                "tactic_res": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w\n         match x with\n         | Nothing => Nothing\n         | I m => I (Int.and m n)\n         | All => I n\n         end), vagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w\n         match x with\n         | Nothing => Nothing\n         | I m => I (Int.and m n)\n         | All => I n\n         end), vagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                    "c3_goal : vagree (Val.and v (Vint n)) (Val.and w (Vint n)) x",
                    "c3_v : val",
                    "c3_w : val",
                    "c3_x : nval",
                    "c3_n : Int.int",
                    "c3_H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.and m n)\n  | All => I n\n  end"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : vagree (Val.and v (Vint n)) (Val.and w (Vint n)) x",
                    "c3_x : nval"
                ],
                "tactic_res": [
                    "c4_goal : vagree (Val.and v (Vint n)) (Val.and w (Vint n)) Nothing",
                    "c4_H : vagree v w Nothing",
                    "c5_goal : vagree (Val.and v (Vint n)) (Val.and w (Vint n)) (I m)",
                    "c5_H : vagree v w (I (Int.and m n))",
                    "c5_m : Int.int",
                    "c6_goal : vagree (Val.and v (Vint n)) (Val.and w (Vint n)) All",
                    "c6_H : vagree v w (I n)"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c4_goal : vagree (Val.and v (Vint n)) (Val.and w (Vint n)) Nothing"
                ],
                "tactic_res": [
                    "c7_goal : True",
                    "c7_H : True"
                ]
            },
            {
                "tactic_sig": "unfold Val._i .",
                "tactic_sig_no_out_arg": "unfold Val._i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "_global_and : forall (_ : aval) (_ : aval), aval"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c5_goal : vagree (Val.and v (Vint n)) (Val.and w (Vint n)) (I m)"
                ],
                "tactic_res": [
                    "c8_goal : match Val.and v (Vint n) with\n| Vint p =>\n    match Val.and w (Vint n) with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c8_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.and m n)\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "unfold Val._i .",
                "tactic_sig_no_out_arg": "unfold Val._i .",
                "tactic_args": [
                    "c8_goal : match Val.and v (Vint n) with\n| Vint p =>\n    match Val.and w (Vint n) with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "_global_2 : Z",
                    "_global_and : forall (_ : aval) (_ : aval), aval"
                ],
                "tactic_res": [
                    "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c6_goal : vagree (Val.and v (Vint n)) (Val.and w (Vint n)) All"
                ],
                "tactic_res": [
                    "c10_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                    "c10_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "unfold Val._i .",
                "tactic_sig_no_out_arg": "unfold Val._i .",
                "tactic_args": [
                    "c10_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                    "_global_3 : Z",
                    "_global_and : forall (_ : aval) (_ : aval), aval"
                ],
                "tactic_res": [
                    "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                    "c12_H : iagree i i0 (Int.and m n)",
                    "c12_i0 : Int.int",
                    "c12_i : Int.int"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                    "_global_1 : Z",
                    "_global_iagree_and : forall (x y n m : Int.int) (_ : iagree x y (Int.and m n)),\n       iagree (Int.and x n) (Int.and y n) m"
                ],
                "tactic_res": [
                    "c13_goal : iagree i i0 (Int.and m n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : iagree i i0 (Int.and m n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                    "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                    "c14_H : iagree i i0 n",
                    "c14_i0 : Int.int",
                    "c14_i : Int.int"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "_global_iagree_and_eq : forall x y mask : Int.int,\n       iff (iagree x y mask) (eq (Int.and x mask) (Int.and y mask))",
                    "c3_H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.and m n)\n  | All => I n\n  end"
                ],
                "tactic_res": [
                    "c14_H : eq (Int.and i n) (Int.and i0 n)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                    "_global_1 : Z",
                    "c3_H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.and m n)\n  | All => I n\n  end"
                ],
                "tactic_res": [
                    "c15_goal : Val.lessdef (Vint (Int.and i0 n)) (Vint (Int.and i0 n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : Val.lessdef (Vint (Int.and i0 n)) (Vint (Int.and i0 n))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "orimm_sound",
        "proof": [
            {
                "tactic_sig": "Lemma orimm_sound : forall v w x n , vagree v w ( orimm x n ) -> vagree ( Val.or v ( Vint n ) ) ( Val.or w ( Vint n ) ) x .",
                "tactic_sig_no_out_arg": "Lemma orimm_sound : forall v w x n , vagree v w ( orimm x n ) -> vagree ( Val.or v ( Vint n ) ) ( Val.or w ( Vint n ) ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x",
                    "_global_1 : Z",
                    "_global_orimm : forall (_ : nval) (_ : Int.int), nval"
                ],
                "tactic_res": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w\n         match x with\n         | Nothing => Nothing\n         | I m => I (Int.and m (Int.not n))\n         | All => I (Int.not n)\n         end), vagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w\n         match x with\n         | Nothing => Nothing\n         | I m => I (Int.and m (Int.not n))\n         | All => I (Int.not n)\n         end), vagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                    "c3_goal : vagree (Val.or v (Vint n)) (Val.or w (Vint n)) x",
                    "c3_v : val",
                    "c3_w : val",
                    "c3_x : nval",
                    "c3_n : Int.int",
                    "c3_H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.and m (Int.not n))\n  | All => I (Int.not n)\n  end"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : vagree (Val.or v (Vint n)) (Val.or w (Vint n)) x",
                    "c3_x : nval"
                ],
                "tactic_res": [
                    "c4_goal : vagree (Val.or v (Vint n)) (Val.or w (Vint n)) Nothing",
                    "c4_H : vagree v w Nothing",
                    "c5_goal : vagree (Val.or v (Vint n)) (Val.or w (Vint n)) (I m)",
                    "c5_H : vagree v w (I (Int.and m (Int.not n)))",
                    "c5_m : Int.int",
                    "c6_goal : vagree (Val.or v (Vint n)) (Val.or w (Vint n)) All",
                    "c6_H : vagree v w (I (Int.not n))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c4_goal : vagree (Val.or v (Vint n)) (Val.or w (Vint n)) Nothing"
                ],
                "tactic_res": [
                    "c7_goal : True",
                    "c7_H : True"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c5_goal : vagree (Val.or v (Vint n)) (Val.or w (Vint n)) (I m)"
                ],
                "tactic_res": [
                    "c8_goal : match Val.or v (Vint n) with\n| Vint p =>\n    match Val.or w (Vint n) with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c8_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.and m (Int.not n))\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c6_goal : vagree (Val.or v (Vint n)) (Val.or w (Vint n)) All"
                ],
                "tactic_res": [
                    "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                    "c9_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold Val._i .",
                "tactic_sig_no_out_arg": "unfold Val._i .",
                "tactic_args": [
                    "c8_goal : match Val.or v (Vint n) with\n| Vint p =>\n    match Val.or w (Vint n) with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "_global_1 : Z",
                    "_global_or : forall (_ : aval) (_ : aval), aval"
                ],
                "tactic_res": [
                    "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                    "c11_H : iagree i i0 (Int.and m (Int.not n))",
                    "c11_i0 : Int.int",
                    "c11_i : Int.int"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                    "_global_1 : Z",
                    "_global_iagree_or : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\n       iagree (Int.or x n) (Int.or y n) m"
                ],
                "tactic_res": [
                    "c12_goal : iagree i i0 (Int.and m (Int.not n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : iagree i i0 (Int.and m (Int.not n))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                    "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                    "c13_H : iagree i i0 (Int.not n)",
                    "c13_i0 : Int.int",
                    "c13_i : Int.int"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))"
                ],
                "tactic_res": [
                    "c14_goal : Val.lessdef (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ]
            },
            {
                "tactic_sig": "apply Val.lessdef_same .",
                "tactic_sig_no_out_arg": "apply Val.lessdef_same .",
                "tactic_args": [
                    "c14_goal : Val.lessdef (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c15_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c15_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                    "c16_goal : eq (Int.or i n) (Int.or i0 n)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c16_goal : eq (Int.or i n) (Int.or i0 n)",
                    "_global_1 : Z",
                    "_global_iagree_mone : forall (p q : Int.int) (_ : iagree p q Int.mone), eq p q"
                ],
                "tactic_res": [
                    "c17_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c17_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone",
                    "_global_1 : Z",
                    "_global_iagree_or : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\n       iagree (Int.or x n) (Int.or y n) m"
                ],
                "tactic_res": [
                    "c18_goal : iagree i i0 (Int.and Int.mone (Int.not n))"
                ]
            },
            {
                "tactic_sig": "rewrite Int.and_commut .",
                "tactic_sig_no_out_arg": "rewrite Int.and_commut .",
                "tactic_args": [
                    "c18_goal : iagree i i0 (Int.and Int.mone (Int.not n))",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c19_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
            },
            {
                "tactic_sig": "rewrite Int.and_mone .",
                "tactic_sig_no_out_arg": "rewrite Int.and_mone .",
                "tactic_args": [
                    "c19_goal : iagree i i0 (Int.and (Int.not n) Int.mone)",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c20_goal : iagree i i0 (Int.not n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c20_goal : iagree i i0 (Int.not n)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "bitwise_idem",
        "proof": [
            {
                "tactic_sig": "Remark bitwise_idem : forall nv , bitwise ( bitwise nv ) = bitwise nv .",
                "tactic_sig_no_out_arg": "Remark bitwise_idem : forall nv , bitwise ( bitwise nv ) = bitwise nv .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall nv : nval, eq (bitwise (bitwise nv)) (bitwise nv)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c1_goal : forall nv : nval, eq (bitwise (bitwise nv)) (bitwise nv)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "vagree_bitwise_binop",
        "proof": [
            {
                "tactic_sig": "Lemma vagree_bitwise_binop : forall f , ( forall p1 p2 q1 q2 m , iagree p1 q1 m -> iagree p2 q2 m -> iagree ( f p1 p2 ) ( f q1 q2 ) m ) -> forall v1 w1 v2 w2 x , vagree v1 w1 ( bitwise x ) -> vagree v2 w2 ( bitwise x ) -> vagree ( match v1 , v2 with Vint i1 , Vint i2 => Vint ( f i1 i2 ) | _ , _ => Vundef end ) ( match w1 , w2 with Vint i1 , Vint i2 => Vint ( f i1 i2 ) | _ , _ => Vundef end ) x .",
                "tactic_sig_no_out_arg": "Lemma vagree_bitwise_binop : forall f , ( forall p1 p2 q1 q2 m , iagree p1 q1 m -> iagree p2 q2 m -> iagree ( f p1 p2 ) ( f q1 q2 ) m ) -> forall v1 w1 v2 w2 x , vagree v1 w1 ( bitwise x ) -> vagree v2 w2 ( bitwise x ) -> vagree ( match v1 , v2 with Vint i1 , Vint i2 => Vint ( f i1 i2 ) | _ , _ => Vundef end ) ( match w1 , w2 with Vint i1 , Vint i2 => Vint ( f i1 i2 ) | _ , _ => Vundef end ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                    "_global_1 : Z",
                    "_global_bitwise : forall _ : nval, nval"
                ],
                "tactic_res": [
                    "c2_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 x)\n  (_ : vagree v2 w2 x),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 x)\n  (_ : vagree v2 w2 x),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
                ],
                "tactic_res": [
                    "c3_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                    "c3_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                    "c3_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                    "c3_v1 : val",
                    "c3_w1 : val",
                    "c3_v2 : val",
                    "c3_w2 : val",
                    "c3_x : nval",
                    "c3_H0 : vagree v1 w1 x",
                    "c3_H1 : vagree v2 w2 x"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o | _o _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                    "c3_x : nval"
                ],
                "tactic_res": [
                    "c4_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end Nothing",
                    "c4_H1 : vagree v2 w2 Nothing",
                    "c4_H0 : vagree v1 w1 Nothing",
                    "c5_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (I m)",
                    "c5_H1 : vagree v2 w2 (I m)",
                    "c5_H0 : vagree v1 w1 (I m)",
                    "c5_m : Int.int",
                    "c6_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end All",
                    "c6_H1 : vagree v2 w2 All",
                    "c6_H0 : vagree v1 w1 All"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c4_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end Nothing"
                ],
                "tactic_res": [
                    "c7_goal : True",
                    "c7_H1 : True",
                    "c7_H0 : True"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c5_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end (I m)"
                ],
                "tactic_res": [
                    "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c8_H1 : match v2 with\n| Vint p => match w2 with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend",
                    "c8_H0 : match v1 with\n| Vint p => match w1 with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c6_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end All"
                ],
                "tactic_res": [
                    "c9_goal : Val.lessdef\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end",
                    "c9_H1 : Val.lessdef v2 w2",
                    "c9_H0 : Val.lessdef v1 w1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c9_goal : Val.lessdef\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end",
                    "c3_H0 : vagree v1 w1 x"
                ],
                "tactic_res": [
                    "c10_goal : Val.lessdef\n  match w1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end",
                    "c11_goal : Val.lessdef Vundef\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : Val.lessdef Vundef\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c10_goal : Val.lessdef\n  match w1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end",
                    "c3_H1 : vagree v2 w2 x"
                ],
                "tactic_res": [
                    "c12_goal : Val.lessdef\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end",
                    "c13_goal : Val.lessdef match w1 with\n            | Vundef | _ => Vundef\n            end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : Val.lessdef\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  | _o | _o | _o | _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c13_goal : Val.lessdef match w1 with\n            | Vundef | _ => Vundef\n            end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end",
                    "c3_w1 : val"
                ],
                "tactic_res": [
                    "c14_goal : Val.lessdef Vundef Vundef",
                    "c15_goal : Val.lessdef Vundef\n  match w2 with\n  | Vint i2 => Vint (f i i2)\n  | _ => Vundef\n  end",
                    "c15_i : Int.int",
                    "c16_goal : Val.lessdef Vundef Vundef",
                    "c16_i : Int64.int",
                    "c17_goal : Val.lessdef Vundef Vundef",
                    "c17_f0 : float",
                    "c18_goal : Val.lessdef Vundef Vundef",
                    "c18_f0 : float32",
                    "c19_goal : Val.lessdef Vundef Vundef",
                    "c19_i : Ptrofs.int",
                    "c19_b : block"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : Val.lessdef Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : Val.lessdef Vundef\n  match w2 with\n  | Vint i2 => Vint (f i i2)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : Val.lessdef Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : Val.lessdef Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : Val.lessdef Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : Val.lessdef Vundef Vundef"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "and_sound",
        "proof": [
            {
                "tactic_sig": "Lemma and_sound : forall v1 w1 v2 w2 x , vagree v1 w1 ( bitwise x ) -> vagree v2 w2 ( bitwise x ) -> vagree ( Val.and v1 v2 ) ( Val.and w1 w2 ) x .",
                "tactic_sig_no_out_arg": "Lemma and_sound : forall v1 w1 v2 w2 x , vagree v1 w1 ( bitwise x ) -> vagree v2 w2 ( bitwise x ) -> vagree ( Val.and v1 v2 ) ( Val.and w1 w2 ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree (Val.and v1 v2) (Val.and w1 w2) x"
                ]
            },
            {
                "tactic_sig": "apply ( _i Int._i ( _i _i Int._i Int.bits_and ) ) .",
                "tactic_sig_no_out_arg": "apply ( _i Int._i ( _i _i Int._i Int.bits_and ) ) .",
                "tactic_args": [
                    "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree (Val.and v1 v2) (Val.and w1 w2) x",
                    "_global_1 : Z",
                    "_global_vagree_bitwise_binop : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n         (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n                (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n         (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n         (_ : vagree v2 w2 (bitwise x)),\n       vagree\n         match v1 with\n         | Vint i1 =>\n             match v2 with\n             | Vint i2 => Vint (f i1 i2)\n             | _ => Vundef\n             end\n         | _ => Vundef\n         end\n         match w1 with\n         | Vint i1 =>\n             match w2 with\n             | Vint i2 => Vint (f i1 i2)\n             | _ => Vundef\n             end\n         | _ => Vundef\n         end x",
                    "_global_and : forall (_ : aval) (_ : aval), aval",
                    "_global_iagree_bitwise_binop : forall (sem : forall (_ : bool) (_ : bool), bool)\n         (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n         (_ : forall (x y : Int.int) (i : Z)\n                (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n              eq (Int.testbit (f x y) i)\n                (sem (Int.testbit x i) (Int.testbit y i)))\n         (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) \n         (_ : iagree x2 y2 m), iagree (f x1 x2) (f y1 y2) m",
                    "_global_andb : forall (_ : bool) (_ : bool), bool",
                    "_global_and : forall (_ : aval) (_ : aval), aval"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "or_sound",
        "proof": [
            {
                "tactic_sig": "Lemma or_sound : forall v1 w1 v2 w2 x , vagree v1 w1 ( bitwise x ) -> vagree v2 w2 ( bitwise x ) -> vagree ( Val.or v1 v2 ) ( Val.or w1 w2 ) x .",
                "tactic_sig_no_out_arg": "Lemma or_sound : forall v1 w1 v2 w2 x , vagree v1 w1 ( bitwise x ) -> vagree v2 w2 ( bitwise x ) -> vagree ( Val.or v1 v2 ) ( Val.or w1 w2 ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree (Val.or v1 v2) (Val.or w1 w2) x"
                ]
            },
            {
                "tactic_sig": "apply ( _i Int._i ( _i _i Int._i Int.bits_or ) ) .",
                "tactic_sig_no_out_arg": "apply ( _i Int._i ( _i _i Int._i Int.bits_or ) ) .",
                "tactic_args": [
                    "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree (Val.or v1 v2) (Val.or w1 w2) x",
                    "_global_1 : Z",
                    "_global_vagree_bitwise_binop : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n         (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n                (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n         (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n         (_ : vagree v2 w2 (bitwise x)),\n       vagree\n         match v1 with\n         | Vint i1 =>\n             match v2 with\n             | Vint i2 => Vint (f i1 i2)\n             | _ => Vundef\n             end\n         | _ => Vundef\n         end\n         match w1 with\n         | Vint i1 =>\n             match w2 with\n             | Vint i2 => Vint (f i1 i2)\n             | _ => Vundef\n             end\n         | _ => Vundef\n         end x",
                    "_global_or : forall (_ : aval) (_ : aval), aval",
                    "_global_iagree_bitwise_binop : forall (sem : forall (_ : bool) (_ : bool), bool)\n         (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n         (_ : forall (x y : Int.int) (i : Z)\n                (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n              eq (Int.testbit (f x y) i)\n                (sem (Int.testbit x i) (Int.testbit y i)))\n         (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) \n         (_ : iagree x2 y2 m), iagree (f x1 x2) (f y1 y2) m",
                    "_global_orb : forall (_ : bool) (_ : bool), bool",
                    "_global_or : forall (_ : aval) (_ : aval), aval"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "xor_sound",
        "proof": [
            {
                "tactic_sig": "Lemma xor_sound : forall v1 w1 v2 w2 x , vagree v1 w1 ( bitwise x ) -> vagree v2 w2 ( bitwise x ) -> vagree ( Val.xor v1 v2 ) ( Val.xor w1 w2 ) x .",
                "tactic_sig_no_out_arg": "Lemma xor_sound : forall v1 w1 v2 w2 x , vagree v1 w1 ( bitwise x ) -> vagree v2 w2 ( bitwise x ) -> vagree ( Val.xor v1 v2 ) ( Val.xor w1 w2 ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree (Val.xor v1 v2) (Val.xor w1 w2) x"
                ]
            },
            {
                "tactic_sig": "apply ( _i Int._i ( _i _i Int._i Int.bits_xor ) ) .",
                "tactic_sig_no_out_arg": "apply ( _i Int._i ( _i _i Int._i Int.bits_xor ) ) .",
                "tactic_args": [
                    "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree (Val.xor v1 v2) (Val.xor w1 w2) x",
                    "_global_1 : Z",
                    "_global_vagree_bitwise_binop : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n         (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n                (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n         (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n         (_ : vagree v2 w2 (bitwise x)),\n       vagree\n         match v1 with\n         | Vint i1 =>\n             match v2 with\n             | Vint i2 => Vint (f i1 i2)\n             | _ => Vundef\n             end\n         | _ => Vundef\n         end\n         match w1 with\n         | Vint i1 =>\n             match w2 with\n             | Vint i2 => Vint (f i1 i2)\n             | _ => Vundef\n             end\n         | _ => Vundef\n         end x",
                    "_global_xor : forall (_ : aval) (_ : aval), aval",
                    "_global_iagree_bitwise_binop : forall (sem : forall (_ : bool) (_ : bool), bool)\n         (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n         (_ : forall (x y : Int.int) (i : Z)\n                (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n              eq (Int.testbit (f x y) i)\n                (sem (Int.testbit x i) (Int.testbit y i)))\n         (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) \n         (_ : iagree x2 y2 m), iagree (f x1 x2) (f y1 y2) m",
                    "_global_xorb : forall (_ : bool) (_ : bool), bool",
                    "_global_xor : forall (_ : aval) (_ : aval), aval"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "notint_sound",
        "proof": [
            {
                "tactic_sig": "Lemma notint_sound : forall v w x , vagree v w ( bitwise x ) -> vagree ( Val.notint v ) ( Val.notint w ) x .",
                "tactic_sig_no_out_arg": "Lemma notint_sound : forall v w x , vagree v w ( bitwise x ) -> vagree ( Val.notint v ) ( Val.notint w ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (x : nval) (_ : vagree v w (bitwise x)),\nvagree (Val.notint v) (Val.notint w) x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (x : nval) (_ : vagree v w (bitwise x)),\nvagree (Val.notint v) (Val.notint w) x"
                ],
                "tactic_res": [
                    "c2_goal : vagree (Val.notint v) (Val.notint w) x",
                    "c2_v : val",
                    "c2_w : val",
                    "c2_x : nval",
                    "c2_H : vagree v w (bitwise x)"
                ]
            },
            {
                "tactic_sig": "rewrite ! Val.not_xor .",
                "tactic_sig_no_out_arg": "rewrite ! Val.not_xor .",
                "tactic_args": [
                    "c2_goal : vagree (Val.notint v) (Val.notint w) x",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c3_goal : vagree (Val.xor v (Vint Int.mone)) (Val.xor w (Vint Int.mone)) x"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c3_goal : vagree (Val.xor v (Vint Int.mone)) (Val.xor w (Vint Int.mone)) x",
                    "_global_1 : Z",
                    "_global_xor_sound : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n         (_ : vagree v2 w2 (bitwise x)),\n       vagree (Val.xor v1 v2) (Val.xor w1 w2) x"
                ],
                "tactic_res": [
                    "c4_goal : vagree v w (bitwise x)",
                    "c5_goal : vagree (Vint Int.mone) (Vint Int.mone) (bitwise x)"
                ]
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c4_goal : vagree v w (bitwise x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c5_goal : vagree (Vint Int.mone) (Vint Int.mone) (bitwise x)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "shlimm_sound",
        "proof": [
            {
                "tactic_sig": "Lemma shlimm_sound : forall v w x n , vagree v w ( shlimm x n ) -> vagree ( Val.shl v ( Vint n ) ) ( Val.shl w ( Vint n ) ) x .",
                "tactic_sig_no_out_arg": "Lemma shlimm_sound : forall v w x n , vagree v w ( shlimm x n ) -> vagree ( Val.shl v ( Vint n ) ) ( Val.shl w ( Vint n ) ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (shlimm x n)),\nvagree (Val.shl v (Vint n)) (Val.shl w (Vint n)) x"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (shlimm x n)),\nvagree (Val.shl v (Vint n)) (Val.shl w (Vint n)) x",
                    "_global_1 : Z",
                    "_global_shlimm : forall (_ : nval) (_ : Int.int), nval"
                ],
                "tactic_res": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w\n         match x with\n         | Nothing => Nothing\n         | I m => I (Int.shru m n)\n         | All => I (Int.shru Int.mone n)\n         end), vagree (Val.shl v (Vint n)) (Val.shl w (Vint n)) x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w\n         match x with\n         | Nothing => Nothing\n         | I m => I (Int.shru m n)\n         | All => I (Int.shru Int.mone n)\n         end), vagree (Val.shl v (Vint n)) (Val.shl w (Vint n)) x"
                ],
                "tactic_res": [
                    "c3_goal : vagree (Val.shl v (Vint n)) (Val.shl w (Vint n)) x",
                    "c3_v : val",
                    "c3_w : val",
                    "c3_x : nval",
                    "c3_n : Int.int",
                    "c3_H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shru m n)\n  | All => I (Int.shru Int.mone n)\n  end"
                ]
            },
            {
                "tactic_sig": "unfold Val._i .",
                "tactic_sig_no_out_arg": "unfold Val._i .",
                "tactic_args": [
                    "c3_goal : vagree (Val.shl v (Vint n)) (Val.shl w (Vint n)) x",
                    "_global_1 : Z",
                    "_global_shl : forall (_ : aval) (_ : aval), aval"
                ],
                "tactic_res": [
                    "c4_goal : vagree\n  match v with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shl n1 n) else Vundef\n  | _ => Vundef\n  end\n  match w with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shl n1 n) else Vundef\n  | _ => Vundef\n  end x"
                ]
            },
            {
                "tactic_sig": "destruct ( Int.ltu _i Int.iwordsize ) as [  | ] .",
                "tactic_sig_no_out_arg": "destruct ( Int.ltu _i Int.iwordsize ) .",
                "tactic_args": [
                    "c4_goal : vagree\n  match v with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shl n1 n) else Vundef\n  | _ => Vundef\n  end\n  match w with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shl n1 n) else Vundef\n  | _ => Vundef\n  end x",
                    "c3_n : Int.int"
                ],
                "tactic_res": [
                    "c5_goal : vagree match v with\n       | Vint n1 => Vint (Int.shl n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end x",
                    "c6_goal : vagree match v with\n       | Vundef | _ => Vundef\n       end match w with\n           | Vundef | _ => Vundef\n           end x"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c5_goal : vagree match v with\n       | Vint n1 => Vint (Int.shl n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end x",
                    "c3_x : nval"
                ],
                "tactic_res": [
                    "c7_goal : vagree match v with\n       | Vint n1 => Vint (Int.shl n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end Nothing",
                    "c7_H : vagree v w Nothing",
                    "c8_goal : vagree match v with\n       | Vint n1 => Vint (Int.shl n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end (I m)",
                    "c8_H : vagree v w (I (Int.shru m n))",
                    "c8_m : Int.int",
                    "c9_goal : vagree match v with\n       | Vint n1 => Vint (Int.shl n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end All",
                    "c9_H : vagree v w (I (Int.shru Int.mone n))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c7_goal : vagree match v with\n       | Vint n1 => Vint (Int.shl n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end Nothing"
                ],
                "tactic_res": [
                    "c10_goal : True",
                    "c10_H : True"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c8_goal : vagree match v with\n       | Vint n1 => Vint (Int.shl n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end (I m)"
                ],
                "tactic_res": [
                    "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c11_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.shru m n)\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c9_goal : vagree match v with\n       | Vint n1 => Vint (Int.shl n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end All"
                ],
                "tactic_res": [
                    "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end",
                    "c12_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.shru Int.mone n)\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                    "c13_H : iagree i i0 (Int.shru m n)",
                    "c13_i0 : Int.int",
                    "c13_i : Int.int"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                    "_global_1 : Z",
                    "_global_iagree_shl : forall (x y m n : Int.int) (_ : iagree x y (Int.shru m n)),\n       iagree (Int.shl x n) (Int.shl y n) m"
                ],
                "tactic_res": [
                    "c14_goal : iagree i i0 (Int.shru m n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : iagree i i0 (Int.shru m n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                    "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                    "c15_H : iagree i i0 (Int.shru Int.mone n)",
                    "c15_i0 : Int.int",
                    "c15_i : Int.int"
                ]
            },
            {
                "tactic_sig": "apply Val.lessdef_same .",
                "tactic_sig_no_out_arg": "apply Val.lessdef_same .",
                "tactic_args": [
                    "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c16_goal : eq (Vint (Int.shl i n)) (Vint (Int.shl i0 n))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c16_goal : eq (Vint (Int.shl i n)) (Vint (Int.shl i0 n))"
                ],
                "tactic_res": [
                    "c17_goal : eq (Int.shl i n) (Int.shl i0 n)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c17_goal : eq (Int.shl i n) (Int.shl i0 n)",
                    "_global_1 : Z",
                    "_global_iagree_mone : forall (p q : Int.int) (_ : iagree p q Int.mone), eq p q"
                ],
                "tactic_res": [
                    "c18_goal : iagree (Int.shl i n) (Int.shl i0 n) Int.mone"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c18_goal : iagree (Int.shl i n) (Int.shl i0 n) Int.mone",
                    "_global_1 : Z",
                    "_global_iagree_shl : forall (x y m n : Int.int) (_ : iagree x y (Int.shru m n)),\n       iagree (Int.shl x n) (Int.shl y n) m"
                ],
                "tactic_res": [
                    "c19_goal : iagree i i0 (Int.shru Int.mone n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : iagree i i0 (Int.shru Int.mone n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c6_goal : vagree match v with\n       | Vundef | _ => Vundef\n       end match w with\n           | Vundef | _ => Vundef\n           end x",
                    "c3_v : val"
                ],
                "tactic_res": [
                    "c20_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x",
                    "c20_H : vagree Vundef w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shru m n)\n  | All => I (Int.shru Int.mone n)\n  end",
                    "c21_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x",
                    "c21_H : vagree (Vint i) w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shru m n)\n  | All => I (Int.shru Int.mone n)\n  end",
                    "c21_i : Int.int",
                    "c22_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x",
                    "c22_H : vagree (Vlong i) w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shru m n)\n  | All => I (Int.shru Int.mone n)\n  end",
                    "c22_i : Int64.int",
                    "c23_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x",
                    "c23_H : vagree (Vfloat f) w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shru m n)\n  | All => I (Int.shru Int.mone n)\n  end",
                    "c23_f : float",
                    "c24_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x",
                    "c24_H : vagree (Vsingle f) w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shru m n)\n  | All => I (Int.shru Int.mone n)\n  end",
                    "c24_f : float32",
                    "c25_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x",
                    "c25_H : vagree (Vptr b i) w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shru m n)\n  | All => I (Int.shru Int.mone n)\n  end",
                    "c25_i : Ptrofs.int",
                    "c25_b : block"
                ]
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c20_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c21_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c22_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c23_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c24_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c25_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "shruimm_sound",
        "proof": [
            {
                "tactic_sig": "Lemma shruimm_sound : forall v w x n , vagree v w ( shruimm x n ) -> vagree ( Val.shru v ( Vint n ) ) ( Val.shru w ( Vint n ) ) x .",
                "tactic_sig_no_out_arg": "Lemma shruimm_sound : forall v w x n , vagree v w ( shruimm x n ) -> vagree ( Val.shru v ( Vint n ) ) ( Val.shru w ( Vint n ) ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (shruimm x n)),\nvagree (Val.shru v (Vint n)) (Val.shru w (Vint n)) x"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (shruimm x n)),\nvagree (Val.shru v (Vint n)) (Val.shru w (Vint n)) x",
                    "_global_1 : Z",
                    "_global_shruimm : forall (_ : nval) (_ : Int.int), nval"
                ],
                "tactic_res": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w\n         match x with\n         | Nothing => Nothing\n         | I m => I (Int.shl m n)\n         | All => I (Int.shl Int.mone n)\n         end), vagree (Val.shru v (Vint n)) (Val.shru w (Vint n)) x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w\n         match x with\n         | Nothing => Nothing\n         | I m => I (Int.shl m n)\n         | All => I (Int.shl Int.mone n)\n         end), vagree (Val.shru v (Vint n)) (Val.shru w (Vint n)) x"
                ],
                "tactic_res": [
                    "c3_goal : vagree (Val.shru v (Vint n)) (Val.shru w (Vint n)) x",
                    "c3_v : val",
                    "c3_w : val",
                    "c3_x : nval",
                    "c3_n : Int.int",
                    "c3_H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shl m n)\n  | All => I (Int.shl Int.mone n)\n  end"
                ]
            },
            {
                "tactic_sig": "unfold Val._i .",
                "tactic_sig_no_out_arg": "unfold Val._i .",
                "tactic_args": [
                    "c3_goal : vagree (Val.shru v (Vint n)) (Val.shru w (Vint n)) x",
                    "_global_1 : Z",
                    "_global_shru : forall (_ : aval) (_ : aval), aval"
                ],
                "tactic_res": [
                    "c4_goal : vagree\n  match v with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shru n1 n) else Vundef\n  | _ => Vundef\n  end\n  match w with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shru n1 n) else Vundef\n  | _ => Vundef\n  end x"
                ]
            },
            {
                "tactic_sig": "destruct ( Int.ltu _i Int.iwordsize ) as [  | ] .",
                "tactic_sig_no_out_arg": "destruct ( Int.ltu _i Int.iwordsize ) .",
                "tactic_args": [
                    "c4_goal : vagree\n  match v with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shru n1 n) else Vundef\n  | _ => Vundef\n  end\n  match w with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shru n1 n) else Vundef\n  | _ => Vundef\n  end x",
                    "c3_n : Int.int"
                ],
                "tactic_res": [
                    "c5_goal : vagree match v with\n       | Vint n1 => Vint (Int.shru n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end x",
                    "c6_goal : vagree match v with\n       | Vundef | _ => Vundef\n       end match w with\n           | Vundef | _ => Vundef\n           end x"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c5_goal : vagree match v with\n       | Vint n1 => Vint (Int.shru n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end x",
                    "c3_x : nval"
                ],
                "tactic_res": [
                    "c7_goal : vagree match v with\n       | Vint n1 => Vint (Int.shru n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end Nothing",
                    "c7_H : vagree v w Nothing",
                    "c8_goal : vagree match v with\n       | Vint n1 => Vint (Int.shru n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end (I m)",
                    "c8_H : vagree v w (I (Int.shl m n))",
                    "c8_m : Int.int",
                    "c9_goal : vagree match v with\n       | Vint n1 => Vint (Int.shru n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end All",
                    "c9_H : vagree v w (I (Int.shl Int.mone n))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c7_goal : vagree match v with\n       | Vint n1 => Vint (Int.shru n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end Nothing"
                ],
                "tactic_res": [
                    "c10_goal : True",
                    "c10_H : True"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c8_goal : vagree match v with\n       | Vint n1 => Vint (Int.shru n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end (I m)"
                ],
                "tactic_res": [
                    "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c11_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.shl m n)\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c9_goal : vagree match v with\n       | Vint n1 => Vint (Int.shru n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end All"
                ],
                "tactic_res": [
                    "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end",
                    "c12_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.shl Int.mone n)\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                    "c13_H : iagree i i0 (Int.shl m n)",
                    "c13_i0 : Int.int",
                    "c13_i : Int.int"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                    "_global_1 : Z",
                    "_global_iagree_shru : forall (x y m n : Int.int) (_ : iagree x y (Int.shl m n)),\n       iagree (Int.shru x n) (Int.shru y n) m"
                ],
                "tactic_res": [
                    "c14_goal : iagree i i0 (Int.shl m n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : iagree i i0 (Int.shl m n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                    "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                    "c15_H : iagree i i0 (Int.shl Int.mone n)",
                    "c15_i0 : Int.int",
                    "c15_i : Int.int"
                ]
            },
            {
                "tactic_sig": "apply Val.lessdef_same .",
                "tactic_sig_no_out_arg": "apply Val.lessdef_same .",
                "tactic_args": [
                    "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c16_goal : eq (Vint (Int.shru i n)) (Vint (Int.shru i0 n))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c16_goal : eq (Vint (Int.shru i n)) (Vint (Int.shru i0 n))"
                ],
                "tactic_res": [
                    "c17_goal : eq (Int.shru i n) (Int.shru i0 n)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c17_goal : eq (Int.shru i n) (Int.shru i0 n)",
                    "_global_1 : Z",
                    "_global_iagree_mone : forall (p q : Int.int) (_ : iagree p q Int.mone), eq p q"
                ],
                "tactic_res": [
                    "c18_goal : iagree (Int.shru i n) (Int.shru i0 n) Int.mone"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c18_goal : iagree (Int.shru i n) (Int.shru i0 n) Int.mone",
                    "_global_1 : Z",
                    "_global_iagree_shru : forall (x y m n : Int.int) (_ : iagree x y (Int.shl m n)),\n       iagree (Int.shru x n) (Int.shru y n) m"
                ],
                "tactic_res": [
                    "c19_goal : iagree i i0 (Int.shl Int.mone n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : iagree i i0 (Int.shl Int.mone n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c6_goal : vagree match v with\n       | Vundef | _ => Vundef\n       end match w with\n           | Vundef | _ => Vundef\n           end x",
                    "c3_v : val"
                ],
                "tactic_res": [
                    "c20_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x",
                    "c20_H : vagree Vundef w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shl m n)\n  | All => I (Int.shl Int.mone n)\n  end",
                    "c21_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x",
                    "c21_H : vagree (Vint i) w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shl m n)\n  | All => I (Int.shl Int.mone n)\n  end",
                    "c21_i : Int.int",
                    "c22_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x",
                    "c22_H : vagree (Vlong i) w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shl m n)\n  | All => I (Int.shl Int.mone n)\n  end",
                    "c22_i : Int64.int",
                    "c23_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x",
                    "c23_H : vagree (Vfloat f) w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shl m n)\n  | All => I (Int.shl Int.mone n)\n  end",
                    "c23_f : float",
                    "c24_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x",
                    "c24_H : vagree (Vsingle f) w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shl m n)\n  | All => I (Int.shl Int.mone n)\n  end",
                    "c24_f : float32",
                    "c25_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x",
                    "c25_H : vagree (Vptr b i) w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shl m n)\n  | All => I (Int.shl Int.mone n)\n  end",
                    "c25_i : Ptrofs.int",
                    "c25_b : block"
                ]
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c20_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c21_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c22_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c23_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c24_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c25_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "shrimm_sound",
        "proof": [
            {
                "tactic_sig": "Lemma shrimm_sound : forall v w x n , vagree v w ( shrimm x n ) -> vagree ( Val.shr v ( Vint n ) ) ( Val.shr w ( Vint n ) ) x .",
                "tactic_sig_no_out_arg": "Lemma shrimm_sound : forall v w x n , vagree v w ( shrimm x n ) -> vagree ( Val.shr v ( Vint n ) ) ( Val.shr w ( Vint n ) ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (shrimm x n)),\nvagree (Val.shr v (Vint n)) (Val.shr w (Vint n)) x"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (shrimm x n)),\nvagree (Val.shr v (Vint n)) (Val.shr w (Vint n)) x",
                    "_global_1 : Z",
                    "_global_shrimm : forall (_ : nval) (_ : Int.int), nval"
                ],
                "tactic_res": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w\n         match x with\n         | Nothing => Nothing\n         | I m =>\n             I\n               (if Int.eq_dec (Int.shru (Int.shl m n) n) m\n                then Int.shl m n\n                else Int.or (Int.shl m n) (Int.repr Int.min_signed))\n         | All =>\n             I (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))\n         end), vagree (Val.shr v (Vint n)) (Val.shr w (Vint n)) x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w\n         match x with\n         | Nothing => Nothing\n         | I m =>\n             I\n               (if Int.eq_dec (Int.shru (Int.shl m n) n) m\n                then Int.shl m n\n                else Int.or (Int.shl m n) (Int.repr Int.min_signed))\n         | All =>\n             I (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))\n         end), vagree (Val.shr v (Vint n)) (Val.shr w (Vint n)) x"
                ],
                "tactic_res": [
                    "c3_goal : vagree (Val.shr v (Vint n)) (Val.shr w (Vint n)) x",
                    "c3_v : val",
                    "c3_w : val",
                    "c3_x : nval",
                    "c3_n : Int.int",
                    "c3_H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m =>\n      I\n        (if Int.eq_dec (Int.shru (Int.shl m n) n) m\n         then Int.shl m n\n         else Int.or (Int.shl m n) (Int.repr Int.min_signed))\n  | All => I (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))\n  end"
                ]
            },
            {
                "tactic_sig": "unfold Val._i .",
                "tactic_sig_no_out_arg": "unfold Val._i .",
                "tactic_args": [
                    "c3_goal : vagree (Val.shr v (Vint n)) (Val.shr w (Vint n)) x",
                    "_global_1 : Z",
                    "_global_shr : forall (_ : aval) (_ : aval), aval"
                ],
                "tactic_res": [
                    "c4_goal : vagree\n  match v with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shr n1 n) else Vundef\n  | _ => Vundef\n  end\n  match w with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shr n1 n) else Vundef\n  | _ => Vundef\n  end x"
                ]
            },
            {
                "tactic_sig": "destruct ( Int.ltu _i Int.iwordsize ) as [  | ] .",
                "tactic_sig_no_out_arg": "destruct ( Int.ltu _i Int.iwordsize ) .",
                "tactic_args": [
                    "c4_goal : vagree\n  match v with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shr n1 n) else Vundef\n  | _ => Vundef\n  end\n  match w with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shr n1 n) else Vundef\n  | _ => Vundef\n  end x",
                    "c3_n : Int.int"
                ],
                "tactic_res": [
                    "c5_goal : vagree match v with\n       | Vint n1 => Vint (Int.shr n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shr n1 n)\n  | _ => Vundef\n  end x",
                    "c6_goal : vagree match v with\n       | Vundef | _ => Vundef\n       end match w with\n           | Vundef | _ => Vundef\n           end x"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c5_goal : vagree match v with\n       | Vint n1 => Vint (Int.shr n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shr n1 n)\n  | _ => Vundef\n  end x",
                    "c3_x : nval"
                ],
                "tactic_res": [
                    "c7_goal : vagree match v with\n       | Vint n1 => Vint (Int.shr n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shr n1 n)\n  | _ => Vundef\n  end Nothing",
                    "c7_H : vagree v w Nothing",
                    "c8_goal : vagree match v with\n       | Vint n1 => Vint (Int.shr n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shr n1 n)\n  | _ => Vundef\n  end (I m)",
                    "c8_H : vagree v w\n  (I\n     (if Int.eq_dec (Int.shru (Int.shl m n) n) m\n      then Int.shl m n\n      else Int.or (Int.shl m n) (Int.repr Int.min_signed)))",
                    "c8_m : Int.int",
                    "c9_goal : vagree match v with\n       | Vint n1 => Vint (Int.shr n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shr n1 n)\n  | _ => Vundef\n  end All",
                    "c9_H : vagree v w (I (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed)))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c7_goal : vagree match v with\n       | Vint n1 => Vint (Int.shr n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shr n1 n)\n  | _ => Vundef\n  end Nothing"
                ],
                "tactic_res": [
                    "c10_goal : True",
                    "c10_H : True"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c8_goal : vagree match v with\n       | Vint n1 => Vint (Int.shr n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shr n1 n)\n  | _ => Vundef\n  end (I m)"
                ],
                "tactic_res": [
                    "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shr n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shr n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c11_H : match v with\n| Vint p =>\n    match w with\n    | Vint q =>\n        iagree p q\n          (if Int.eq_dec (Int.shru (Int.shl m n) n) m\n           then Int.shl m n\n           else Int.or (Int.shl m n) (Int.repr Int.min_signed))\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c9_goal : vagree match v with\n       | Vint n1 => Vint (Int.shr n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.shr n1 n)\n  | _ => Vundef\n  end All"
                ],
                "tactic_res": [
                    "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shr n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shr n1 n)\n      | _ => Vundef\n      end",
                    "c12_H : match v with\n| Vint p =>\n    match w with\n    | Vint q =>\n        iagree p q\n          (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shr n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shr n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c13_goal : iagree (Int.shr i n) (Int.shr i0 n) m",
                    "c13_H : iagree i i0\n  (if Int.eq_dec (Int.shru (Int.shl m n) n) m\n   then Int.shl m n\n   else Int.or (Int.shl m n) (Int.repr Int.min_signed))",
                    "c13_i0 : Int.int",
                    "c13_i : Int.int"
                ]
            },
            {
                "tactic_sig": "destruct ( Int.eq_dec ( Int.shru ( Int.shl _i _i ) _i ) _i ) as [  _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Int.eq_dec ( Int.shru ( Int.shl _i _i ) _i ) _i ) .",
                "tactic_args": [
                    "c13_goal : iagree (Int.shr i n) (Int.shr i0 n) m",
                    "c8_m : Int.int",
                    "c3_n : Int.int",
                    "c3_n : Int.int",
                    "c8_m : Int.int"
                ],
                "tactic_res": [
                    "c14_goal : iagree (Int.shr i n) (Int.shr i0 n) m",
                    "c14_H : iagree i i0 (Int.shl m n)",
                    "c14_e : eq (Int.shru (Int.shl m n) n) m",
                    "c15_goal : iagree (Int.shr i n) (Int.shr i0 n) m",
                    "c15_H : iagree i i0 (Int.or (Int.shl m n) (Int.repr Int.min_signed))",
                    "c15_n0 : not (eq (Int.shru (Int.shl m n) n) m)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : iagree (Int.shr i n) (Int.shr i0 n) m",
                    "_global_1 : Z",
                    "_global_iagree_shr_1 : forall (x y m n : Int.int) (_ : eq (Int.shru (Int.shl m n) n) m)\n         (_ : iagree x y (Int.shl m n)), iagree (Int.shr x n) (Int.shr y n) m"
                ],
                "tactic_res": [
                    "c16_goal : eq (Int.shru (Int.shl m n) n) m",
                    "c17_goal : iagree i i0 (Int.shl m n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : eq (Int.shru (Int.shl m n) n) m"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : iagree i i0 (Int.shl m n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : iagree (Int.shr i n) (Int.shr i0 n) m",
                    "_global_1 : Z",
                    "_global_iagree_shr : forall (x y m n : Int.int)\n         (_ : iagree x y (Int.or (Int.shl m n) (Int.repr Int.min_signed))),\n       iagree (Int.shr x n) (Int.shr y n) m"
                ],
                "tactic_res": [
                    "c18_goal : iagree i i0 (Int.or (Int.shl m n) (Int.repr Int.min_signed))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : iagree i i0 (Int.or (Int.shl m n) (Int.repr Int.min_signed))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shr n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shr n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                    "c19_goal : Val.lessdef (Vint (Int.shr i n)) (Vint (Int.shr i0 n))",
                    "c19_H : iagree i i0 (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))",
                    "c19_i0 : Int.int",
                    "c19_i : Int.int"
                ]
            },
            {
                "tactic_sig": "apply Val.lessdef_same .",
                "tactic_sig_no_out_arg": "apply Val.lessdef_same .",
                "tactic_args": [
                    "c19_goal : Val.lessdef (Vint (Int.shr i n)) (Vint (Int.shr i0 n))",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c20_goal : eq (Vint (Int.shr i n)) (Vint (Int.shr i0 n))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c20_goal : eq (Vint (Int.shr i n)) (Vint (Int.shr i0 n))"
                ],
                "tactic_res": [
                    "c21_goal : eq (Int.shr i n) (Int.shr i0 n)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c21_goal : eq (Int.shr i n) (Int.shr i0 n)",
                    "_global_1 : Z",
                    "_global_iagree_mone : forall (p q : Int.int) (_ : iagree p q Int.mone), eq p q"
                ],
                "tactic_res": [
                    "c22_goal : iagree (Int.shr i n) (Int.shr i0 n) Int.mone"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c22_goal : iagree (Int.shr i n) (Int.shr i0 n) Int.mone",
                    "_global_1 : Z",
                    "_global_iagree_shr : forall (x y m n : Int.int)\n         (_ : iagree x y (Int.or (Int.shl m n) (Int.repr Int.min_signed))),\n       iagree (Int.shr x n) (Int.shr y n) m"
                ],
                "tactic_res": [
                    "c23_goal : iagree i i0 (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : iagree i i0 (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c6_goal : vagree match v with\n       | Vundef | _ => Vundef\n       end match w with\n           | Vundef | _ => Vundef\n           end x",
                    "c3_v : val"
                ],
                "tactic_res": [
                    "c24_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x",
                    "c24_H : vagree Vundef w\n  match x with\n  | Nothing => Nothing\n  | I m =>\n      I\n        (if Int.eq_dec (Int.shru (Int.shl m n) n) m\n         then Int.shl m n\n         else Int.or (Int.shl m n) (Int.repr Int.min_signed))\n  | All => I (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))\n  end",
                    "c25_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x",
                    "c25_H : vagree (Vint i) w\n  match x with\n  | Nothing => Nothing\n  | I m =>\n      I\n        (if Int.eq_dec (Int.shru (Int.shl m n) n) m\n         then Int.shl m n\n         else Int.or (Int.shl m n) (Int.repr Int.min_signed))\n  | All => I (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))\n  end",
                    "c25_i : Int.int",
                    "c26_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x",
                    "c26_H : vagree (Vlong i) w\n  match x with\n  | Nothing => Nothing\n  | I m =>\n      I\n        (if Int.eq_dec (Int.shru (Int.shl m n) n) m\n         then Int.shl m n\n         else Int.or (Int.shl m n) (Int.repr Int.min_signed))\n  | All => I (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))\n  end",
                    "c26_i : Int64.int",
                    "c27_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x",
                    "c27_H : vagree (Vfloat f) w\n  match x with\n  | Nothing => Nothing\n  | I m =>\n      I\n        (if Int.eq_dec (Int.shru (Int.shl m n) n) m\n         then Int.shl m n\n         else Int.or (Int.shl m n) (Int.repr Int.min_signed))\n  | All => I (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))\n  end",
                    "c27_f : float",
                    "c28_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x",
                    "c28_H : vagree (Vsingle f) w\n  match x with\n  | Nothing => Nothing\n  | I m =>\n      I\n        (if Int.eq_dec (Int.shru (Int.shl m n) n) m\n         then Int.shl m n\n         else Int.or (Int.shl m n) (Int.repr Int.min_signed))\n  | All => I (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))\n  end",
                    "c28_f : float32",
                    "c29_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x",
                    "c29_H : vagree (Vptr b i) w\n  match x with\n  | Nothing => Nothing\n  | I m =>\n      I\n        (if Int.eq_dec (Int.shru (Int.shl m n) n) m\n         then Int.shl m n\n         else Int.or (Int.shl m n) (Int.repr Int.min_signed))\n  | All => I (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))\n  end",
                    "c29_i : Ptrofs.int",
                    "c29_b : block"
                ]
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c24_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c25_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c26_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c27_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c28_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c29_goal : vagree Vundef match w with\n              | Vundef | _ => Vundef\n              end x"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "rol_sound",
        "proof": [
            {
                "tactic_sig": "Lemma rol_sound : forall v w x n , vagree v w ( rol x n ) -> vagree ( Val.rol v ( Vint n ) ) ( Val.rol w ( Vint n ) ) x .",
                "tactic_sig_no_out_arg": "Lemma rol_sound : forall v w x n , vagree v w ( rol x n ) -> vagree ( Val.rol v ( Vint n ) ) ( Val.rol w ( Vint n ) ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Int.int) (_ : vagree v w (rol x n)),\nvagree (Val.rol v (Vint n)) (Val.rol w (Vint n)) x"
                ]
            },
            {
                "tactic_sig": "unfold _i , Val._i .",
                "tactic_sig_no_out_arg": "unfold _i , Val._i .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Int.int) (_ : vagree v w (rol x n)),\nvagree (Val.rol v (Vint n)) (Val.rol w (Vint n)) x",
                    "_global_1 : Z",
                    "_global_rol : forall (_ : nval) (_ : Int.int), nval",
                    "_global_rol : forall (_ : nval) (_ : Int.int), nval"
                ],
                "tactic_res": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w\n         match x with\n         | Nothing => Nothing\n         | I m => I (Int.ror m n)\n         | All => All\n         end),\nvagree match v with\n       | Vint n1 => Vint (Int.rol n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w\n         match x with\n         | Nothing => Nothing\n         | I m => I (Int.ror m n)\n         | All => All\n         end),\nvagree match v with\n       | Vint n1 => Vint (Int.rol n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end x"
                ],
                "tactic_res": [
                    "c3_goal : vagree match v with\n       | Vint n1 => Vint (Int.rol n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end x",
                    "c3_v : val",
                    "c3_w : val",
                    "c3_x : nval",
                    "c3_n : Int.int",
                    "c3_H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.ror m n)\n  | All => All\n  end"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : vagree match v with\n       | Vint n1 => Vint (Int.rol n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end x",
                    "c3_x : nval"
                ],
                "tactic_res": [
                    "c4_goal : vagree match v with\n       | Vint n1 => Vint (Int.rol n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end Nothing",
                    "c4_H : vagree v w Nothing",
                    "c5_goal : vagree match v with\n       | Vint n1 => Vint (Int.rol n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end (I m)",
                    "c5_H : vagree v w (I (Int.ror m n))",
                    "c5_m : Int.int",
                    "c6_goal : vagree match v with\n       | Vint n1 => Vint (Int.rol n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end All",
                    "c6_H : vagree v w All"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c4_goal : vagree match v with\n       | Vint n1 => Vint (Int.rol n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end Nothing"
                ],
                "tactic_res": [
                    "c7_goal : True",
                    "c7_H : True"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c5_goal : vagree match v with\n       | Vint n1 => Vint (Int.rol n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end (I m)"
                ],
                "tactic_res": [
                    "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c8_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.ror m n)\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c6_goal : vagree match v with\n       | Vint n1 => Vint (Int.rol n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end All"
                ],
                "tactic_res": [
                    "c9_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end",
                    "c9_H : Val.lessdef v w"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                    "c10_H : iagree i i0 (Int.ror m n)",
                    "c10_i0 : Int.int",
                    "c10_i : Int.int"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                    "_global_1 : Z",
                    "_global_iagree_rol : forall (p q m amount : Int.int) (_ : iagree p q (Int.ror m amount)),\n       iagree (Int.rol p amount) (Int.rol q amount) m"
                ],
                "tactic_res": [
                    "c11_goal : iagree i i0 (Int.ror m n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : iagree i i0 (Int.ror m n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c9_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end",
                    "c3_H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.ror m n)\n  | All => All\n  end"
                ],
                "tactic_res": [
                    "c12_goal : Val.lessdef\n  match w with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end",
                    "c13_goal : Val.lessdef Vundef\n  match w with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : Val.lessdef\n  match w with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : Val.lessdef Vundef\n  match w with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "ror_sound",
        "proof": [
            {
                "tactic_sig": "Lemma ror_sound : forall v w x n , vagree v w ( ror x n ) -> vagree ( Val.ror v ( Vint n ) ) ( Val.ror w ( Vint n ) ) x .",
                "tactic_sig_no_out_arg": "Lemma ror_sound : forall v w x n , vagree v w ( ror x n ) -> vagree ( Val.ror v ( Vint n ) ) ( Val.ror w ( Vint n ) ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Int.int) (_ : vagree v w (ror x n)),\nvagree (Val.ror v (Vint n)) (Val.ror w (Vint n)) x"
                ]
            },
            {
                "tactic_sig": "unfold _i , Val._i .",
                "tactic_sig_no_out_arg": "unfold _i , Val._i .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Int.int) (_ : vagree v w (ror x n)),\nvagree (Val.ror v (Vint n)) (Val.ror w (Vint n)) x",
                    "_global_1 : Z",
                    "_global_ror : forall (_ : nval) (_ : Int.int), nval",
                    "_global_ror : forall (_ : nval) (_ : Int.int), nval"
                ],
                "tactic_res": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w\n         match x with\n         | Nothing => Nothing\n         | I m => I (Int.rol m n)\n         | All => All\n         end),\nvagree match v with\n       | Vint n1 => Vint (Int.ror n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w\n         match x with\n         | Nothing => Nothing\n         | I m => I (Int.rol m n)\n         | All => All\n         end),\nvagree match v with\n       | Vint n1 => Vint (Int.ror n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end x"
                ],
                "tactic_res": [
                    "c3_goal : vagree match v with\n       | Vint n1 => Vint (Int.ror n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end x",
                    "c3_v : val",
                    "c3_w : val",
                    "c3_x : nval",
                    "c3_n : Int.int",
                    "c3_H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.rol m n)\n  | All => All\n  end"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : vagree match v with\n       | Vint n1 => Vint (Int.ror n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end x",
                    "c3_x : nval"
                ],
                "tactic_res": [
                    "c4_goal : vagree match v with\n       | Vint n1 => Vint (Int.ror n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end Nothing",
                    "c4_H : vagree v w Nothing",
                    "c5_goal : vagree match v with\n       | Vint n1 => Vint (Int.ror n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end (I m)",
                    "c5_H : vagree v w (I (Int.rol m n))",
                    "c5_m : Int.int",
                    "c6_goal : vagree match v with\n       | Vint n1 => Vint (Int.ror n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end All",
                    "c6_H : vagree v w All"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c4_goal : vagree match v with\n       | Vint n1 => Vint (Int.ror n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end Nothing"
                ],
                "tactic_res": [
                    "c7_goal : True",
                    "c7_H : True"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c5_goal : vagree match v with\n       | Vint n1 => Vint (Int.ror n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end (I m)"
                ],
                "tactic_res": [
                    "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c8_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.rol m n)\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c6_goal : vagree match v with\n       | Vint n1 => Vint (Int.ror n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end All"
                ],
                "tactic_res": [
                    "c9_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end",
                    "c9_H : Val.lessdef v w"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                    "c10_H : iagree i i0 (Int.rol m n)",
                    "c10_i0 : Int.int",
                    "c10_i : Int.int"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                    "_global_1 : Z",
                    "_global_iagree_ror : forall (p q m amount : Int.int) (_ : iagree p q (Int.rol m amount)),\n       iagree (Int.ror p amount) (Int.ror q amount) m"
                ],
                "tactic_res": [
                    "c11_goal : iagree i i0 (Int.rol m n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : iagree i i0 (Int.rol m n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c9_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end",
                    "c3_H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.rol m n)\n  | All => All\n  end"
                ],
                "tactic_res": [
                    "c12_goal : Val.lessdef\n  match w with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end",
                    "c13_goal : Val.lessdef Vundef\n  match w with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : Val.lessdef\n  match w with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : Val.lessdef Vundef\n  match w with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "rolm_sound",
        "proof": [
            {
                "tactic_sig": "Lemma rolm_sound : forall v w x amount mask , vagree v w ( rolm x amount mask ) -> vagree ( Val.rolm v amount mask ) ( Val.rolm w amount mask ) x .",
                "tactic_sig_no_out_arg": "Lemma rolm_sound : forall v w x amount mask , vagree v w ( rolm x amount mask ) -> vagree ( Val.rolm v amount mask ) ( Val.rolm w amount mask ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                    "_global_1 : Z",
                    "_global_rolm : forall (_ : nval) (_ : Int.int) (_ : Int.int), nval"
                ],
                "tactic_res": [
                    "c2_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rol (andimm x mask) amount)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rol (andimm x mask) amount)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                    "c3_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                    "c3_v : val",
                    "c3_w : val",
                    "c3_x : nval",
                    "c3_amount : Int.int",
                    "c3_mask : Int.int",
                    "c3_H : vagree v w (rol (andimm x mask) amount)"
                ]
            },
            {
                "tactic_sig": "assert ( X : forall u , Val.rolm u _i _i = Val.and ( Val.rol u ( Vint _i ) ) ( Vint _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( X : forall u , Val.rolm u _i _i = Val.and ( Val.rol u ( Vint _i ) ) ( Vint _i ) ) .",
                "tactic_args": [
                    "c3_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                    "c3_amount : Int.int",
                    "c3_mask : Int.int",
                    "c3_amount : Int.int",
                    "c3_mask : Int.int"
                ],
                "tactic_res": [
                    "c4_goal : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))",
                    "c5_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                    "c5_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ]
            },
            {
                "tactic_sig": "destruct u as [  | _o | _o | _o | _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct u .",
                "tactic_args": [
                    "c4_goal : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": [
                    "c6_goal : eq (Val.rolm Vundef amount mask)\n  (Val.and (Val.rol Vundef (Vint amount)) (Vint mask))",
                    "c7_goal : eq (Val.rolm (Vint i) amount mask)\n  (Val.and (Val.rol (Vint i) (Vint amount)) (Vint mask))",
                    "c7_i : Int.int",
                    "c8_goal : eq (Val.rolm (Vlong i) amount mask)\n  (Val.and (Val.rol (Vlong i) (Vint amount)) (Vint mask))",
                    "c8_i : Int64.int",
                    "c9_goal : eq (Val.rolm (Vfloat f) amount mask)\n  (Val.and (Val.rol (Vfloat f) (Vint amount)) (Vint mask))",
                    "c9_f : float",
                    "c10_goal : eq (Val.rolm (Vsingle f) amount mask)\n  (Val.and (Val.rol (Vsingle f) (Vint amount)) (Vint mask))",
                    "c10_f : float32",
                    "c11_goal : eq (Val.rolm (Vptr b i) amount mask)\n  (Val.and (Val.rol (Vptr b i) (Vint amount)) (Vint mask))",
                    "c11_i : Ptrofs.int",
                    "c11_b : block"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : eq (Val.rolm Vundef amount mask)\n  (Val.and (Val.rol Vundef (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : eq (Val.rolm (Vint i) amount mask)\n  (Val.and (Val.rol (Vint i) (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : eq (Val.rolm (Vlong i) amount mask)\n  (Val.and (Val.rol (Vlong i) (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : eq (Val.rolm (Vfloat f) amount mask)\n  (Val.and (Val.rol (Vfloat f) (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : eq (Val.rolm (Vsingle f) amount mask)\n  (Val.and (Val.rol (Vsingle f) (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : eq (Val.rolm (Vptr b i) amount mask)\n  (Val.and (Val.rol (Vptr b i) (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ! _i .",
                "tactic_sig_no_out_arg": "rewrite ! _i .",
                "tactic_args": [
                    "c5_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                    "_global_1 : Z",
                    "c5_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": [
                    "c12_goal : vagree (Val.and (Val.rol v (Vint amount)) (Vint mask))\n  (Val.and (Val.rol w (Vint amount)) (Vint mask)) x"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : vagree (Val.and (Val.rol v (Vint amount)) (Vint mask))\n  (Val.and (Val.rol w (Vint amount)) (Vint mask)) x",
                    "_global_1 : Z",
                    "_global_andimm_sound : forall (v w : val) (x : nval) (n : Int.int)\n         (_ : vagree v w (andimm x n)),\n       vagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                    "c13_goal : vagree (Val.rol v (Vint amount)) (Val.rol w (Vint amount))\n  (andimm x mask)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : vagree (Val.rol v (Vint amount)) (Val.rol w (Vint amount))\n  (andimm x mask)",
                    "_global_1 : Z",
                    "_global_rol_sound : forall (v w : val) (x : nval) (n : Int.int) (_ : vagree v w (rol x n)),\n       vagree (Val.rol v (Vint n)) (Val.rol w (Vint n)) x"
                ],
                "tactic_res": [
                    "c14_goal : vagree v w (rol (andimm x mask) amount)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : vagree v w (rol (andimm x mask) amount)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "add_sound",
        "proof": [
            {
                "tactic_sig": "Lemma add_sound : forall v1 w1 v2 w2 x , vagree v1 w1 ( modarith x ) -> vagree v2 w2 ( modarith x ) -> vagree ( Val.add v1 v2 ) ( Val.add w1 w2 ) x .",
                "tactic_sig_no_out_arg": "Lemma add_sound : forall v1 w1 v2 w2 x , vagree v1 w1 ( modarith x ) -> vagree v2 w2 ( modarith x ) -> vagree ( Val.add v1 v2 ) ( Val.add w1 w2 ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)),\nvagree (Val.add v1 v2) (Val.add w1 w2) x"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)),\nvagree (Val.add v1 v2) (Val.add w1 w2) x",
                    "_global_1 : Z",
                    "_global_modarith : forall _ : nval, nval"
                ],
                "tactic_res": [
                    "c2_goal : forall (v1 w1 v2 w2 : val) (x : nval)\n  (_ : vagree v1 w1\n         match x with\n         | Nothing => Nothing\n         | I m => I (complete_mask m)\n         | All => All\n         end)\n  (_ : vagree v2 w2\n         match x with\n         | Nothing => Nothing\n         | I m => I (complete_mask m)\n         | All => All\n         end), vagree (Val.add v1 v2) (Val.add w1 w2) x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (v1 w1 v2 w2 : val) (x : nval)\n  (_ : vagree v1 w1\n         match x with\n         | Nothing => Nothing\n         | I m => I (complete_mask m)\n         | All => All\n         end)\n  (_ : vagree v2 w2\n         match x with\n         | Nothing => Nothing\n         | I m => I (complete_mask m)\n         | All => All\n         end), vagree (Val.add v1 v2) (Val.add w1 w2) x"
                ],
                "tactic_res": [
                    "c3_goal : vagree (Val.add v1 v2) (Val.add w1 w2) x",
                    "c3_v1 : val",
                    "c3_w1 : val",
                    "c3_v2 : val",
                    "c3_w2 : val",
                    "c3_x : nval",
                    "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                    "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o | _o _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : vagree (Val.add v1 v2) (Val.add w1 w2) x",
                    "c3_x : nval"
                ],
                "tactic_res": [
                    "c4_goal : vagree (Val.add v1 v2) (Val.add w1 w2) Nothing",
                    "c4_H0 : vagree v2 w2 Nothing",
                    "c4_H : vagree v1 w1 Nothing",
                    "c5_goal : vagree (Val.add v1 v2) (Val.add w1 w2) (I m)",
                    "c5_H0 : vagree v2 w2 (I (complete_mask m))",
                    "c5_H : vagree v1 w1 (I (complete_mask m))",
                    "c5_m : Int.int",
                    "c6_goal : vagree (Val.add v1 v2) (Val.add w1 w2) All",
                    "c6_H0 : vagree v2 w2 All",
                    "c6_H : vagree v1 w1 All"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c4_goal : vagree (Val.add v1 v2) (Val.add w1 w2) Nothing"
                ],
                "tactic_res": [
                    "c7_goal : True",
                    "c7_H0 : True",
                    "c7_H : True"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c5_goal : vagree (Val.add v1 v2) (Val.add w1 w2) (I m)"
                ],
                "tactic_res": [
                    "c8_goal : match Val.add v1 v2 with\n| Vint p =>\n    match Val.add w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c8_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                    "c8_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c6_goal : vagree (Val.add v1 v2) (Val.add w1 w2) All"
                ],
                "tactic_res": [
                    "c9_goal : Val.lessdef (Val.add v1 v2) (Val.add w1 w2)",
                    "c9_H0 : Val.lessdef v2 w2",
                    "c9_H : Val.lessdef v1 w1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold Val._i .",
                "tactic_sig_no_out_arg": "unfold Val._i .",
                "tactic_args": [
                    "c8_goal : match Val.add v1 v2 with\n| Vint p =>\n    match Val.add w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "_global_1 : Z",
                    "_global_add : forall (_ : aval) (_ : aval), aval"
                ],
                "tactic_res": [
                    "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                    "c11_H0 : iagree i i0 (complete_mask m)",
                    "c11_H : iagree i1 i2 (complete_mask m)",
                    "c11_i0 : Int.int",
                    "c11_i : Int.int",
                    "c11_i2 : Int.int",
                    "c11_i1 : Int.int"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                    "_global_1 : Z",
                    "_global_eqmod_iagree : forall (m : Int.int) (x y : Z) (_ : eqmod (two_p (Int.size m)) x y),\n       iagree (Int.repr x) (Int.repr y) m"
                ],
                "tactic_res": [
                    "c12_goal : eqmod (two_p (Int.size m)) (Z.add (Int.unsigned i1) (Int.unsigned i))\n  (Z.add (Int.unsigned i2) (Int.unsigned i0))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : eqmod (two_p (Int.size m)) (Z.add (Int.unsigned i1) (Int.unsigned i))\n  (Z.add (Int.unsigned i2) (Int.unsigned i0))",
                    "_global_1 : Z",
                    "_global_eqmod_add : forall (modul a b c d : Z) (_ : eqmod modul a b) (_ : eqmod modul c d),\n       eqmod modul (Z.add a c) (Z.add b d)"
                ],
                "tactic_res": [
                    "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)",
                    "c14_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)",
                    "_global_1 : Z",
                    "_global_iagree_eqmod : forall (x y m : Int.int) (_ : iagree x y (complete_mask m)),\n       eqmod (two_p (Int.size m)) (Int.unsigned x) (Int.unsigned y)"
                ],
                "tactic_res": [
                    "c15_goal : iagree i1 i2 (complete_mask m)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : iagree i1 i2 (complete_mask m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                    "_global_1 : Z",
                    "_global_iagree_eqmod : forall (x y m : Int.int) (_ : iagree x y (complete_mask m)),\n       eqmod (two_p (Int.size m)) (Int.unsigned x) (Int.unsigned y)"
                ],
                "tactic_res": [
                    "c16_goal : iagree i i0 (complete_mask m)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : iagree i i0 (complete_mask m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c9_goal : Val.lessdef (Val.add v1 v2) (Val.add w1 w2)",
                    "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end"
                ],
                "tactic_res": [
                    "c17_goal : Val.lessdef (Val.add w1 v2) (Val.add w1 w2)",
                    "c18_goal : Val.lessdef (Val.add Vundef v2) (Val.add w1 w2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : Val.lessdef (Val.add Vundef v2) (Val.add w1 w2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c17_goal : Val.lessdef (Val.add w1 v2) (Val.add w1 w2)",
                    "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end"
                ],
                "tactic_res": [
                    "c19_goal : Val.lessdef (Val.add w1 w2) (Val.add w1 w2)",
                    "c20_goal : Val.lessdef (Val.add w1 Vundef) (Val.add w1 w2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : Val.lessdef (Val.add w1 w2) (Val.add w1 w2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  | _o | _o | _o | _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c20_goal : Val.lessdef (Val.add w1 Vundef) (Val.add w1 w2)",
                    "c3_w1 : val"
                ],
                "tactic_res": [
                    "c21_goal : Val.lessdef (Val.add Vundef Vundef) (Val.add Vundef w2)",
                    "c22_goal : Val.lessdef (Val.add (Vint i) Vundef) (Val.add (Vint i) w2)",
                    "c22_i : Int.int",
                    "c23_goal : Val.lessdef (Val.add (Vlong i) Vundef) (Val.add (Vlong i) w2)",
                    "c23_i : Int64.int",
                    "c24_goal : Val.lessdef (Val.add (Vfloat f) Vundef) (Val.add (Vfloat f) w2)",
                    "c24_f : float",
                    "c25_goal : Val.lessdef (Val.add (Vsingle f) Vundef) (Val.add (Vsingle f) w2)",
                    "c25_f : float32",
                    "c26_goal : Val.lessdef (Val.add (Vptr b i) Vundef) (Val.add (Vptr b i) w2)",
                    "c26_i : Ptrofs.int",
                    "c26_b : block"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : Val.lessdef (Val.add Vundef Vundef) (Val.add Vundef w2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c22_goal : Val.lessdef (Val.add (Vint i) Vundef) (Val.add (Vint i) w2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : Val.lessdef (Val.add (Vlong i) Vundef) (Val.add (Vlong i) w2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : Val.lessdef (Val.add (Vfloat f) Vundef) (Val.add (Vfloat f) w2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : Val.lessdef (Val.add (Vsingle f) Vundef) (Val.add (Vsingle f) w2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c26_goal : Val.lessdef (Val.add (Vptr b i) Vundef) (Val.add (Vptr b i) w2)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sub_sound",
        "proof": [
            {
                "tactic_sig": "Lemma sub_sound : forall v1 w1 v2 w2 x , vagree v1 w1 ( modarith x ) -> vagree v2 w2 ( modarith x ) -> Archi.ptr64 = true -> vagree ( Val.sub v1 v2 ) ( Val.sub w1 w2 ) x .",
                "tactic_sig_no_out_arg": "Lemma sub_sound : forall v1 w1 v2 w2 x , vagree v1 w1 ( modarith x ) -> vagree v2 w2 ( modarith x ) -> Archi.ptr64 = true -> vagree ( Val.sub v1 v2 ) ( Val.sub w1 w2 ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                    "_global_1 : Z",
                    "_global_modarith : forall _ : nval, nval"
                ],
                "tactic_res": [
                    "c2_goal : forall (v1 w1 v2 w2 : val) (x : nval)\n  (_ : vagree v1 w1\n         match x with\n         | Nothing => Nothing\n         | I m => I (complete_mask m)\n         | All => All\n         end)\n  (_ : vagree v2 w2\n         match x with\n         | Nothing => Nothing\n         | I m => I (complete_mask m)\n         | All => All\n         end) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (v1 w1 v2 w2 : val) (x : nval)\n  (_ : vagree v1 w1\n         match x with\n         | Nothing => Nothing\n         | I m => I (complete_mask m)\n         | All => All\n         end)\n  (_ : vagree v2 w2\n         match x with\n         | Nothing => Nothing\n         | I m => I (complete_mask m)\n         | All => All\n         end) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
                ],
                "tactic_res": [
                    "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                    "c3_v1 : val",
                    "c3_w1 : val",
                    "c3_v2 : val",
                    "c3_w2 : val",
                    "c3_x : nval",
                    "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                    "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                    "c3_H1 : eq Archi.ptr64 true"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o | _o _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                    "c3_x : nval"
                ],
                "tactic_res": [
                    "c4_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) Nothing",
                    "c4_H0 : vagree v2 w2 Nothing",
                    "c4_H : vagree v1 w1 Nothing",
                    "c5_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) (I m)",
                    "c5_H0 : vagree v2 w2 (I (complete_mask m))",
                    "c5_H : vagree v1 w1 (I (complete_mask m))",
                    "c5_m : Int.int",
                    "c6_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) All",
                    "c6_H0 : vagree v2 w2 All",
                    "c6_H : vagree v1 w1 All"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c4_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) Nothing"
                ],
                "tactic_res": [
                    "c7_goal : True",
                    "c7_H0 : True",
                    "c7_H : True"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c5_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) (I m)"
                ],
                "tactic_res": [
                    "c8_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c8_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                    "c8_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c6_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) All"
                ],
                "tactic_res": [
                    "c9_goal : Val.lessdef (Val.sub v1 v2) (Val.sub w1 w2)",
                    "c9_H0 : Val.lessdef v2 w2",
                    "c9_H : Val.lessdef v1 w1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold Val._i .",
                "tactic_sig_no_out_arg": "unfold Val._i .",
                "tactic_args": [
                    "c8_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "_global_1 : Z",
                    "_global_sub : forall (_ : aval) (_ : aval), aval"
                ],
                "tactic_res": [
                    "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int n2))\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else\n           if eq_block b1 b2\n           then Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs2))\n           else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int n2))\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else\n               if eq_block b1 b2\n               then Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs2))\n               else Vundef\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int n2))\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else\n           if eq_block b1 b2\n           then Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs2))\n           else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int n2))\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else\n               if eq_block b1 b2\n               then Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs2))\n               else Vundef\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "_global_1 : Z",
                    "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                    "c11_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c11_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c12_goal : iagree (Int.sub i1 i) (Int.sub i2 i0) m",
                    "c12_H0 : iagree i i0 (complete_mask m)",
                    "c12_H : iagree i1 i2 (complete_mask m)",
                    "c12_i0 : Int.int",
                    "c12_i : Int.int",
                    "c12_i2 : Int.int",
                    "c12_i1 : Int.int"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : iagree (Int.sub i1 i) (Int.sub i2 i0) m",
                    "_global_1 : Z",
                    "_global_eqmod_iagree : forall (m : Int.int) (x y : Z) (_ : eqmod (two_p (Int.size m)) x y),\n       iagree (Int.repr x) (Int.repr y) m"
                ],
                "tactic_res": [
                    "c13_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                    "_global_1 : Z",
                    "_global_eqmod_sub : forall (modul a b c d : Z) (_ : eqmod modul a b) (_ : eqmod modul c d),\n       eqmod modul (Z.sub a c) (Z.sub b d)"
                ],
                "tactic_res": [
                    "c14_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)",
                    "c15_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c14_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)",
                    "_global_1 : Z",
                    "_global_iagree_eqmod : forall (x y m : Int.int) (_ : iagree x y (complete_mask m)),\n       eqmod (two_p (Int.size m)) (Int.unsigned x) (Int.unsigned y)"
                ],
                "tactic_res": [
                    "c16_goal : iagree i1 i2 (complete_mask m)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : iagree i1 i2 (complete_mask m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                    "_global_1 : Z",
                    "_global_iagree_eqmod : forall (x y m : Int.int) (_ : iagree x y (complete_mask m)),\n       eqmod (two_p (Int.size m)) (Int.unsigned x) (Int.unsigned y)"
                ],
                "tactic_res": [
                    "c17_goal : iagree i i0 (complete_mask m)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : iagree i i0 (complete_mask m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c9_goal : Val.lessdef (Val.sub v1 v2) (Val.sub w1 w2)",
                    "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end"
                ],
                "tactic_res": [
                    "c18_goal : Val.lessdef (Val.sub w1 v2) (Val.sub w1 w2)",
                    "c19_goal : Val.lessdef (Val.sub Vundef v2) (Val.sub w1 w2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : Val.lessdef (Val.sub Vundef v2) (Val.sub w1 w2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c18_goal : Val.lessdef (Val.sub w1 v2) (Val.sub w1 w2)",
                    "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end"
                ],
                "tactic_res": [
                    "c20_goal : Val.lessdef (Val.sub w1 w2) (Val.sub w1 w2)",
                    "c21_goal : Val.lessdef (Val.sub w1 Vundef) (Val.sub w1 w2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c20_goal : Val.lessdef (Val.sub w1 w2) (Val.sub w1 w2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  | _o | _o | _o | _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c21_goal : Val.lessdef (Val.sub w1 Vundef) (Val.sub w1 w2)",
                    "c3_w1 : val"
                ],
                "tactic_res": [
                    "c22_goal : Val.lessdef (Val.sub Vundef Vundef) (Val.sub Vundef w2)",
                    "c23_goal : Val.lessdef (Val.sub (Vint i) Vundef) (Val.sub (Vint i) w2)",
                    "c23_i : Int.int",
                    "c24_goal : Val.lessdef (Val.sub (Vlong i) Vundef) (Val.sub (Vlong i) w2)",
                    "c24_i : Int64.int",
                    "c25_goal : Val.lessdef (Val.sub (Vfloat f) Vundef) (Val.sub (Vfloat f) w2)",
                    "c25_f : float",
                    "c26_goal : Val.lessdef (Val.sub (Vsingle f) Vundef) (Val.sub (Vsingle f) w2)",
                    "c26_f : float32",
                    "c27_goal : Val.lessdef (Val.sub (Vptr b i) Vundef) (Val.sub (Vptr b i) w2)",
                    "c27_i : Ptrofs.int",
                    "c27_b : block"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c22_goal : Val.lessdef (Val.sub Vundef Vundef) (Val.sub Vundef w2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : Val.lessdef (Val.sub (Vint i) Vundef) (Val.sub (Vint i) w2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : Val.lessdef (Val.sub (Vlong i) Vundef) (Val.sub (Vlong i) w2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : Val.lessdef (Val.sub (Vfloat f) Vundef) (Val.sub (Vfloat f) w2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c26_goal : Val.lessdef (Val.sub (Vsingle f) Vundef) (Val.sub (Vsingle f) w2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c27_goal : Val.lessdef (Val.sub (Vptr b i) Vundef) (Val.sub (Vptr b i) w2)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "modarith_idem",
        "proof": [
            {
                "tactic_sig": "Remark modarith_idem : forall nv , modarith ( modarith nv ) = modarith nv .",
                "tactic_sig_no_out_arg": "Remark modarith_idem : forall nv , modarith ( modarith nv ) = modarith nv .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall nv : nval, eq (modarith (modarith nv)) (modarith nv)"
                ]
            },
            {
                "tactic_sig": "destruct nv as [  | _o | ] .",
                "tactic_sig_no_out_arg": "destruct nv .",
                "tactic_args": [
                    "c1_goal : forall nv : nval, eq (modarith (modarith nv)) (modarith nv)"
                ],
                "tactic_res": [
                    "c2_goal : eq (modarith (modarith Nothing)) (modarith Nothing)",
                    "c3_goal : eq (modarith (modarith (I m))) (modarith (I m))",
                    "c3_m : Int.int",
                    "c4_goal : eq (modarith (modarith All)) (modarith All)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c2_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
                ],
                "tactic_res": [
                    "c5_goal : eq Nothing Nothing"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : eq Nothing Nothing"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : eq (modarith (modarith (I m))) (modarith (I m))"
                ],
                "tactic_res": [
                    "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : eq (modarith (modarith All)) (modarith All)"
                ],
                "tactic_res": [
                    "c7_goal : eq All All"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : eq All All"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": [
                    "c8_goal : eq (complete_mask (complete_mask m)) (complete_mask m)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c8_goal : eq (complete_mask (complete_mask m)) (complete_mask m)",
                    "_global_1 : Z",
                    "_global_complete_mask_idem : forall m : Int.int,\n       eq (complete_mask (complete_mask m)) (complete_mask m)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "mul_sound",
        "proof": [
            {
                "tactic_sig": "Lemma mul_sound : forall v1 w1 v2 w2 x , vagree v1 w1 ( modarith x ) -> vagree v2 w2 ( modarith x ) -> vagree ( Val.mul v1 v2 ) ( Val.mul w1 w2 ) x .",
                "tactic_sig_no_out_arg": "Lemma mul_sound : forall v1 w1 v2 w2 x , vagree v1 w1 ( modarith x ) -> vagree v2 w2 ( modarith x ) -> vagree ( Val.mul v1 v2 ) ( Val.mul w1 w2 ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)),\nvagree (Val.mul v1 v2) (Val.mul w1 w2) x"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "_global_mul : forall (_ : aval) (_ : aval), aval",
                    "_global_add : forall (_ : aval) (_ : aval), aval"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)),\nvagree (Val.mul v1 v2) (Val.mul w1 w2) x"
                ],
                "tactic_res": [
                    "c2_goal : vagree (Val.mul v1 v2) (Val.mul w1 w2) x",
                    "c2_v1 : val",
                    "c2_w1 : val",
                    "c2_v2 : val",
                    "c2_w2 : val",
                    "c2_x : nval",
                    "c2_H : vagree v1 w1 (modarith x)",
                    "c2_H0 : vagree v2 w2 (modarith x)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o | _o _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c2_goal : vagree (Val.mul v1 v2) (Val.mul w1 w2) x",
                    "c2_x : nval"
                ],
                "tactic_res": [
                    "c3_goal : vagree (Val.mul v1 v2) (Val.mul w1 w2) Nothing",
                    "c3_H0 : vagree v2 w2 (modarith Nothing)",
                    "c3_H : vagree v1 w1 (modarith Nothing)",
                    "c4_goal : vagree (Val.mul v1 v2) (Val.mul w1 w2) (I m)",
                    "c4_H0 : vagree v2 w2 (modarith (I m))",
                    "c4_H : vagree v1 w1 (modarith (I m))",
                    "c4_m : Int.int",
                    "c5_goal : vagree (Val.mul v1 v2) (Val.mul w1 w2) All",
                    "c5_H0 : vagree v2 w2 (modarith All)",
                    "c5_H : vagree v1 w1 (modarith All)"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c3_goal : vagree (Val.mul v1 v2) (Val.mul w1 w2) Nothing"
                ],
                "tactic_res": [
                    "c6_goal : True",
                    "c6_H0 : True",
                    "c6_H : True"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c4_goal : vagree (Val.mul v1 v2) (Val.mul w1 w2) (I m)"
                ],
                "tactic_res": [
                    "c7_goal : match Val.mul v1 v2 with\n| Vint p =>\n    match Val.mul w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c7_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                    "c7_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c5_goal : vagree (Val.mul v1 v2) (Val.mul w1 w2) All"
                ],
                "tactic_res": [
                    "c8_goal : Val.lessdef (Val.mul v1 v2) (Val.mul w1 w2)",
                    "c8_H0 : Val.lessdef v2 w2",
                    "c8_H : Val.lessdef v1 w1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold Val._i .",
                "tactic_sig_no_out_arg": "unfold Val._i .",
                "tactic_args": [
                    "c7_goal : match Val.mul v1 v2 with\n| Vint p =>\n    match Val.mul w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "_global_1 : Z",
                    "_global_mul : forall (_ : aval) (_ : aval), aval"
                ],
                "tactic_res": [
                    "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                    "c10_H0 : iagree i i0 (complete_mask m)",
                    "c10_H : iagree i1 i2 (complete_mask m)",
                    "c10_i0 : Int.int",
                    "c10_i : Int.int",
                    "c10_i2 : Int.int",
                    "c10_i1 : Int.int"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                    "_global_1 : Z",
                    "_global_eqmod_iagree : forall (m : Int.int) (x y : Z) (_ : eqmod (two_p (Int.size m)) x y),\n       iagree (Int.repr x) (Int.repr y) m"
                ],
                "tactic_res": [
                    "c11_goal : eqmod (two_p (Int.size m)) (Z.mul (Int.unsigned i1) (Int.unsigned i))\n  (Z.mul (Int.unsigned i2) (Int.unsigned i0))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : eqmod (two_p (Int.size m)) (Z.mul (Int.unsigned i1) (Int.unsigned i))\n  (Z.mul (Int.unsigned i2) (Int.unsigned i0))",
                    "_global_1 : Z",
                    "_global_eqmod_mult : forall (modul a b c d : Z) (_ : eqmod modul a c) (_ : eqmod modul b d),\n       eqmod modul (Z.mul a b) (Z.mul c d)"
                ],
                "tactic_res": [
                    "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)",
                    "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)",
                    "_global_1 : Z",
                    "_global_iagree_eqmod : forall (x y m : Int.int) (_ : iagree x y (complete_mask m)),\n       eqmod (two_p (Int.size m)) (Int.unsigned x) (Int.unsigned y)"
                ],
                "tactic_res": [
                    "c14_goal : iagree i1 i2 (complete_mask m)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : iagree i1 i2 (complete_mask m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                    "_global_1 : Z",
                    "_global_iagree_eqmod : forall (x y m : Int.int) (_ : iagree x y (complete_mask m)),\n       eqmod (two_p (Int.size m)) (Int.unsigned x) (Int.unsigned y)"
                ],
                "tactic_res": [
                    "c15_goal : iagree i i0 (complete_mask m)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : iagree i i0 (complete_mask m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c8_goal : Val.lessdef (Val.mul v1 v2) (Val.mul w1 w2)",
                    "c2_H : vagree v1 w1 (modarith x)"
                ],
                "tactic_res": [
                    "c16_goal : Val.lessdef (Val.mul w1 v2) (Val.mul w1 w2)",
                    "c17_goal : Val.lessdef (Val.mul Vundef v2) (Val.mul w1 w2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : Val.lessdef (Val.mul Vundef v2) (Val.mul w1 w2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c16_goal : Val.lessdef (Val.mul w1 v2) (Val.mul w1 w2)",
                    "c2_H0 : vagree v2 w2 (modarith x)"
                ],
                "tactic_res": [
                    "c18_goal : Val.lessdef (Val.mul w1 w2) (Val.mul w1 w2)",
                    "c19_goal : Val.lessdef (Val.mul w1 Vundef) (Val.mul w1 w2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : Val.lessdef (Val.mul w1 w2) (Val.mul w1 w2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  | _o | _o | _o | _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c19_goal : Val.lessdef (Val.mul w1 Vundef) (Val.mul w1 w2)",
                    "c2_w1 : val"
                ],
                "tactic_res": [
                    "c20_goal : Val.lessdef (Val.mul Vundef Vundef) (Val.mul Vundef w2)",
                    "c21_goal : Val.lessdef (Val.mul (Vint i) Vundef) (Val.mul (Vint i) w2)",
                    "c21_i : Int.int",
                    "c22_goal : Val.lessdef (Val.mul (Vlong i) Vundef) (Val.mul (Vlong i) w2)",
                    "c22_i : Int64.int",
                    "c23_goal : Val.lessdef (Val.mul (Vfloat f) Vundef) (Val.mul (Vfloat f) w2)",
                    "c23_f : float",
                    "c24_goal : Val.lessdef (Val.mul (Vsingle f) Vundef) (Val.mul (Vsingle f) w2)",
                    "c24_f : float32",
                    "c25_goal : Val.lessdef (Val.mul (Vptr b i) Vundef) (Val.mul (Vptr b i) w2)",
                    "c25_i : Ptrofs.int",
                    "c25_b : block"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c20_goal : Val.lessdef (Val.mul Vundef Vundef) (Val.mul Vundef w2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : Val.lessdef (Val.mul (Vint i) Vundef) (Val.mul (Vint i) w2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c22_goal : Val.lessdef (Val.mul (Vlong i) Vundef) (Val.mul (Vlong i) w2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : Val.lessdef (Val.mul (Vfloat f) Vundef) (Val.mul (Vfloat f) w2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : Val.lessdef (Val.mul (Vsingle f) Vundef) (Val.mul (Vsingle f) w2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : Val.lessdef (Val.mul (Vptr b i) Vundef) (Val.mul (Vptr b i) w2)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "neg_sound",
        "proof": [
            {
                "tactic_sig": "Lemma neg_sound : forall v w x , vagree v w ( modarith x ) -> vagree ( Val.neg v ) ( Val.neg w ) x .",
                "tactic_sig_no_out_arg": "Lemma neg_sound : forall v w x , vagree v w ( modarith x ) -> vagree ( Val.neg v ) ( Val.neg w ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (x : nval) (_ : vagree v w (modarith x)),\nvagree (Val.neg v) (Val.neg w) x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (x : nval) (_ : vagree v w (modarith x)),\nvagree (Val.neg v) (Val.neg w) x"
                ],
                "tactic_res": [
                    "c2_goal : vagree (Val.neg v) (Val.neg w) x",
                    "c2_v : val",
                    "c2_w : val",
                    "c2_x : nval",
                    "c2_H : vagree v w (modarith x)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c2_goal : vagree (Val.neg v) (Val.neg w) x",
                    "c2_x : nval"
                ],
                "tactic_res": [
                    "c3_goal : vagree (Val.neg v) (Val.neg w) Nothing",
                    "c3_H : vagree v w (modarith Nothing)",
                    "c4_goal : vagree (Val.neg v) (Val.neg w) (I m)",
                    "c4_H : vagree v w (modarith (I m))",
                    "c4_m : Int.int",
                    "c5_goal : vagree (Val.neg v) (Val.neg w) All",
                    "c5_H : vagree v w (modarith All)"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c3_goal : vagree (Val.neg v) (Val.neg w) Nothing"
                ],
                "tactic_res": [
                    "c6_goal : True",
                    "c6_H : True"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c4_goal : vagree (Val.neg v) (Val.neg w) (I m)"
                ],
                "tactic_res": [
                    "c7_goal : match Val.neg v with\n| Vint p =>\n    match Val.neg w with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c7_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c5_goal : vagree (Val.neg v) (Val.neg w) All"
                ],
                "tactic_res": [
                    "c8_goal : Val.lessdef (Val.neg v) (Val.neg w)",
                    "c8_H : Val.lessdef v w"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold Val._i .",
                "tactic_sig_no_out_arg": "unfold Val._i .",
                "tactic_args": [
                    "c7_goal : match Val.neg v with\n| Vint p =>\n    match Val.neg w with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "_global_1 : Z",
                    "_global_neg : forall _ : aval, aval"
                ],
                "tactic_res": [
                    "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                    "c10_H : iagree i i0 (complete_mask m)",
                    "c10_i0 : Int.int",
                    "c10_i : Int.int"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                    "_global_1 : Z",
                    "_global_eqmod_iagree : forall (m : Int.int) (x y : Z) (_ : eqmod (two_p (Int.size m)) x y),\n       iagree (Int.repr x) (Int.repr y) m"
                ],
                "tactic_res": [
                    "c11_goal : eqmod (two_p (Int.size m)) (Z.opp (Int.unsigned i))\n  (Z.opp (Int.unsigned i0))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c11_goal : eqmod (two_p (Int.size m)) (Z.opp (Int.unsigned i))\n  (Z.opp (Int.unsigned i0))",
                    "_global_1 : Z",
                    "_global_eqmod_neg : forall (modul x y : Z) (_ : eqmod modul x y),\n       eqmod modul (Z.opp x) (Z.opp y)"
                ],
                "tactic_res": [
                    "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                    "_global_1 : Z",
                    "_global_iagree_eqmod : forall (x y m : Int.int) (_ : iagree x y (complete_mask m)),\n       eqmod (two_p (Int.size m)) (Int.unsigned x) (Int.unsigned y)"
                ],
                "tactic_res": [
                    "c13_goal : iagree i i0 (complete_mask m)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : iagree i i0 (complete_mask m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c8_goal : Val.lessdef (Val.neg v) (Val.neg w)",
                    "c2_H : vagree v w (modarith x)"
                ],
                "tactic_res": [
                    "c14_goal : Val.lessdef (Val.neg w) (Val.neg w)",
                    "c15_goal : Val.lessdef (Val.neg Vundef) (Val.neg w)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : Val.lessdef (Val.neg w) (Val.neg w)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c15_goal : Val.lessdef (Val.neg Vundef) (Val.neg w)"
                ],
                "tactic_res": [
                    "c16_goal : Val.lessdef Vundef (Val.neg w)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : Val.lessdef Vundef (Val.neg w)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "zero_ext_sound",
        "proof": [
            {
                "tactic_sig": "Lemma zero_ext_sound : forall v w x n , vagree v w ( zero_ext n x ) -> 0 <= n -> vagree ( Val.zero_ext n v ) ( Val.zero_ext n w ) x .",
                "tactic_sig_no_out_arg": "Lemma zero_ext_sound : forall v w x n , vagree v w ( zero_ext n x ) -> 0 <= n -> vagree ( Val.zero_ext n v ) ( Val.zero_ext n w ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Z) (_ : vagree v w (zero_ext n x))\n  (_ : Z.le 0 n), vagree (Val.zero_ext n v) (Val.zero_ext n w) x"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Z) (_ : vagree v w (zero_ext n x))\n  (_ : Z.le 0 n), vagree (Val.zero_ext n v) (Val.zero_ext n w) x",
                    "_global_1 : Z",
                    "_global_zero_ext : forall (_ : Z) (_ : nval), nval"
                ],
                "tactic_res": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Z)\n  (_ : vagree v w\n         match x with\n         | Nothing => Nothing\n         | I m => I (Int.zero_ext n m)\n         | All => I (Int.zero_ext n Int.mone)\n         end) (_ : Z.le 0 n),\nvagree (Val.zero_ext n v) (Val.zero_ext n w) x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Z)\n  (_ : vagree v w\n         match x with\n         | Nothing => Nothing\n         | I m => I (Int.zero_ext n m)\n         | All => I (Int.zero_ext n Int.mone)\n         end) (_ : Z.le 0 n),\nvagree (Val.zero_ext n v) (Val.zero_ext n w) x"
                ],
                "tactic_res": [
                    "c3_goal : vagree (Val.zero_ext n v) (Val.zero_ext n w) x",
                    "c3_v : val",
                    "c3_w : val",
                    "c3_x : nval",
                    "c3_n : Z",
                    "c3_H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.zero_ext n m)\n  | All => I (Int.zero_ext n Int.mone)\n  end",
                    "c3_H0 : Z.le 0 n"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : vagree (Val.zero_ext n v) (Val.zero_ext n w) x",
                    "c3_x : nval"
                ],
                "tactic_res": [
                    "c4_goal : vagree (Val.zero_ext n v) (Val.zero_ext n w) Nothing",
                    "c4_H : vagree v w Nothing",
                    "c5_goal : vagree (Val.zero_ext n v) (Val.zero_ext n w) (I m)",
                    "c5_H : vagree v w (I (Int.zero_ext n m))",
                    "c5_m : Int.int",
                    "c6_goal : vagree (Val.zero_ext n v) (Val.zero_ext n w) All",
                    "c6_H : vagree v w (I (Int.zero_ext n Int.mone))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c4_goal : vagree (Val.zero_ext n v) (Val.zero_ext n w) Nothing"
                ],
                "tactic_res": [
                    "c7_goal : True",
                    "c7_H : True"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c5_goal : vagree (Val.zero_ext n v) (Val.zero_ext n w) (I m)"
                ],
                "tactic_res": [
                    "c8_goal : match Val.zero_ext n v with\n| Vint p =>\n    match Val.zero_ext n w with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c8_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.zero_ext n m)\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c6_goal : vagree (Val.zero_ext n v) (Val.zero_ext n w) All"
                ],
                "tactic_res": [
                    "c9_goal : Val.lessdef (Val.zero_ext n v) (Val.zero_ext n w)",
                    "c9_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.zero_ext n Int.mone)\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold Val._i .",
                "tactic_sig_no_out_arg": "unfold Val._i .",
                "tactic_args": [
                    "c8_goal : match Val.zero_ext n v with\n| Vint p =>\n    match Val.zero_ext n w with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "_global_1 : Z",
                    "_global_zero_ext : forall (_ : Z) (_ : nval), nval"
                ],
                "tactic_res": [
                    "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                    "c11_H : iagree i i0 (Int.zero_ext n m)",
                    "c11_i0 : Int.int",
                    "c11_i : Int.int"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m"
                ],
                "tactic_res": [
                    "c12_goal : forall (i1 : Z) (_ : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize))\n  (_ : eq (Int.testbit m i1) true),\neq (Int.testbit (Int.zero_ext n i) i1)\n  (Int.testbit (Int.zero_ext n i0) i1)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c12_goal : forall (i1 : Z) (_ : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize))\n  (_ : eq (Int.testbit m i1) true),\neq (Int.testbit (Int.zero_ext n i) i1)\n  (Int.testbit (Int.zero_ext n i0) i1)"
                ],
                "tactic_res": [
                    "c13_goal : eq (Int.testbit (Int.zero_ext n i) i1)\n  (Int.testbit (Int.zero_ext n i0) i1)",
                    "c13_i1 : Z",
                    "c13_H1 : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)",
                    "c13_H2 : eq (Int.testbit m i1) true"
                ]
            },
            {
                "tactic_sig": "autorewrite with ints .",
                "tactic_sig_no_out_arg": "autorewrite with ints .",
                "tactic_args": [
                    "c13_goal : eq (Int.testbit (Int.zero_ext n i) i1)\n  (Int.testbit (Int.zero_ext n i0) i1)"
                ],
                "tactic_res": [
                    "c14_goal : eq (if zlt i1 n then Int.testbit i i1 else false)\n  (if zlt i1 n then Int.testbit i0 i1 else false)",
                    "c15_goal : Z.le 0 i1",
                    "c16_goal : Z.le 0 i1"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c15_goal : Z.le 0 i1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c16_goal : Z.le 0 i1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "c14_goal : eq (if zlt i1 n then Int.testbit i i1 else false)\n  (if zlt i1 n then Int.testbit i0 i1 else false)",
                    "c13_i1 : Z",
                    "c3_n : Z"
                ],
                "tactic_res": [
                    "c17_goal : eq (Int.testbit i i1) (Int.testbit i0 i1)",
                    "c17_l : Z.lt i1 n",
                    "c18_goal : eq false false",
                    "c18_g : Z.ge i1 n"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : eq false false"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c17_goal : eq (Int.testbit i i1) (Int.testbit i0 i1)",
                    "_global_1 : Z",
                    "c3_H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.zero_ext n m)\n  | All => I (Int.zero_ext n Int.mone)\n  end"
                ],
                "tactic_res": [
                    "c19_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)",
                    "c20_goal : eq (Int.testbit (Int.zero_ext n m) i1) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c19_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "autorewrite with ints .",
                "tactic_sig_no_out_arg": "autorewrite with ints .",
                "tactic_args": [
                    "c20_goal : eq (Int.testbit (Int.zero_ext n m) i1) true"
                ],
                "tactic_res": [
                    "c21_goal : eq (if zlt i1 n then Int.testbit m i1 else false) true",
                    "c22_goal : Z.le 0 i1"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c22_goal : Z.le 0 i1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c21_goal : eq (if zlt i1 n then Int.testbit m i1 else false) true",
                    "_global_1 : Z",
                    "_global_zlt_true : forall (A : Type) (x y : Z) (a b : A) (_ : Z.lt x y),\n       eq (if zlt x y then a else b) a"
                ],
                "tactic_res": [
                    "c23_goal : eq (Int.testbit m i1) true",
                    "c24_goal : Z.lt i1 n"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : eq (Int.testbit m i1) true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : Z.lt i1 n"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold Val._i .",
                "tactic_sig_no_out_arg": "unfold Val._i .",
                "tactic_args": [
                    "c9_goal : Val.lessdef (Val.zero_ext n v) (Val.zero_ext n w)",
                    "_global_1 : Z",
                    "_global_zero_ext : forall (_ : Z) (_ : nval), nval"
                ],
                "tactic_res": [
                    "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ]
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                    "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                    "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                    "c26_i0 : Int.int",
                    "c26_i : Int.int"
                ]
            },
            {
                "tactic_sig": "apply Val.lessdef_same .",
                "tactic_sig_no_out_arg": "apply Val.lessdef_same .",
                "tactic_args": [
                    "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c27_goal : eq (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c27_goal : eq (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))"
                ],
                "tactic_res": [
                    "c28_goal : eq (Int.zero_ext n i) (Int.zero_ext n i0)"
                ]
            },
            {
                "tactic_sig": "Int.bit_solve .",
                "tactic_sig_no_out_arg": "Int.bit_solve .",
                "tactic_args": [
                    "c28_goal : eq (Int.zero_ext n i) (Int.zero_ext n i0)"
                ],
                "tactic_res": [
                    "c29_goal : eq (if zlt i1 n then Int.testbit i i1 else false)\n  (if zlt i1 n then Int.testbit i0 i1 else false)",
                    "c29_H1 : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)",
                    "c29_i1 : Z",
                    "c30_goal : Z.le 0 i1",
                    "c30_H1 : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)",
                    "c30_i1 : Z",
                    "c31_goal : Z.le 0 i1",
                    "c31_H1 : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)",
                    "c31_i1 : Z"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c30_goal : Z.le 0 i1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c31_goal : Z.le 0 i1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "c29_goal : eq (if zlt i1 n then Int.testbit i i1 else false)\n  (if zlt i1 n then Int.testbit i0 i1 else false)",
                    "c29_i1 : Z",
                    "c3_n : Z"
                ],
                "tactic_res": [
                    "c32_goal : eq (Int.testbit i i1) (Int.testbit i0 i1)",
                    "c32_l : Z.lt i1 n",
                    "c33_goal : eq false false",
                    "c33_g : Z.ge i1 n"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c33_goal : eq false false"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c32_goal : eq (Int.testbit i i1) (Int.testbit i0 i1)",
                    "_global_1 : Z",
                    "c3_H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.zero_ext n m)\n  | All => I (Int.zero_ext n Int.mone)\n  end"
                ],
                "tactic_res": [
                    "c34_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)",
                    "c35_goal : eq (Int.testbit (Int.zero_ext n Int.mone) i1) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c34_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "autorewrite with ints .",
                "tactic_sig_no_out_arg": "autorewrite with ints .",
                "tactic_args": [
                    "c35_goal : eq (Int.testbit (Int.zero_ext n Int.mone) i1) true"
                ],
                "tactic_res": [
                    "c36_goal : eq (if zlt i1 n then true else false) true",
                    "c37_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)",
                    "c38_goal : Z.le 0 i1"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c37_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c38_goal : Z.le 0 i1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c36_goal : eq (if zlt i1 n then true else false) true",
                    "_global_1 : Z",
                    "_global_zlt_true : forall (A : Type) (x y : Z) (a b : A) (_ : Z.lt x y),\n       eq (if zlt x y then a else b) a"
                ],
                "tactic_res": [
                    "c39_goal : Z.lt i1 n"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c39_goal : Z.lt i1 n"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sign_ext_sound",
        "proof": [
            {
                "tactic_sig": "Lemma sign_ext_sound : forall v w x n , vagree v w ( sign_ext n x ) -> 0 < n -> vagree ( Val.sign_ext n v ) ( Val.sign_ext n w ) x .",
                "tactic_sig_no_out_arg": "Lemma sign_ext_sound : forall v w x n , vagree v w ( sign_ext n x ) -> 0 < n -> vagree ( Val.sign_ext n v ) ( Val.sign_ext n w ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Z) (_ : vagree v w (sign_ext n x))\n  (_ : Z.lt 0 n), vagree (Val.sign_ext n v) (Val.sign_ext n w) x"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Z) (_ : vagree v w (sign_ext n x))\n  (_ : Z.lt 0 n), vagree (Val.sign_ext n v) (Val.sign_ext n w) x",
                    "_global_1 : Z",
                    "_global_sign_ext : forall (_ : Z) (_ : nval), nval"
                ],
                "tactic_res": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Z)\n  (_ : vagree v w\n         match x with\n         | Nothing => Nothing\n         | I m =>\n             I\n               (Int.or (Int.zero_ext n m)\n                  (Int.shl Int.one (Int.repr (Z.sub n 1))))\n         | All => I (Int.zero_ext n Int.mone)\n         end) (_ : Z.lt 0 n),\nvagree (Val.sign_ext n v) (Val.sign_ext n w) x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Z)\n  (_ : vagree v w\n         match x with\n         | Nothing => Nothing\n         | I m =>\n             I\n               (Int.or (Int.zero_ext n m)\n                  (Int.shl Int.one (Int.repr (Z.sub n 1))))\n         | All => I (Int.zero_ext n Int.mone)\n         end) (_ : Z.lt 0 n),\nvagree (Val.sign_ext n v) (Val.sign_ext n w) x"
                ],
                "tactic_res": [
                    "c3_goal : vagree (Val.sign_ext n v) (Val.sign_ext n w) x",
                    "c3_v : val",
                    "c3_w : val",
                    "c3_x : nval",
                    "c3_n : Z",
                    "c3_H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m =>\n      I\n        (Int.or (Int.zero_ext n m)\n           (Int.shl Int.one (Int.repr (Z.sub n 1))))\n  | All => I (Int.zero_ext n Int.mone)\n  end",
                    "c3_H0 : Z.lt 0 n"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : vagree (Val.sign_ext n v) (Val.sign_ext n w) x",
                    "c3_x : nval"
                ],
                "tactic_res": [
                    "c4_goal : vagree (Val.sign_ext n v) (Val.sign_ext n w) Nothing",
                    "c4_H : vagree v w Nothing",
                    "c5_goal : vagree (Val.sign_ext n v) (Val.sign_ext n w) (I m)",
                    "c5_H : vagree v w\n  (I\n     (Int.or (Int.zero_ext n m)\n        (Int.shl Int.one (Int.repr (Z.sub n 1)))))",
                    "c5_m : Int.int",
                    "c6_goal : vagree (Val.sign_ext n v) (Val.sign_ext n w) All",
                    "c6_H : vagree v w (I (Int.zero_ext n Int.mone))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c4_goal : vagree (Val.sign_ext n v) (Val.sign_ext n w) Nothing"
                ],
                "tactic_res": [
                    "c7_goal : True",
                    "c7_H : True"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c5_goal : vagree (Val.sign_ext n v) (Val.sign_ext n w) (I m)"
                ],
                "tactic_res": [
                    "c8_goal : match Val.sign_ext n v with\n| Vint p =>\n    match Val.sign_ext n w with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c8_H : match v with\n| Vint p =>\n    match w with\n    | Vint q =>\n        iagree p q\n          (Int.or (Int.zero_ext n m)\n             (Int.shl Int.one (Int.repr (Z.sub n 1))))\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c6_goal : vagree (Val.sign_ext n v) (Val.sign_ext n w) All"
                ],
                "tactic_res": [
                    "c9_goal : Val.lessdef (Val.sign_ext n v) (Val.sign_ext n w)",
                    "c9_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.zero_ext n Int.mone)\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold Val._i .",
                "tactic_sig_no_out_arg": "unfold Val._i .",
                "tactic_args": [
                    "c8_goal : match Val.sign_ext n v with\n| Vint p =>\n    match Val.sign_ext n w with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "_global_1 : Z",
                    "_global_sign_ext : forall (_ : Z) (_ : nval), nval"
                ],
                "tactic_res": [
                    "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                    "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                    "c11_i0 : Int.int",
                    "c11_i : Int.int"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m"
                ],
                "tactic_res": [
                    "c12_goal : forall (i1 : Z) (_ : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize))\n  (_ : eq (Int.testbit m i1) true),\neq (Int.testbit (Int.sign_ext n i) i1)\n  (Int.testbit (Int.sign_ext n i0) i1)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c12_goal : forall (i1 : Z) (_ : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize))\n  (_ : eq (Int.testbit m i1) true),\neq (Int.testbit (Int.sign_ext n i) i1)\n  (Int.testbit (Int.sign_ext n i0) i1)"
                ],
                "tactic_res": [
                    "c13_goal : eq (Int.testbit (Int.sign_ext n i) i1)\n  (Int.testbit (Int.sign_ext n i0) i1)",
                    "c13_i1 : Z",
                    "c13_H1 : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)",
                    "c13_H2 : eq (Int.testbit m i1) true"
                ]
            },
            {
                "tactic_sig": "autorewrite with ints .",
                "tactic_sig_no_out_arg": "autorewrite with ints .",
                "tactic_args": [
                    "c13_goal : eq (Int.testbit (Int.sign_ext n i) i1)\n  (Int.testbit (Int.sign_ext n i0) i1)"
                ],
                "tactic_res": [
                    "c14_goal : eq (Int.testbit i (if zlt i1 n then i1 else Z.sub n 1))\n  (Int.testbit i0 (if zlt i1 n then i1 else Z.sub n 1))",
                    "c15_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)",
                    "c16_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c15_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c16_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "set ( j := if zlt _i _i then _i else _i - 1 ) .",
                "tactic_sig_no_out_arg": "set ( j := if zlt _i _i then _i else _i - 1 ) .",
                "tactic_args": [
                    "c14_goal : eq (Int.testbit i (if zlt i1 n then i1 else Z.sub n 1))\n  (Int.testbit i0 (if zlt i1 n then i1 else Z.sub n 1))",
                    "c13_i1 : Z",
                    "c3_n : Z",
                    "c13_i1 : Z",
                    "c3_n : Z"
                ],
                "tactic_res": [
                    "c17_goal : eq (Int.testbit i j) (Int.testbit i0 j)",
                    "c17_j : Z"
                ]
            },
            {
                "tactic_sig": "assert ( 0 <= _i < Int.zwordsize ) .",
                "tactic_sig_no_out_arg": "assert ( 0 <= _i < Int.zwordsize ) .",
                "tactic_args": [
                    "c17_goal : eq (Int.testbit i j) (Int.testbit i0 j)",
                    "c17_j : Z"
                ],
                "tactic_res": [
                    "c18_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)",
                    "c19_goal : eq (Int.testbit i j) (Int.testbit i0 j)",
                    "c19_H3 : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c18_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)",
                    "_global_1 : Z",
                    "c17_j : Z"
                ],
                "tactic_res": [
                    "c20_goal : Logic.and (Z.le 0 (if zlt i1 n then i1 else Z.sub n 1))\n  (Z.lt (if zlt i1 n then i1 else Z.sub n 1) Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "c20_goal : Logic.and (Z.le 0 (if zlt i1 n then i1 else Z.sub n 1))\n  (Z.lt (if zlt i1 n then i1 else Z.sub n 1) Int.zwordsize)",
                    "c13_i1 : Z",
                    "c3_n : Z"
                ],
                "tactic_res": [
                    "c21_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)",
                    "c21_l : Z.lt i1 n",
                    "c22_goal : Logic.and (Z.le 0 (Z.sub n 1)) (Z.lt (Z.sub n 1) Int.zwordsize)",
                    "c22_g : Z.ge i1 n"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c21_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c22_goal : Logic.and (Z.le 0 (Z.sub n 1)) (Z.lt (Z.sub n 1) Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c19_goal : eq (Int.testbit i j) (Int.testbit i0 j)",
                    "_global_1 : Z",
                    "c3_H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m =>\n      I\n        (Int.or (Int.zero_ext n m)\n           (Int.shl Int.one (Int.repr (Z.sub n 1))))\n  | All => I (Int.zero_ext n Int.mone)\n  end"
                ],
                "tactic_res": [
                    "c23_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)",
                    "c24_goal : eq\n  (Int.testbit\n     (Int.or (Int.zero_ext n m)\n        (Int.shl Int.one (Int.repr (Z.sub n 1)))) j) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "autorewrite with ints .",
                "tactic_sig_no_out_arg": "autorewrite with ints .",
                "tactic_args": [
                    "c24_goal : eq\n  (Int.testbit\n     (Int.or (Int.zero_ext n m)\n        (Int.shl Int.one (Int.repr (Z.sub n 1)))) j) true"
                ],
                "tactic_res": [
                    "c25_goal : eq\n  (orb (if zlt j n then Int.testbit m j else false)\n     (if zlt j (Int.unsigned (Int.repr (Z.sub n 1)))\n      then false\n      else\n       Int.testbit Int.one\n         (Z.sub j (Int.unsigned (Int.repr (Z.sub n 1)))))) true",
                    "c26_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)",
                    "c27_goal : Z.le 0 j",
                    "c28_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c26_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c27_goal : Z.le 0 j"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c28_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c25_goal : eq\n  (orb (if zlt j n then Int.testbit m j else false)\n     (if zlt j (Int.unsigned (Int.repr (Z.sub n 1)))\n      then false\n      else\n       Int.testbit Int.one\n         (Z.sub j (Int.unsigned (Int.repr (Z.sub n 1)))))) true",
                    "_global_1 : Z",
                    "_global_orb_true_intro : forall (b1 b2 : bool) (_ : Logic.or (eq b1 true) (eq b2 true)),\n       eq (orb b1 b2) true"
                ],
                "tactic_res": [
                    "c29_goal : Logic.or (eq (if zlt j n then Int.testbit m j else false) true)\n  (eq\n     (if zlt j (Int.unsigned (Int.repr (Z.sub n 1)))\n      then false\n      else\n       Int.testbit Int.one\n         (Z.sub j (Int.unsigned (Int.repr (Z.sub n 1))))) true)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c29_goal : Logic.or (eq (if zlt j n then Int.testbit m j else false) true)\n  (eq\n     (if zlt j (Int.unsigned (Int.repr (Z.sub n 1)))\n      then false\n      else\n       Int.testbit Int.one\n         (Z.sub j (Int.unsigned (Int.repr (Z.sub n 1))))) true)",
                    "_global_1 : Z",
                    "c17_j : Z"
                ],
                "tactic_res": [
                    "c30_goal : Logic.or\n  (eq\n     (if zlt (if zlt i1 n then i1 else Z.sub n 1) n\n      then Int.testbit m (if zlt i1 n then i1 else Z.sub n 1)\n      else false) true)\n  (eq\n     (if\n       zlt (if zlt i1 n then i1 else Z.sub n 1)\n         (Int.unsigned (Int.repr (Z.sub n 1)))\n      then false\n      else\n       Int.testbit Int.one\n         (Z.sub (if zlt i1 n then i1 else Z.sub n 1)\n            (Int.unsigned (Int.repr (Z.sub n 1))))) true)"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "c30_goal : Logic.or\n  (eq\n     (if zlt (if zlt i1 n then i1 else Z.sub n 1) n\n      then Int.testbit m (if zlt i1 n then i1 else Z.sub n 1)\n      else false) true)\n  (eq\n     (if\n       zlt (if zlt i1 n then i1 else Z.sub n 1)\n         (Int.unsigned (Int.repr (Z.sub n 1)))\n      then false\n      else\n       Int.testbit Int.one\n         (Z.sub (if zlt i1 n then i1 else Z.sub n 1)\n            (Int.unsigned (Int.repr (Z.sub n 1))))) true)",
                    "c13_i1 : Z",
                    "c3_n : Z"
                ],
                "tactic_res": [
                    "c31_goal : Logic.or (eq (if zlt i1 n then Int.testbit m i1 else false) true)\n  (eq\n     (if zlt i1 (Int.unsigned (Int.repr (Z.sub n 1)))\n      then false\n      else\n       Int.testbit Int.one\n         (Z.sub i1 (Int.unsigned (Int.repr (Z.sub n 1))))) true)",
                    "c31_l : Z.lt i1 n",
                    "c32_goal : Logic.or\n  (eq (if zlt (Z.sub n 1) n then Int.testbit m (Z.sub n 1) else false)\n     true)\n  (eq\n     (if zlt (Z.sub n 1) (Int.unsigned (Int.repr (Z.sub n 1)))\n      then false\n      else\n       Int.testbit Int.one\n         (Z.sub (Z.sub n 1) (Int.unsigned (Int.repr (Z.sub n 1)))))\n     true)",
                    "c32_g : Z.ge i1 n"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c31_goal : Logic.or (eq (if zlt i1 n then Int.testbit m i1 else false) true)\n  (eq\n     (if zlt i1 (Int.unsigned (Int.repr (Z.sub n 1)))\n      then false\n      else\n       Int.testbit Int.one\n         (Z.sub i1 (Int.unsigned (Int.repr (Z.sub n 1))))) true)"
                ],
                "tactic_res": [
                    "c33_goal : eq (if zlt i1 n then Int.testbit m i1 else false) true"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c33_goal : eq (if zlt i1 n then Int.testbit m i1 else false) true",
                    "_global_1 : Z",
                    "_global_zlt_true : forall (A : Type) (x y : Z) (a b : A) (_ : Z.lt x y),\n       eq (if zlt x y then a else b) a"
                ],
                "tactic_res": [
                    "c34_goal : eq (Int.testbit m i1) true",
                    "c35_goal : Z.lt i1 n"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c34_goal : eq (Int.testbit m i1) true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c35_goal : Z.lt i1 n"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c32_goal : Logic.or\n  (eq (if zlt (Z.sub n 1) n then Int.testbit m (Z.sub n 1) else false)\n     true)\n  (eq\n     (if zlt (Z.sub n 1) (Int.unsigned (Int.repr (Z.sub n 1)))\n      then false\n      else\n       Int.testbit Int.one\n         (Z.sub (Z.sub n 1) (Int.unsigned (Int.repr (Z.sub n 1)))))\n     true)"
                ],
                "tactic_res": [
                    "c36_goal : eq\n  (if zlt (Z.sub n 1) (Int.unsigned (Int.repr (Z.sub n 1)))\n   then false\n   else\n    Int.testbit Int.one\n      (Z.sub (Z.sub n 1) (Int.unsigned (Int.repr (Z.sub n 1))))) true"
                ]
            },
            {
                "tactic_sig": "rewrite Int.unsigned_repr .",
                "tactic_sig_no_out_arg": "rewrite Int.unsigned_repr .",
                "tactic_args": [
                    "c36_goal : eq\n  (if zlt (Z.sub n 1) (Int.unsigned (Int.repr (Z.sub n 1)))\n   then false\n   else\n    Int.testbit Int.one\n      (Z.sub (Z.sub n 1) (Int.unsigned (Int.repr (Z.sub n 1))))) true",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c37_goal : eq\n  (if zlt (Z.sub n 1) (Z.sub n 1)\n   then false\n   else Int.testbit Int.one (Z.sub (Z.sub n 1) (Z.sub n 1))) true",
                    "c38_goal : Logic.and (Z.le 0 (Z.sub n 1)) (Z.le (Z.sub n 1) Int.max_unsigned)"
                ]
            },
            {
                "tactic_sig": "rewrite _i by lia .",
                "tactic_sig_no_out_arg": "rewrite _i by lia .",
                "tactic_args": [
                    "c37_goal : eq\n  (if zlt (Z.sub n 1) (Z.sub n 1)\n   then false\n   else Int.testbit Int.one (Z.sub (Z.sub n 1) (Z.sub n 1))) true",
                    "_global_1 : Z",
                    "_global_zlt_false : forall (A : Type) (x y : Z) (a b : A) (_ : Z.ge x y),\n       eq (if zlt x y then a else b) b"
                ],
                "tactic_res": [
                    "c39_goal : eq (Int.testbit Int.one (Z.sub (Z.sub n 1) (Z.sub n 1))) true"
                ]
            },
            {
                "tactic_sig": "replace ( _i - 1 - ( _i - 1 ) ) with 0 by lia .",
                "tactic_sig_no_out_arg": "replace ( _i - 1 - ( _i - 1 ) ) with 0 by lia .",
                "tactic_args": [
                    "c39_goal : eq (Int.testbit Int.one (Z.sub (Z.sub n 1) (Z.sub n 1))) true",
                    "c3_n : Z",
                    "c3_n : Z"
                ],
                "tactic_res": [
                    "c40_goal : eq (Int.testbit Int.one 0) true"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "c40_goal : eq (Int.testbit Int.one 0) true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize Int.wordsize_max_unsigned .",
                "tactic_sig_no_out_arg": "generalize Int.wordsize_max_unsigned .",
                "tactic_args": [
                    "c38_goal : Logic.and (Z.le 0 (Z.sub n 1)) (Z.le (Z.sub n 1) Int.max_unsigned)"
                ],
                "tactic_res": [
                    "c41_goal : forall _ : Z.le Int.zwordsize Int.max_unsigned,\nLogic.and (Z.le 0 (Z.sub n 1)) (Z.le (Z.sub n 1) Int.max_unsigned)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c41_goal : forall _ : Z.le Int.zwordsize Int.max_unsigned,\nLogic.and (Z.le 0 (Z.sub n 1)) (Z.le (Z.sub n 1) Int.max_unsigned)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold Val._i .",
                "tactic_sig_no_out_arg": "unfold Val._i .",
                "tactic_args": [
                    "c9_goal : Val.lessdef (Val.sign_ext n v) (Val.sign_ext n w)",
                    "_global_1 : Z",
                    "_global_sign_ext : forall (_ : Z) (_ : nval), nval"
                ],
                "tactic_res": [
                    "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ]
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                    "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                    "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                    "c43_i0 : Int.int",
                    "c43_i : Int.int"
                ]
            },
            {
                "tactic_sig": "apply Val.lessdef_same .",
                "tactic_sig_no_out_arg": "apply Val.lessdef_same .",
                "tactic_args": [
                    "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c44_goal : eq (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "c44_goal : eq (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))"
                ],
                "tactic_res": [
                    "c45_goal : eq (Int.sign_ext n i) (Int.sign_ext n i0)"
                ]
            },
            {
                "tactic_sig": "Int.bit_solve .",
                "tactic_sig_no_out_arg": "Int.bit_solve .",
                "tactic_args": [
                    "c45_goal : eq (Int.sign_ext n i) (Int.sign_ext n i0)"
                ],
                "tactic_res": [
                    "c46_goal : eq (Int.testbit i (if zlt i1 n then i1 else Z.sub n 1))\n  (Int.testbit i0 (if zlt i1 n then i1 else Z.sub n 1))",
                    "c46_H1 : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)",
                    "c46_i1 : Z"
                ]
            },
            {
                "tactic_sig": "set ( j := if zlt _i _i then _i else _i - 1 ) .",
                "tactic_sig_no_out_arg": "set ( j := if zlt _i _i then _i else _i - 1 ) .",
                "tactic_args": [
                    "c46_goal : eq (Int.testbit i (if zlt i1 n then i1 else Z.sub n 1))\n  (Int.testbit i0 (if zlt i1 n then i1 else Z.sub n 1))",
                    "c46_i1 : Z",
                    "c3_n : Z",
                    "c46_i1 : Z",
                    "c3_n : Z"
                ],
                "tactic_res": [
                    "c47_goal : eq (Int.testbit i j) (Int.testbit i0 j)",
                    "c47_j : Z"
                ]
            },
            {
                "tactic_sig": "assert ( 0 <= _i < Int.zwordsize ) .",
                "tactic_sig_no_out_arg": "assert ( 0 <= _i < Int.zwordsize ) .",
                "tactic_args": [
                    "c47_goal : eq (Int.testbit i j) (Int.testbit i0 j)",
                    "c47_j : Z"
                ],
                "tactic_res": [
                    "c48_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)",
                    "c49_goal : eq (Int.testbit i j) (Int.testbit i0 j)",
                    "c49_H2 : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c48_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)",
                    "_global_1 : Z",
                    "c47_j : Z"
                ],
                "tactic_res": [
                    "c50_goal : Logic.and (Z.le 0 (if zlt i1 n then i1 else Z.sub n 1))\n  (Z.lt (if zlt i1 n then i1 else Z.sub n 1) Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "c50_goal : Logic.and (Z.le 0 (if zlt i1 n then i1 else Z.sub n 1))\n  (Z.lt (if zlt i1 n then i1 else Z.sub n 1) Int.zwordsize)",
                    "c46_i1 : Z",
                    "c3_n : Z"
                ],
                "tactic_res": [
                    "c51_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)",
                    "c51_l : Z.lt i1 n",
                    "c52_goal : Logic.and (Z.le 0 (Z.sub n 1)) (Z.lt (Z.sub n 1) Int.zwordsize)",
                    "c52_g : Z.ge i1 n"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c51_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c52_goal : Logic.and (Z.le 0 (Z.sub n 1)) (Z.lt (Z.sub n 1) Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c49_goal : eq (Int.testbit i j) (Int.testbit i0 j)",
                    "_global_1 : Z",
                    "c3_H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m =>\n      I\n        (Int.or (Int.zero_ext n m)\n           (Int.shl Int.one (Int.repr (Z.sub n 1))))\n  | All => I (Int.zero_ext n Int.mone)\n  end"
                ],
                "tactic_res": [
                    "c53_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)",
                    "c54_goal : eq (Int.testbit (Int.zero_ext n Int.mone) j) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c53_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite Int.bits_zero_ext .",
                "tactic_sig_no_out_arg": "rewrite Int.bits_zero_ext .",
                "tactic_args": [
                    "c54_goal : eq (Int.testbit (Int.zero_ext n Int.mone) j) true",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c55_goal : eq (if zlt j n then Int.testbit Int.mone j else false) true",
                    "c56_goal : Z.le 0 j"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c56_goal : Z.le 0 j"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c55_goal : eq (if zlt j n then Int.testbit Int.mone j else false) true",
                    "_global_1 : Z",
                    "_global_zlt_true : forall (A : Type) (x y : Z) (a b : A) (_ : Z.lt x y),\n       eq (if zlt x y then a else b) a"
                ],
                "tactic_res": [
                    "c57_goal : eq (Int.testbit Int.mone j) true",
                    "c58_goal : Z.lt j n"
                ]
            },
            {
                "tactic_sig": "apply Int.bits_mone .",
                "tactic_sig_no_out_arg": "apply Int.bits_mone .",
                "tactic_args": [
                    "c57_goal : eq (Int.testbit Int.mone j) true",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c59_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c59_goal : Logic.and (Z.le 0 j) (Z.lt j Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c58_goal : Z.lt j n",
                    "_global_1 : Z",
                    "c47_j : Z"
                ],
                "tactic_res": [
                    "c60_goal : Z.lt (if zlt i1 n then i1 else Z.sub n 1) n"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "c60_goal : Z.lt (if zlt i1 n then i1 else Z.sub n 1) n",
                    "c46_i1 : Z",
                    "c3_n : Z"
                ],
                "tactic_res": [
                    "c61_goal : Z.lt i1 n",
                    "c61_l : Z.lt i1 n",
                    "c62_goal : Z.lt (Z.sub n 1) n",
                    "c62_g : Z.ge i1 n"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c61_goal : Z.lt i1 n"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c62_goal : Z.lt (Z.sub n 1) n"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "maskzero_sound",
        "proof": [
            {
                "tactic_sig": "Lemma maskzero_sound : forall v w n b , vagree v w ( maskzero n ) -> Val.maskzero_bool v n = Some b -> Val.maskzero_bool w n = Some b .",
                "tactic_sig_no_out_arg": "Lemma maskzero_sound : forall v w n b , vagree v w ( maskzero n ) -> Val.maskzero_bool v n = Some b -> Val.maskzero_bool w n = Some b .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (n : Int.int) (b : bool)\n  (_ : vagree v w (maskzero n))\n  (_ : eq (Val.maskzero_bool v n) (Some b)),\neq (Val.maskzero_bool w n) (Some b)"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (n : Int.int) (b : bool)\n  (_ : vagree v w (maskzero n))\n  (_ : eq (Val.maskzero_bool v n) (Some b)),\neq (Val.maskzero_bool w n) (Some b)",
                    "_global_1 : Z",
                    "_global_maskzero : forall _ : Int.int, nval"
                ],
                "tactic_res": [
                    "c2_goal : forall (v w : val) (n : Int.int) (b : bool) (_ : vagree v w (I n))\n  (_ : eq (Val.maskzero_bool v n) (Some b)),\neq (Val.maskzero_bool w n) (Some b)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (v w : val) (n : Int.int) (b : bool) (_ : vagree v w (I n))\n  (_ : eq (Val.maskzero_bool v n) (Some b)),\neq (Val.maskzero_bool w n) (Some b)"
                ],
                "tactic_res": [
                    "c3_goal : eq (Val.maskzero_bool w n) (Some b)",
                    "c3_v : val",
                    "c3_w : val",
                    "c3_n : Int.int",
                    "c3_b : bool",
                    "c3_H : vagree v w (I n)",
                    "c3_H0 : eq (Val.maskzero_bool v n) (Some b)"
                ]
            },
            {
                "tactic_sig": "unfold Val.maskzero_bool .",
                "tactic_sig_no_out_arg": "unfold Val.maskzero_bool .",
                "tactic_args": [
                    "c3_goal : eq (Val.maskzero_bool w n) (Some b)",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ]
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                    "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                    "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                    "c5_H : True",
                    "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                    "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                    "c6_H : iagree i i0 n",
                    "c6_i0 : Int.int",
                    "c6_i : Int.int",
                    "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                    "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                    "c7_H : True",
                    "c7_i : Int64.int",
                    "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                    "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                    "c8_H : True",
                    "c8_f : float",
                    "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                    "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                    "c9_H : True",
                    "c9_f : float32",
                    "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                    "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                    "c10_H : True",
                    "c10_i : Ptrofs.int",
                    "c10_b0 : block"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                    "c3_H0 : eq (Val.maskzero_bool v n) (Some b)"
                ],
                "tactic_res": [
                    "c11_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero))\n  (Some (Int.eq (Int.and i n) Int.zero))"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "_global_iagree_and_eq : forall x y mask : Int.int,\n       iff (iagree x y mask) (eq (Int.and x mask) (Int.and y mask))",
                    "c3_H : vagree v w (I n)"
                ],
                "tactic_res": [
                    "c11_H : eq (Int.and i n) (Int.and i0 n)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c11_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero))\n  (Some (Int.eq (Int.and i n) Int.zero))",
                    "_global_1 : Z",
                    "c3_H : vagree v w (I n)"
                ],
                "tactic_res": [
                    "c12_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero))\n  (Some (Int.eq (Int.and i0 n) Int.zero))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c12_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero))\n  (Some (Int.eq (Int.and i0 n) Int.zero))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "normalize_sound",
        "proof": [
            {
                "tactic_sig": "Lemma normalize_sound : forall v w x ty , vagree v w x -> vagree ( Val.normalize v ty ) ( Val.normalize w ty ) x .",
                "tactic_sig_no_out_arg": "Lemma normalize_sound : forall v w x ty , vagree v w x -> vagree ( Val.normalize v ty ) ( Val.normalize w ty ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (x : nval) (ty : typ) (_ : vagree v w x),\nvagree (Val.normalize v ty) (Val.normalize w ty) x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (x : nval) (ty : typ) (_ : vagree v w x),\nvagree (Val.normalize v ty) (Val.normalize w ty) x"
                ],
                "tactic_res": [
                    "c2_goal : vagree (Val.normalize v ty) (Val.normalize w ty) x",
                    "c2_v : val",
                    "c2_w : val",
                    "c2_x : nval",
                    "c2_ty : typ",
                    "c2_H : vagree v w x"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c2_goal : vagree (Val.normalize v ty) (Val.normalize w ty) x",
                    "c2_x : nval"
                ],
                "tactic_res": [
                    "c3_goal : vagree (Val.normalize v ty) (Val.normalize w ty) Nothing",
                    "c3_H : vagree v w Nothing",
                    "c4_goal : vagree (Val.normalize v ty) (Val.normalize w ty) (I m)",
                    "c4_H : vagree v w (I m)",
                    "c4_m : Int.int",
                    "c5_goal : vagree (Val.normalize v ty) (Val.normalize w ty) All",
                    "c5_H : vagree v w All"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c3_goal : vagree (Val.normalize v ty) (Val.normalize w ty) Nothing"
                ],
                "tactic_res": [
                    "c6_goal : True",
                    "c6_H : True"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c4_goal : vagree (Val.normalize v ty) (Val.normalize w ty) (I m)"
                ],
                "tactic_res": [
                    "c7_goal : match Val.normalize v ty with\n| Vint p =>\n    match Val.normalize w ty with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c7_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c5_goal : vagree (Val.normalize v ty) (Val.normalize w ty) All"
                ],
                "tactic_res": [
                    "c8_goal : Val.lessdef (Val.normalize v ty) (Val.normalize w ty)",
                    "c8_H : Val.lessdef v w"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold Val.normalize .",
                "tactic_sig_no_out_arg": "unfold Val.normalize .",
                "tactic_args": [
                    "c7_goal : match Val.normalize v ty with\n| Vint p =>\n    match Val.normalize w ty with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c9_goal : match\n  match v with\n  | Vundef => Vundef\n  | Vint _ =>\n      match ty with\n      | Tfloat | Tlong | Tsingle => Vundef\n      | _ => v\n      end\n  | Vlong _ => match ty with\n               | Tlong | Tany64 => v\n               | _ => Vundef\n               end\n  | Vfloat _ => match ty with\n                | Tfloat | Tany64 => v\n                | _ => Vundef\n                end\n  | Vsingle _ =>\n      match ty with\n      | Tint | Tfloat | Tlong => Vundef\n      | _ => v\n      end\n  | Vptr _ _ =>\n      match ty with\n      | Tlong => if Archi.ptr64 then v else Vundef\n      | Tfloat | Tsingle => Vundef\n      | Tany64 => v\n      | _ => if Archi.ptr64 then Vundef else v\n      end\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ =>\n          match ty with\n          | Tlong | Tany64 => w\n          | _ => Vundef\n          end\n      | Vfloat _ =>\n          match ty with\n          | Tfloat | Tany64 => w\n          | _ => Vundef\n          end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c9_goal : match\n  match v with\n  | Vundef => Vundef\n  | Vint _ =>\n      match ty with\n      | Tfloat | Tlong | Tsingle => Vundef\n      | _ => v\n      end\n  | Vlong _ => match ty with\n               | Tlong | Tany64 => v\n               | _ => Vundef\n               end\n  | Vfloat _ => match ty with\n                | Tfloat | Tany64 => v\n                | _ => Vundef\n                end\n  | Vsingle _ =>\n      match ty with\n      | Tint | Tfloat | Tlong => Vundef\n      | _ => v\n      end\n  | Vptr _ _ =>\n      match ty with\n      | Tlong => if Archi.ptr64 then v else Vundef\n      | Tfloat | Tsingle => Vundef\n      | Tany64 => v\n      | _ => if Archi.ptr64 then Vundef else v\n      end\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ =>\n          match ty with\n          | Tlong | Tany64 => w\n          | _ => Vundef\n          end\n      | Vfloat _ =>\n          match ty with\n          | Tfloat | Tany64 => w\n          | _ => Vundef\n          end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c2_v : val"
                ],
                "tactic_res": [
                    "c10_goal : True",
                    "c10_H : True",
                    "c11_goal : match\n  match ty with\n  | Tfloat | Tlong | Tsingle => Vundef\n  | _ => Vint i\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ =>\n          match ty with\n          | Tlong | Tany64 => w\n          | _ => Vundef\n          end\n      | Vfloat _ =>\n          match ty with\n          | Tfloat | Tany64 => w\n          | _ => Vundef\n          end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c11_H : match w with\n| Vint q => iagree i q m\n| _ => False\nend",
                    "c11_i : Int.int",
                    "c12_goal : match match ty with\n      | Tlong | Tany64 => Vlong i\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ =>\n          match ty with\n          | Tlong | Tany64 => w\n          | _ => Vundef\n          end\n      | Vfloat _ =>\n          match ty with\n          | Tfloat | Tany64 => w\n          | _ => Vundef\n          end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c12_H : True",
                    "c12_i : Int64.int",
                    "c13_goal : match\n  match ty with\n  | Tfloat | Tany64 => Vfloat f\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ =>\n          match ty with\n          | Tlong | Tany64 => w\n          | _ => Vundef\n          end\n      | Vfloat _ =>\n          match ty with\n          | Tfloat | Tany64 => w\n          | _ => Vundef\n          end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c13_H : True",
                    "c13_f : float",
                    "c14_goal : match\n  match ty with\n  | Tint | Tfloat | Tlong => Vundef\n  | _ => Vsingle f\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ =>\n          match ty with\n          | Tlong | Tany64 => w\n          | _ => Vundef\n          end\n      | Vfloat _ =>\n          match ty with\n          | Tfloat | Tany64 => w\n          | _ => Vundef\n          end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c14_H : True",
                    "c14_f : float32",
                    "c15_goal : match\n  match ty with\n  | Tlong => if Archi.ptr64 then Vptr b i else Vundef\n  | Tfloat | Tsingle => Vundef\n  | Tany64 => Vptr b i\n  | _ => if Archi.ptr64 then Vundef else Vptr b i\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ =>\n          match ty with\n          | Tlong | Tany64 => w\n          | _ => Vundef\n          end\n      | Vfloat _ =>\n          match ty with\n          | Tfloat | Tany64 => w\n          | _ => Vundef\n          end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c15_H : True",
                    "c15_i : Ptrofs.int",
                    "c15_b : block"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c11_goal : match\n  match ty with\n  | Tfloat | Tlong | Tsingle => Vundef\n  | _ => Vint i\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ =>\n          match ty with\n          | Tlong | Tany64 => w\n          | _ => Vundef\n          end\n      | Vfloat _ =>\n          match ty with\n          | Tfloat | Tany64 => w\n          | _ => Vundef\n          end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c2_w : val"
                ],
                "tactic_res": [
                    "c16_goal : match\n  match ty with\n  | Tfloat | Tlong | Tsingle => Vundef\n  | _ => Vint i\n  end\nwith\n| Vint _ => False\n| _ => True\nend",
                    "c16_H : False",
                    "c17_goal : match\n  match ty with\n  | Tfloat | Tlong | Tsingle => Vundef\n  | _ => Vint i\n  end\nwith\n| Vint p =>\n    match\n      match ty with\n      | Tfloat | Tlong | Tsingle => Vundef\n      | _ => Vint i0\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c17_H : iagree i i0 m",
                    "c17_i0 : Int.int",
                    "c18_goal : match\n  match ty with\n  | Tfloat | Tlong | Tsingle => Vundef\n  | _ => Vint i\n  end\nwith\n| Vint p =>\n    match\n      match ty with\n      | Tlong | Tany64 => Vlong i0\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c18_H : False",
                    "c18_i0 : Int64.int",
                    "c19_goal : match\n  match ty with\n  | Tfloat | Tlong | Tsingle => Vundef\n  | _ => Vint i\n  end\nwith\n| Vint p =>\n    match\n      match ty with\n      | Tfloat | Tany64 => Vfloat f\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c19_H : False",
                    "c19_f : float",
                    "c20_goal : match\n  match ty with\n  | Tfloat | Tlong | Tsingle => Vundef\n  | _ => Vint i\n  end\nwith\n| Vint p =>\n    match\n      match ty with\n      | Tint | Tfloat | Tlong => Vundef\n      | _ => Vsingle f\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c20_H : False",
                    "c20_f : float32",
                    "c21_goal : match\n  match ty with\n  | Tfloat | Tlong | Tsingle => Vundef\n  | _ => Vint i\n  end\nwith\n| Vint p =>\n    match\n      match ty with\n      | Tlong => if Archi.ptr64 then Vptr b i0 else Vundef\n      | Tfloat | Tsingle => Vundef\n      | Tany64 => Vptr b i0\n      | _ => if Archi.ptr64 then Vundef else Vptr b i0\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c21_H : False",
                    "c21_i0 : Ptrofs.int",
                    "c21_b : block"
                ]
            },
            {
                "tactic_sig": "try contradiction .",
                "tactic_sig_no_out_arg": "try contradiction .",
                "tactic_args": [
                    "c16_goal : match\n  match ty with\n  | Tfloat | Tlong | Tsingle => Vundef\n  | _ => Vint i\n  end\nwith\n| Vint _ => False\n| _ => True\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try contradiction .",
                "tactic_sig_no_out_arg": "try contradiction .",
                "tactic_args": [
                    "c18_goal : match\n  match ty with\n  | Tfloat | Tlong | Tsingle => Vundef\n  | _ => Vint i\n  end\nwith\n| Vint p =>\n    match\n      match ty with\n      | Tlong | Tany64 => Vlong i0\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try contradiction .",
                "tactic_sig_no_out_arg": "try contradiction .",
                "tactic_args": [
                    "c19_goal : match\n  match ty with\n  | Tfloat | Tlong | Tsingle => Vundef\n  | _ => Vint i\n  end\nwith\n| Vint p =>\n    match\n      match ty with\n      | Tfloat | Tany64 => Vfloat f\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try contradiction .",
                "tactic_sig_no_out_arg": "try contradiction .",
                "tactic_args": [
                    "c20_goal : match\n  match ty with\n  | Tfloat | Tlong | Tsingle => Vundef\n  | _ => Vint i\n  end\nwith\n| Vint p =>\n    match\n      match ty with\n      | Tint | Tfloat | Tlong => Vundef\n      | _ => Vsingle f\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try contradiction .",
                "tactic_sig_no_out_arg": "try contradiction .",
                "tactic_args": [
                    "c21_goal : match\n  match ty with\n  | Tfloat | Tlong | Tsingle => Vundef\n  | _ => Vint i\n  end\nwith\n| Vint p =>\n    match\n      match ty with\n      | Tlong => if Archi.ptr64 then Vptr b i0 else Vundef\n      | Tfloat | Tsingle => Vundef\n      | Tany64 => Vptr b i0\n      | _ => if Archi.ptr64 then Vundef else Vptr b i0\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  | | | | | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c17_goal : match\n  match ty with\n  | Tfloat | Tlong | Tsingle => Vundef\n  | _ => Vint i\n  end\nwith\n| Vint p =>\n    match\n      match ty with\n      | Tfloat | Tlong | Tsingle => Vundef\n      | _ => Vint i0\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c2_ty : typ"
                ],
                "tactic_res": [
                    "c22_goal : iagree i i0 m",
                    "c23_goal : True",
                    "c24_goal : True",
                    "c25_goal : True",
                    "c26_goal : iagree i i0 m",
                    "c27_goal : iagree i i0 m"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c22_goal : iagree i i0 m"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c23_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c24_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c26_goal : iagree i i0 m"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c27_goal : iagree i i0 m"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  | | | | | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c12_goal : match match ty with\n      | Tlong | Tany64 => Vlong i\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ =>\n          match ty with\n          | Tlong | Tany64 => w\n          | _ => Vundef\n          end\n      | Vfloat _ =>\n          match ty with\n          | Tfloat | Tany64 => w\n          | _ => Vundef\n          end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c2_ty : typ"
                ],
                "tactic_res": [
                    "c28_goal : True",
                    "c29_goal : True",
                    "c30_goal : True",
                    "c31_goal : True",
                    "c32_goal : True",
                    "c33_goal : True"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c28_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c29_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c30_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c31_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c32_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c33_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  | | | | | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c13_goal : match\n  match ty with\n  | Tfloat | Tany64 => Vfloat f\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ =>\n          match ty with\n          | Tlong | Tany64 => w\n          | _ => Vundef\n          end\n      | Vfloat _ =>\n          match ty with\n          | Tfloat | Tany64 => w\n          | _ => Vundef\n          end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c2_ty : typ"
                ],
                "tactic_res": [
                    "c34_goal : True",
                    "c35_goal : True",
                    "c36_goal : True",
                    "c37_goal : True",
                    "c38_goal : True",
                    "c39_goal : True"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c34_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c35_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c36_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c37_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c38_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c39_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  | | | | | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c14_goal : match\n  match ty with\n  | Tint | Tfloat | Tlong => Vundef\n  | _ => Vsingle f\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ =>\n          match ty with\n          | Tlong | Tany64 => w\n          | _ => Vundef\n          end\n      | Vfloat _ =>\n          match ty with\n          | Tfloat | Tany64 => w\n          | _ => Vundef\n          end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c2_ty : typ"
                ],
                "tactic_res": [
                    "c40_goal : True",
                    "c41_goal : True",
                    "c42_goal : True",
                    "c43_goal : True",
                    "c44_goal : True",
                    "c45_goal : True"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c40_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c41_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c42_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c43_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c44_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c45_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  | | | | | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c15_goal : match\n  match ty with\n  | Tlong => if Archi.ptr64 then Vptr b i else Vundef\n  | Tfloat | Tsingle => Vundef\n  | Tany64 => Vptr b i\n  | _ => if Archi.ptr64 then Vundef else Vptr b i\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ =>\n          match ty with\n          | Tlong | Tany64 => w\n          | _ => Vundef\n          end\n      | Vfloat _ =>\n          match ty with\n          | Tfloat | Tany64 => w\n          | _ => Vundef\n          end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c2_ty : typ"
                ],
                "tactic_res": [
                    "c46_goal : match (if Archi.ptr64 then Vundef else Vptr b i) with\n| Vint p =>\n    match\n      match w with\n      | Vint _ => w\n      | Vptr _ _ => if Archi.ptr64 then Vundef else w\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c47_goal : True",
                    "c48_goal : match (if Archi.ptr64 then Vptr b i else Vundef) with\n| Vint p =>\n    match\n      match w with\n      | Vlong _ => w\n      | Vptr _ _ => if Archi.ptr64 then w else Vundef\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c49_goal : True",
                    "c50_goal : match (if Archi.ptr64 then Vundef else Vptr b i) with\n| Vint p =>\n    match\n      match w with\n      | Vint _ | Vsingle _ => w\n      | Vptr _ _ => if Archi.ptr64 then Vundef else w\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                    "c51_goal : True"
                ]
            },
            {
                "tactic_sig": "destruct Archi.ptr64 as [  | ] .",
                "tactic_sig_no_out_arg": "destruct Archi.ptr64 .",
                "tactic_args": [
                    "c46_goal : match (if Archi.ptr64 then Vundef else Vptr b i) with\n| Vint p =>\n    match\n      match w with\n      | Vint _ => w\n      | Vptr _ _ => if Archi.ptr64 then Vundef else w\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c52_goal : True",
                    "c53_goal : True"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c52_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c53_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct Archi.ptr64 as [  | ] .",
                "tactic_sig_no_out_arg": "destruct Archi.ptr64 .",
                "tactic_args": [
                    "c47_goal : True"
                ],
                "tactic_res": [
                    "c54_goal : True",
                    "c55_goal : True"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c54_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c55_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct Archi.ptr64 as [  | ] .",
                "tactic_sig_no_out_arg": "destruct Archi.ptr64 .",
                "tactic_args": [
                    "c48_goal : match (if Archi.ptr64 then Vptr b i else Vundef) with\n| Vint p =>\n    match\n      match w with\n      | Vlong _ => w\n      | Vptr _ _ => if Archi.ptr64 then w else Vundef\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c56_goal : True",
                    "c57_goal : True"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c56_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c57_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct Archi.ptr64 as [  | ] .",
                "tactic_sig_no_out_arg": "destruct Archi.ptr64 .",
                "tactic_args": [
                    "c49_goal : True"
                ],
                "tactic_res": [
                    "c58_goal : True",
                    "c59_goal : True"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c58_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c59_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct Archi.ptr64 as [  | ] .",
                "tactic_sig_no_out_arg": "destruct Archi.ptr64 .",
                "tactic_args": [
                    "c50_goal : match (if Archi.ptr64 then Vundef else Vptr b i) with\n| Vint p =>\n    match\n      match w with\n      | Vint _ | Vsingle _ => w\n      | Vptr _ _ => if Archi.ptr64 then Vundef else w\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c60_goal : True",
                    "c61_goal : True"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c60_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c61_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct Archi.ptr64 as [  | ] .",
                "tactic_sig_no_out_arg": "destruct Archi.ptr64 .",
                "tactic_args": [
                    "c51_goal : True"
                ],
                "tactic_res": [
                    "c62_goal : True",
                    "c63_goal : True"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c62_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c63_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply Val.normalize_lessdef .",
                "tactic_sig_no_out_arg": "apply Val.normalize_lessdef .",
                "tactic_args": [
                    "c8_goal : Val.lessdef (Val.normalize v ty) (Val.normalize w ty)",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c64_goal : Val.lessdef v w"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c64_goal : Val.lessdef v w"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "select_sound",
        "proof": [
            {
                "tactic_sig": "Lemma select_sound : forall ob v1 v2 w1 w2 ty x , vagree v1 w1 x -> vagree v2 w2 x -> vagree ( Val.select ob v1 v2 ty ) ( Val.select ob w1 w2 ty ) x .",
                "tactic_sig_no_out_arg": "Lemma select_sound : forall ob v1 v2 w1 w2 ty x , vagree v1 w1 x -> vagree v2 w2 x -> vagree ( Val.select ob v1 v2 ty ) ( Val.select ob w1 w2 ty ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (ob : option bool) (v1 v2 w1 w2 : val) (ty : typ) \n  (x : nval) (_ : vagree v1 w1 x) (_ : vagree v2 w2 x),\nvagree (Val.select ob v1 v2 ty) (Val.select ob w1 w2 ty) x"
                ]
            },
            {
                "tactic_sig": "unfold Val._i .",
                "tactic_sig_no_out_arg": "unfold Val._i .",
                "tactic_args": [
                    "c1_goal : forall (ob : option bool) (v1 v2 w1 w2 : val) (ty : typ) \n  (x : nval) (_ : vagree v1 w1 x) (_ : vagree v2 w2 x),\nvagree (Val.select ob v1 v2 ty) (Val.select ob w1 w2 ty) x",
                    "_global_1 : Z",
                    "_global_select : forall (_ : abool) (_ : aval) (_ : aval), aval"
                ],
                "tactic_res": [
                    "c2_goal : forall (ob : option bool) (v1 v2 w1 w2 : val) (ty : typ) \n  (x : nval) (_ : vagree v1 w1 x) (_ : vagree v2 w2 x),\nvagree\n  match ob with\n  | Some b => Val.normalize (if b then v1 else v2) ty\n  | None => Vundef\n  end\n  match ob with\n  | Some b => Val.normalize (if b then w1 else w2) ty\n  | None => Vundef\n  end x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (ob : option bool) (v1 v2 w1 w2 : val) (ty : typ) \n  (x : nval) (_ : vagree v1 w1 x) (_ : vagree v2 w2 x),\nvagree\n  match ob with\n  | Some b => Val.normalize (if b then v1 else v2) ty\n  | None => Vundef\n  end\n  match ob with\n  | Some b => Val.normalize (if b then w1 else w2) ty\n  | None => Vundef\n  end x"
                ],
                "tactic_res": [
                    "c3_goal : vagree\n  match ob with\n  | Some b => Val.normalize (if b then v1 else v2) ty\n  | None => Vundef\n  end\n  match ob with\n  | Some b => Val.normalize (if b then w1 else w2) ty\n  | None => Vundef\n  end x",
                    "c3_ob : option bool",
                    "c3_v1 : val",
                    "c3_v2 : val",
                    "c3_w1 : val",
                    "c3_w2 : val",
                    "c3_ty : typ",
                    "c3_x : nval",
                    "c3_H : vagree v1 w1 x",
                    "c3_H0 : vagree v2 w2 x"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ b| ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ b| ] .",
                "tactic_args": [
                    "c3_goal : vagree\n  match ob with\n  | Some b => Val.normalize (if b then v1 else v2) ty\n  | None => Vundef\n  end\n  match ob with\n  | Some b => Val.normalize (if b then w1 else w2) ty\n  | None => Vundef\n  end x",
                    "c3_ob : option bool"
                ],
                "tactic_res": [
                    "c4_goal : vagree (Val.normalize (if b then v1 else v2) ty)\n  (Val.normalize (if b then w1 else w2) ty) x",
                    "c4_b : bool",
                    "c5_goal : vagree Vundef Vundef x"
                ]
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c5_goal : vagree Vundef Vundef x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : vagree (Val.normalize (if b then v1 else v2) ty)\n  (Val.normalize (if b then w1 else w2) ty) x",
                    "_global_1 : Z",
                    "_global_normalize_sound : forall (v w : val) (x : nval) (ty : typ) (_ : vagree v w x),\n       vagree (Val.normalize v ty) (Val.normalize w ty) x"
                ],
                "tactic_res": [
                    "c6_goal : vagree (if b then v1 else v2) (if b then w1 else w2) x"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c6_goal : vagree (if b then v1 else v2) (if b then w1 else w2) x",
                    "c4_b : bool"
                ],
                "tactic_res": [
                    "c7_goal : vagree v1 w1 x",
                    "c8_goal : vagree v2 w2 x"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : vagree v1 w1 x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : vagree v2 w2 x"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "valid_pointer_inj",
        "proof": [
            {
                "tactic_sig": "Let valid_pointer_inj : forall b1 ofs b2 delta , inject_id b1 = Some ( b2 , delta ) -> Mem.valid_pointer m1 b1 ( Ptrofs.unsigned ofs ) = true -> Mem.valid_pointer m2 b2 ( Ptrofs.unsigned ( Ptrofs.add ofs ( Ptrofs.repr delta ) ) ) = true .",
                "tactic_sig_no_out_arg": "Let valid_pointer_inj : forall b1 ofs b2 delta , inject_id b1 = Some ( b2 , delta ) -> Mem.valid_pointer m1 b1 ( Ptrofs.unsigned ofs ) = true -> Mem.valid_pointer m2 b2 ( Ptrofs.unsigned ( Ptrofs.add ofs ( Ptrofs.repr delta ) ) ) = true .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true",
                    "c1_PERM : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission)\n  (_ : Mem.perm m1 b ofs k p), Mem.perm m2 b ofs k p",
                    "c1_m2 : Mem.mem",
                    "c1_m1 : Mem.mem",
                    "c1_sp : block",
                    "c1_ge : genv"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true",
                    "_global_1 : Z",
                    "_global_inject_id : Val.meminj"
                ],
                "tactic_res": [
                    "c2_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (Some (pair b1 0)) (Some (pair b2 delta)))\n  (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (Some (pair b1 0)) (Some (pair b2 delta)))\n  (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true"
                ],
                "tactic_res": [
                    "c3_goal : eq\n  (Mem.valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true",
                    "c3_b1 : block",
                    "c3_ofs : Ptrofs.int",
                    "c3_b2 : block",
                    "c3_delta : Z",
                    "c3_H : eq (Some (pair b1 0)) (Some (pair b2 delta))",
                    "c3_H0 : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c3_goal : eq\n  (Mem.valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true",
                    "c3_H : eq (Some (pair b1 0)) (Some (pair b2 delta))"
                ],
                "tactic_res": [
                    "c4_goal : eq\n  (Mem.valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr 0)))) true",
                    "c4_H0 : eq (Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs)) true"
                ]
            },
            {
                "tactic_sig": "rewrite Ptrofs.add_zero .",
                "tactic_sig_no_out_arg": "rewrite Ptrofs.add_zero .",
                "tactic_args": [
                    "c4_goal : eq\n  (Mem.valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr 0)))) true",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c5_goal : eq (Mem.valid_pointer m2 b2 (Ptrofs.unsigned ofs)) true"
                ]
            },
            {
                "tactic_sig": "rewrite Mem.valid_pointer_nonempty_perm in * .",
                "tactic_sig_no_out_arg": "rewrite Mem.valid_pointer_nonempty_perm in * .",
                "tactic_args": [
                    "c5_goal : eq (Mem.valid_pointer m2 b2 (Ptrofs.unsigned ofs)) true",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c6_goal : Mem.perm m2 b2 (Ptrofs.unsigned ofs) Cur Nonempty",
                    "c6_H0 : Mem.perm m1 b2 (Ptrofs.unsigned ofs) Cur Nonempty"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c6_goal : Mem.perm m2 b2 (Ptrofs.unsigned ofs) Cur Nonempty"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "weak_valid_pointer_inj",
        "proof": [
            {
                "tactic_sig": "Let weak_valid_pointer_inj : forall b1 ofs b2 delta , inject_id b1 = Some ( b2 , delta ) -> Mem.weak_valid_pointer m1 b1 ( Ptrofs.unsigned ofs ) = true -> Mem.weak_valid_pointer m2 b2 ( Ptrofs.unsigned ( Ptrofs.add ofs ( Ptrofs.repr delta ) ) ) = true .",
                "tactic_sig_no_out_arg": "Let weak_valid_pointer_inj : forall b1 ofs b2 delta , inject_id b1 = Some ( b2 , delta ) -> Mem.weak_valid_pointer m1 b1 ( Ptrofs.unsigned ofs ) = true -> Mem.weak_valid_pointer m2 b2 ( Ptrofs.unsigned ( Ptrofs.add ofs ( Ptrofs.repr delta ) ) ) = true .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.weak_valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true",
                    "c1_valid_pointer_inj : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true",
                    "c1_PERM : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission)\n  (_ : Mem.perm m1 b ofs k p), Mem.perm m2 b ofs k p",
                    "c1_m2 : Mem.mem",
                    "c1_m1 : Mem.mem",
                    "c1_sp : block",
                    "c1_ge : genv"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.weak_valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true",
                    "_global_1 : Z",
                    "_global_inject_id : Val.meminj"
                ],
                "tactic_res": [
                    "c2_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (Some (pair b1 0)) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.weak_valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (Some (pair b1 0)) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.weak_valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true"
                ],
                "tactic_res": [
                    "c3_goal : eq\n  (Mem.weak_valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true",
                    "c3_b1 : block",
                    "c3_ofs : Ptrofs.int",
                    "c3_b2 : block",
                    "c3_delta : Z",
                    "c3_H : eq (Some (pair b1 0)) (Some (pair b2 delta))",
                    "c3_H0 : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c3_goal : eq\n  (Mem.weak_valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true",
                    "c3_H : eq (Some (pair b1 0)) (Some (pair b2 delta))"
                ],
                "tactic_res": [
                    "c4_goal : eq\n  (Mem.weak_valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr 0)))) true",
                    "c4_H0 : eq (Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs)) true"
                ]
            },
            {
                "tactic_sig": "rewrite Ptrofs.add_zero .",
                "tactic_sig_no_out_arg": "rewrite Ptrofs.add_zero .",
                "tactic_args": [
                    "c4_goal : eq\n  (Mem.weak_valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr 0)))) true",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c5_goal : eq (Mem.weak_valid_pointer m2 b2 (Ptrofs.unsigned ofs)) true"
                ]
            },
            {
                "tactic_sig": "rewrite Mem.weak_valid_pointer_spec in * .",
                "tactic_sig_no_out_arg": "rewrite Mem.weak_valid_pointer_spec in * .",
                "tactic_args": [
                    "c5_goal : eq (Mem.weak_valid_pointer m2 b2 (Ptrofs.unsigned ofs)) true",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c6_goal : Logic.or (eq (Mem.valid_pointer m2 b2 (Ptrofs.unsigned ofs)) true)\n  (eq (Mem.valid_pointer m2 b2 (Z.sub (Ptrofs.unsigned ofs) 1)) true)",
                    "c6_H0 : Logic.or (eq (Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs)) true)\n  (eq (Mem.valid_pointer m1 b2 (Z.sub (Ptrofs.unsigned ofs) 1)) true)"
                ]
            },
            {
                "tactic_sig": "rewrite ! Mem.valid_pointer_nonempty_perm in * .",
                "tactic_sig_no_out_arg": "rewrite ! Mem.valid_pointer_nonempty_perm in * .",
                "tactic_args": [
                    "c6_goal : Logic.or (eq (Mem.valid_pointer m2 b2 (Ptrofs.unsigned ofs)) true)\n  (eq (Mem.valid_pointer m2 b2 (Z.sub (Ptrofs.unsigned ofs) 1)) true)",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c7_goal : Logic.or (Mem.perm m2 b2 (Ptrofs.unsigned ofs) Cur Nonempty)\n  (Mem.perm m2 b2 (Z.sub (Ptrofs.unsigned ofs) 1) Cur Nonempty)",
                    "c7_H0 : Logic.or (Mem.perm m1 b2 (Ptrofs.unsigned ofs) Cur Nonempty)\n  (Mem.perm m1 b2 (Z.sub (Ptrofs.unsigned ofs) 1) Cur Nonempty)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c7_goal : Logic.or (Mem.perm m2 b2 (Ptrofs.unsigned ofs) Cur Nonempty)\n  (Mem.perm m2 b2 (Z.sub (Ptrofs.unsigned ofs) 1) Cur Nonempty)",
                    "c3_H0 : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true"
                ],
                "tactic_res": [
                    "c8_goal : Logic.or (Mem.perm m2 b2 (Ptrofs.unsigned ofs) Cur Nonempty)\n  (Mem.perm m2 b2 (Z.sub (Ptrofs.unsigned ofs) 1) Cur Nonempty)",
                    "c8_H : Mem.perm m1 b2 (Ptrofs.unsigned ofs) Cur Nonempty",
                    "c9_goal : Logic.or (Mem.perm m2 b2 (Ptrofs.unsigned ofs) Cur Nonempty)\n  (Mem.perm m2 b2 (Z.sub (Ptrofs.unsigned ofs) 1) Cur Nonempty)",
                    "c9_H : Mem.perm m1 b2 (Z.sub (Ptrofs.unsigned ofs) 1) Cur Nonempty"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c8_goal : Logic.or (Mem.perm m2 b2 (Ptrofs.unsigned ofs) Cur Nonempty)\n  (Mem.perm m2 b2 (Z.sub (Ptrofs.unsigned ofs) 1) Cur Nonempty)"
                ],
                "tactic_res": [
                    "c10_goal : Mem.perm m2 b2 (Ptrofs.unsigned ofs) Cur Nonempty"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c10_goal : Mem.perm m2 b2 (Ptrofs.unsigned ofs) Cur Nonempty"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "c9_goal : Logic.or (Mem.perm m2 b2 (Ptrofs.unsigned ofs) Cur Nonempty)\n  (Mem.perm m2 b2 (Z.sub (Ptrofs.unsigned ofs) 1) Cur Nonempty)"
                ],
                "tactic_res": [
                    "c11_goal : Mem.perm m2 b2 (Z.sub (Ptrofs.unsigned ofs) 1) Cur Nonempty"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c11_goal : Mem.perm m2 b2 (Z.sub (Ptrofs.unsigned ofs) 1) Cur Nonempty"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "weak_valid_pointer_no_overflow",
        "proof": [
            {
                "tactic_sig": "Let weak_valid_pointer_no_overflow : forall b1 ofs b2 delta , inject_id b1 = Some ( b2 , delta ) -> Mem.weak_valid_pointer m1 b1 ( Ptrofs.unsigned ofs ) = true -> 0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned ( Ptrofs.repr delta ) <= Ptrofs.max_unsigned .",
                "tactic_sig_no_out_arg": "Let weak_valid_pointer_no_overflow : forall b1 ofs b2 delta , inject_id b1 = Some ( b2 , delta ) -> Mem.weak_valid_pointer m1 b1 ( Ptrofs.unsigned ofs ) = true -> 0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned ( Ptrofs.repr delta ) <= Ptrofs.max_unsigned .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\nLogic.and\n  (Z.le 0\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta))))\n  (Z.le\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta)))\n     Ptrofs.max_unsigned)",
                    "c1_weak_valid_pointer_inj : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.weak_valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true",
                    "c1_valid_pointer_inj : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true",
                    "c1_PERM : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission)\n  (_ : Mem.perm m1 b ofs k p), Mem.perm m2 b ofs k p",
                    "c1_m2 : Mem.mem",
                    "c1_m1 : Mem.mem",
                    "c1_sp : block",
                    "c1_ge : genv"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\nLogic.and\n  (Z.le 0\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta))))\n  (Z.le\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta)))\n     Ptrofs.max_unsigned)",
                    "_global_1 : Z",
                    "_global_inject_id : Val.meminj"
                ],
                "tactic_res": [
                    "c2_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (Some (pair b1 0)) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\nLogic.and\n  (Z.le 0\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta))))\n  (Z.le\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta)))\n     Ptrofs.max_unsigned)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (Some (pair b1 0)) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\nLogic.and\n  (Z.le 0\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta))))\n  (Z.le\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta)))\n     Ptrofs.max_unsigned)"
                ],
                "tactic_res": [
                    "c3_goal : Logic.and\n  (Z.le 0\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta))))\n  (Z.le\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta)))\n     Ptrofs.max_unsigned)",
                    "c3_b1 : block",
                    "c3_ofs : Ptrofs.int",
                    "c3_b2 : block",
                    "c3_delta : Z",
                    "c3_H : eq (Some (pair b1 0)) (Some (pair b2 delta))",
                    "c3_H0 : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c3_goal : Logic.and\n  (Z.le 0\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta))))\n  (Z.le\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta)))\n     Ptrofs.max_unsigned)",
                    "c3_H : eq (Some (pair b1 0)) (Some (pair b2 delta))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.and\n  (Z.le 0\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr 0))))\n  (Z.le (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr 0)))\n     Ptrofs.max_unsigned)",
                    "c4_H0 : eq (Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs)) true"
                ]
            },
            {
                "tactic_sig": "rewrite _i.add_0_r .",
                "tactic_sig_no_out_arg": "rewrite _i.add_0_r .",
                "tactic_args": [
                    "c4_goal : Logic.and\n  (Z.le 0\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr 0))))\n  (Z.le (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr 0)))\n     Ptrofs.max_unsigned)",
                    "_global_1 : Z",
                    "_global_Z : Set"
                ],
                "tactic_res": [
                    "c5_goal : Logic.and (Z.le 0 (Ptrofs.unsigned ofs))\n  (Z.le (Ptrofs.unsigned ofs) Ptrofs.max_unsigned)"
                ]
            },
            {
                "tactic_sig": "apply Ptrofs.unsigned_range_2 .",
                "tactic_sig_no_out_arg": "apply Ptrofs.unsigned_range_2 .",
                "tactic_args": [
                    "c5_goal : Logic.and (Z.le 0 (Ptrofs.unsigned ofs))\n  (Z.le (Ptrofs.unsigned ofs) Ptrofs.max_unsigned)",
                    "_global_1 : Z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "valid_different_pointers_inj",
        "proof": [
            {
                "tactic_sig": "Let valid_different_pointers_inj : forall b1 ofs1 b2 ofs2 b1' delta1 b2' delta2 , b1 <> b2 -> Mem.valid_pointer m1 b1 ( Ptrofs.unsigned ofs1 ) = true -> Mem.valid_pointer m1 b2 ( Ptrofs.unsigned ofs2 ) = true -> inject_id b1 = Some ( b1' , delta1 ) -> inject_id b2 = Some ( b2' , delta2 ) -> b1' <> b2' \\/ Ptrofs.unsigned ( Ptrofs.add ofs1 ( Ptrofs.repr delta1 ) ) <> Ptrofs.unsigned ( Ptrofs.add ofs2 ( Ptrofs.repr delta2 ) ) .",
                "tactic_sig_no_out_arg": "Let valid_different_pointers_inj : forall b1 ofs1 b2 ofs2 b1' delta1 b2' delta2 , b1 <> b2 -> Mem.valid_pointer m1 b1 ( Ptrofs.unsigned ofs1 ) = true -> Mem.valid_pointer m1 b2 ( Ptrofs.unsigned ofs2 ) = true -> inject_id b1 = Some ( b1' , delta1 ) -> inject_id b2 = Some ( b2' , delta2 ) -> b1' <> b2' \\/ Ptrofs.unsigned ( Ptrofs.add ofs1 ( Ptrofs.repr delta1 ) ) <> Ptrofs.unsigned ( Ptrofs.add ofs2 ( Ptrofs.repr delta2 ) ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (b1 : block) (ofs1 : Ptrofs.int) (b2 : block)\n  (ofs2 : Ptrofs.int) (b1' : block) (delta1 : Z) (b2' : block)\n  (delta2 : Z) (_ : not (eq b1 b2))\n  (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1)) true)\n  (_ : eq (Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2)) true)\n  (_ : eq (inject_id b1) (Some (pair b1' delta1)))\n  (_ : eq (inject_id b2) (Some (pair b2' delta2))),\nLogic.or (not (eq b1' b2'))\n  (not\n     (eq (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)))\n        (Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)))))",
                    "c1_weak_valid_pointer_no_overflow : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\nLogic.and\n  (Z.le 0\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta))))\n  (Z.le\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta)))\n     Ptrofs.max_unsigned)",
                    "c1_weak_valid_pointer_inj : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.weak_valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true",
                    "c1_valid_pointer_inj : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true",
                    "c1_PERM : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission)\n  (_ : Mem.perm m1 b ofs k p), Mem.perm m2 b ofs k p",
                    "c1_m2 : Mem.mem",
                    "c1_m1 : Mem.mem",
                    "c1_sp : block",
                    "c1_ge : genv"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (b1 : block) (ofs1 : Ptrofs.int) (b2 : block)\n  (ofs2 : Ptrofs.int) (b1' : block) (delta1 : Z) (b2' : block)\n  (delta2 : Z) (_ : not (eq b1 b2))\n  (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1)) true)\n  (_ : eq (Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2)) true)\n  (_ : eq (inject_id b1) (Some (pair b1' delta1)))\n  (_ : eq (inject_id b2) (Some (pair b2' delta2))),\nLogic.or (not (eq b1' b2'))\n  (not\n     (eq (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)))\n        (Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)))))",
                    "_global_1 : Z",
                    "_global_inject_id : Val.meminj"
                ],
                "tactic_res": [
                    "c2_goal : forall (b1 : block) (ofs1 : Ptrofs.int) (b2 : block)\n  (ofs2 : Ptrofs.int) (b1' : block) (delta1 : Z) (b2' : block)\n  (delta2 : Z) (_ : not (eq b1 b2))\n  (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1)) true)\n  (_ : eq (Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2)) true)\n  (_ : eq (Some (pair b1 0)) (Some (pair b1' delta1)))\n  (_ : eq (Some (pair b2 0)) (Some (pair b2' delta2))),\nLogic.or (not (eq b1' b2'))\n  (not\n     (eq (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)))\n        (Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (b1 : block) (ofs1 : Ptrofs.int) (b2 : block)\n  (ofs2 : Ptrofs.int) (b1' : block) (delta1 : Z) (b2' : block)\n  (delta2 : Z) (_ : not (eq b1 b2))\n  (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1)) true)\n  (_ : eq (Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2)) true)\n  (_ : eq (Some (pair b1 0)) (Some (pair b1' delta1)))\n  (_ : eq (Some (pair b2 0)) (Some (pair b2' delta2))),\nLogic.or (not (eq b1' b2'))\n  (not\n     (eq (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)))\n        (Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)))))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.or (not (eq b1' b2'))\n  (not\n     (eq (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)))\n        (Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)))))",
                    "c3_b1 : block",
                    "c3_ofs1 : Ptrofs.int",
                    "c3_b2 : block",
                    "c3_ofs2 : Ptrofs.int",
                    "c3_b1' : block",
                    "c3_delta1 : Z",
                    "c3_b2' : block",
                    "c3_delta2 : Z",
                    "c3_H : not (eq b1 b2)",
                    "c3_H0 : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1)) true",
                    "c3_H1 : eq (Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2)) true",
                    "c3_H2 : eq (Some (pair b1 0)) (Some (pair b1' delta1))",
                    "c3_H3 : eq (Some (pair b2 0)) (Some (pair b2' delta2))"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "c3_goal : Logic.or (not (eq b1' b2'))\n  (not\n     (eq (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)))\n        (Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)))))"
                ],
                "tactic_res": [
                    "c4_goal : not (eq b1' b2')"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c4_goal : not (eq b1' b2')"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "default_needs_of_condition_sound",
        "proof": [
            {
                "tactic_sig": "Lemma default_needs_of_condition_sound : forall cond args1 b args2 , eval_condition cond args1 m1 = Some b -> vagree_list args1 args2 nil -> eval_condition cond args2 m2 = Some b .",
                "tactic_sig_no_out_arg": "Lemma default_needs_of_condition_sound : forall cond args1 b args2 , eval_condition cond args1 m1 = Some b -> vagree_list args1 args2 nil -> eval_condition cond args2 m2 = Some b .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (cond : condition) (args1 : list val) (b : bool)\n  (args2 : list val) (_ : eq (eval_condition cond args1 m1) (Some b))\n  (_ : vagree_list args1 args2 nil),\neq (eval_condition cond args2 m2) (Some b)",
                    "c1_valid_different_pointers_inj : forall (b1 : block) (ofs1 : Ptrofs.int) (b2 : block)\n  (ofs2 : Ptrofs.int) (b1' : block) (delta1 : Z) (b2' : block)\n  (delta2 : Z) (_ : not (eq b1 b2))\n  (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1)) true)\n  (_ : eq (Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2)) true)\n  (_ : eq (inject_id b1) (Some (pair b1' delta1)))\n  (_ : eq (inject_id b2) (Some (pair b2' delta2))),\nLogic.or (not (eq b1' b2'))\n  (not\n     (eq (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)))\n        (Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)))))",
                    "c1_weak_valid_pointer_no_overflow : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\nLogic.and\n  (Z.le 0\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta))))\n  (Z.le\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta)))\n     Ptrofs.max_unsigned)",
                    "c1_weak_valid_pointer_inj : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.weak_valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true",
                    "c1_valid_pointer_inj : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true",
                    "c1_PERM : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission)\n  (_ : Mem.perm m1 b ofs k p), Mem.perm m2 b ofs k p",
                    "c1_m2 : Mem.mem",
                    "c1_m1 : Mem.mem",
                    "c1_sp : block",
                    "c1_ge : genv"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (cond : condition) (args1 : list val) (b : bool)\n  (args2 : list val) (_ : eq (eval_condition cond args1 m1) (Some b))\n  (_ : vagree_list args1 args2 nil),\neq (eval_condition cond args2 m2) (Some b)"
                ],
                "tactic_res": [
                    "c2_goal : eq (eval_condition cond args2 m2) (Some b)",
                    "c2_cond : condition",
                    "c2_args1 : list val",
                    "c2_b : bool",
                    "c2_args2 : list val",
                    "c2_H : eq (eval_condition cond args1 m1) (Some b)",
                    "c2_H0 : vagree_list args1 args2 nil"
                ]
            },
            {
                "tactic_sig": "apply _i with ( f := _i ) ( _i := _i ) ( vl1 := _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( f := _i ) ( _i := _i ) ( vl1 := _i ) .",
                "tactic_args": [
                    "c2_goal : eq (eval_condition cond args2 m2) (Some b)",
                    "_global_1 : Z",
                    "_global_eval_condition_inj : forall (f : Val.meminj) (m1 m2 : Mem.mem)\n         (_ : forall (b1 : block) (ofs : Ptrofs.int) \n                (b2 : block) (delta : Z)\n                (_ : eq (f b1) (Some (pair b2 delta)))\n                (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\n              eq\n                (Mem.valid_pointer m2 b2\n                   (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))))\n                true)\n         (_ : forall (b1 : block) (ofs : Ptrofs.int) \n                (b2 : block) (delta : Z)\n                (_ : eq (f b1) (Some (pair b2 delta)))\n                (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs))\n                       true),\n              eq\n                (Mem.weak_valid_pointer m2 b2\n                   (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))))\n                true)\n         (_ : forall (b1 : block) (ofs : Ptrofs.int) \n                (b2 : block) (delta : Z)\n                (_ : eq (f b1) (Some (pair b2 delta)))\n                (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs))\n                       true),\n              Logic.and\n                (Z.le 0\n                   (Z.add (Ptrofs.unsigned ofs)\n                      (Ptrofs.unsigned (Ptrofs.repr delta))))\n                (Z.le\n                   (Z.add (Ptrofs.unsigned ofs)\n                      (Ptrofs.unsigned (Ptrofs.repr delta)))\n                   Ptrofs.max_unsigned))\n         (_ : forall (b1 : block) (ofs1 : Ptrofs.int) \n                (b2 : block) (ofs2 : Ptrofs.int) (b1' : block) \n                (delta1 : Z) (b2' : block) (delta2 : Z) \n                (_ : not (eq b1 b2))\n                (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1)) true)\n                (_ : eq (Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2)) true)\n                (_ : eq (f b1) (Some (pair b1' delta1)))\n                (_ : eq (f b2) (Some (pair b2' delta2))),\n              Logic.or (not (eq b1' b2'))\n                (not\n                   (eq\n                      (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)))\n                      (Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2))))))\n         (cond : condition) (vl1 vl2 : list val) (b : bool)\n         (_ : Val.inject_list f vl1 vl2)\n         (_ : eq (eval_condition cond vl1 m1) (Some b)),\n       eq (eval_condition cond vl2 m2) (Some b)",
                    "_global_inject_id : Val.meminj",
                    "c1_m1 : Mem.mem",
                    "c1_m1 : Mem.mem",
                    "c2_args1 : list val"
                ],
                "tactic_res": [
                    "c3_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true",
                    "c4_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.weak_valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true",
                    "c5_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\nLogic.and\n  (Z.le 0\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta))))\n  (Z.le\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta)))\n     Ptrofs.max_unsigned)",
                    "c6_goal : forall (b1 : block) (ofs1 : Ptrofs.int) (b2 : block)\n  (ofs2 : Ptrofs.int) (b1' : block) (delta1 : Z) (b2' : block)\n  (delta2 : Z) (_ : not (eq b1 b2))\n  (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1)) true)\n  (_ : eq (Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2)) true)\n  (_ : eq (inject_id b1) (Some (pair b1' delta1)))\n  (_ : eq (inject_id b2) (Some (pair b2' delta2))),\nLogic.or (not (eq b1' b2'))\n  (not\n     (eq (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)))\n        (Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)))))",
                    "c7_goal : Val.inject_list inject_id args1 args2",
                    "c8_goal : eq (eval_condition cond args1 m1) (Some b)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.weak_valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c5_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\nLogic.and\n  (Z.le 0\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta))))\n  (Z.le\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta)))\n     Ptrofs.max_unsigned)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : forall (b1 : block) (ofs1 : Ptrofs.int) (b2 : block)\n  (ofs2 : Ptrofs.int) (b1' : block) (delta1 : Z) (b2' : block)\n  (delta2 : Z) (_ : not (eq b1 b2))\n  (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1)) true)\n  (_ : eq (Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2)) true)\n  (_ : eq (inject_id b1) (Some (pair b1' delta1)))\n  (_ : eq (inject_id b2) (Some (pair b2' delta2))),\nLogic.or (not (eq b1' b2'))\n  (not\n     (eq (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)))\n        (Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : eq (eval_condition cond args1 m1) (Some b)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : Val.inject_list inject_id args1 args2",
                    "_global_1 : Z",
                    "_global_val_inject_list_lessdef : forall vl1 vl2 : list val,\n       iff (Val.lessdef_list vl1 vl2)\n         (Val.inject_list (fun b : block => Some (pair b 0)) vl1 vl2)"
                ],
                "tactic_res": [
                    "c9_goal : Val.lessdef_list args1 args2"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : Val.lessdef_list args1 args2",
                    "_global_1 : Z",
                    "_global_lessdef_vagree_list : forall (vl1 vl2 : list val) (_ : vagree_list vl1 vl2 nil),\n       Val.lessdef_list vl1 vl2"
                ],
                "tactic_res": [
                    "c10_goal : vagree_list args1 args2 nil"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : vagree_list args1 args2 nil"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "default_needs_of_operation_sound",
        "proof": [
            {
                "tactic_sig": "Lemma default_needs_of_operation_sound : forall op args1 v1 args2 nv , eval_operation ge ( Vptr sp Ptrofs.zero ) op args1 m1 = Some v1 -> vagree_list args1 args2 nil \\/ vagree_list args1 args2 ( default nv : : nil ) \\/ vagree_list args1 args2 ( default nv : : default nv : : nil ) \\/ vagree_list args1 args2 ( default nv : : default nv : : default nv : : nil ) -> nv <> Nothing -> exists v2 , eval_operation ge ( Vptr sp Ptrofs.zero ) op args2 m2 = Some v2 /\\ vagree v1 v2 nv .",
                "tactic_sig_no_out_arg": "Lemma default_needs_of_operation_sound : forall op args1 v1 args2 nv , eval_operation ge ( Vptr sp Ptrofs.zero ) op args1 m1 = Some v1 -> vagree_list args1 args2 nil \\/ vagree_list args1 args2 ( default nv : : nil ) \\/ vagree_list args1 args2 ( default nv : : default nv : : nil ) \\/ vagree_list args1 args2 ( default nv : : default nv : : default nv : : nil ) -> nv <> Nothing -> exists v2 , eval_operation ge ( Vptr sp Ptrofs.zero ) op args2 m2 = Some v2 /\\ vagree v1 v2 nv .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (op : operation) (args1 : list val) (v1 : val)\n  (args2 : list val) (nv : nval)\n  (_ : eq (eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1)\n         (Some v1))\n  (_ : Logic.or (vagree_list args1 args2 nil)\n         (Logic.or (vagree_list args1 args2 (cons (default nv) nil))\n            (Logic.or\n               (vagree_list args1 args2\n                  (cons (default nv) (cons (default nv) nil)))\n               (vagree_list args1 args2\n                  (cons (default nv)\n                     (cons (default nv) (cons (default nv) nil)))))))\n  (_ : not (eq nv Nothing)),\nex\n  (fun v2 : val =>\n   Logic.and\n     (eq (eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2)\n        (Some v2)) (vagree v1 v2 nv))",
                    "c1_valid_different_pointers_inj : forall (b1 : block) (ofs1 : Ptrofs.int) (b2 : block)\n  (ofs2 : Ptrofs.int) (b1' : block) (delta1 : Z) (b2' : block)\n  (delta2 : Z) (_ : not (eq b1 b2))\n  (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1)) true)\n  (_ : eq (Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2)) true)\n  (_ : eq (inject_id b1) (Some (pair b1' delta1)))\n  (_ : eq (inject_id b2) (Some (pair b2' delta2))),\nLogic.or (not (eq b1' b2'))\n  (not\n     (eq (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)))\n        (Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)))))",
                    "c1_weak_valid_pointer_no_overflow : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\nLogic.and\n  (Z.le 0\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta))))\n  (Z.le\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta)))\n     Ptrofs.max_unsigned)",
                    "c1_weak_valid_pointer_inj : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.weak_valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true",
                    "c1_valid_pointer_inj : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true",
                    "c1_PERM : forall (b : block) (ofs : Z) (k : perm_kind) (p : permission)\n  (_ : Mem.perm m1 b ofs k p), Mem.perm m2 b ofs k p",
                    "c1_m2 : Mem.mem",
                    "c1_m1 : Mem.mem",
                    "c1_sp : block",
                    "c1_ge : genv"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (op : operation) (args1 : list val) (v1 : val)\n  (args2 : list val) (nv : nval)\n  (_ : eq (eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1)\n         (Some v1))\n  (_ : Logic.or (vagree_list args1 args2 nil)\n         (Logic.or (vagree_list args1 args2 (cons (default nv) nil))\n            (Logic.or\n               (vagree_list args1 args2\n                  (cons (default nv) (cons (default nv) nil)))\n               (vagree_list args1 args2\n                  (cons (default nv)\n                     (cons (default nv) (cons (default nv) nil)))))))\n  (_ : not (eq nv Nothing)),\nex\n  (fun v2 : val =>\n   Logic.and\n     (eq (eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2)\n        (Some v2)) (vagree v1 v2 nv))"
                ],
                "tactic_res": [
                    "c2_goal : ex\n  (fun v2 : val =>\n   Logic.and\n     (eq (eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2)\n        (Some v2)) (vagree v1 v2 nv))",
                    "c2_op : operation",
                    "c2_args1 : list val",
                    "c2_v1 : val",
                    "c2_args2 : list val",
                    "c2_nv : nval",
                    "c2_H : eq (eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1) (Some v1)",
                    "c2_H0 : Logic.or (vagree_list args1 args2 nil)\n  (Logic.or (vagree_list args1 args2 (cons (default nv) nil))\n     (Logic.or\n        (vagree_list args1 args2\n           (cons (default nv) (cons (default nv) nil)))\n        (vagree_list args1 args2\n           (cons (default nv)\n              (cons (default nv) (cons (default nv) nil))))))",
                    "c2_H1 : not (eq nv Nothing)"
                ]
            },
            {
                "tactic_sig": "assert ( default _i = All ) by ( destruct _i ; simpl ; congruence ) .",
                "tactic_sig_no_out_arg": "assert ( default _i = All ) by ( destruct _i ; simpl ; congruence ) .",
                "tactic_args": [
                    "c2_nv : nval",
                    "c2_nv : nval"
                ],
                "tactic_res": [
                    "c2_H2 : eq (default nv) All"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c2_H2 : eq (default nv) All",
                    "c2_H0 : Logic.or (vagree_list args1 args2 nil)\n  (Logic.or (vagree_list args1 args2 (cons (default nv) nil))\n     (Logic.or\n        (vagree_list args1 args2\n           (cons (default nv) (cons (default nv) nil)))\n        (vagree_list args1 args2\n           (cons (default nv)\n              (cons (default nv) (cons (default nv) nil))))))"
                ],
                "tactic_res": [
                    "c2_H0 : Logic.or (vagree_list args1 args2 nil)\n  (Logic.or (vagree_list args1 args2 (cons All nil))\n     (Logic.or (vagree_list args1 args2 (cons All (cons All nil)))\n        (vagree_list args1 args2 (cons All (cons All (cons All nil))))))"
                ]
            },
            {
                "tactic_sig": "assert ( Val.lessdef_list _i _i ) .",
                "tactic_sig_no_out_arg": "assert ( Val.lessdef_list _i _i ) .",
                "tactic_args": [
                    "c2_goal : ex\n  (fun v2 : val =>\n   Logic.and\n     (eq (eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2)\n        (Some v2)) (vagree v1 v2 nv))",
                    "c2_args1 : list val",
                    "c2_args2 : list val"
                ],
                "tactic_res": [
                    "c3_goal : Val.lessdef_list args1 args2",
                    "c4_goal : ex\n  (fun v2 : val =>\n   Logic.and\n     (eq (eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2)\n        (Some v2)) (vagree v1 v2 nv))",
                    "c4_H3 : Val.lessdef_list args1 args2"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : Val.lessdef_list args1 args2",
                    "c2_H0 : Logic.or (vagree_list args1 args2 nil)\n  (Logic.or (vagree_list args1 args2 (cons (default nv) nil))\n     (Logic.or\n        (vagree_list args1 args2\n           (cons (default nv) (cons (default nv) nil)))\n        (vagree_list args1 args2\n           (cons (default nv)\n              (cons (default nv) (cons (default nv) nil))))))"
                ],
                "tactic_res": [
                    "c5_goal : Val.lessdef_list args1 args2",
                    "c5_H0 : vagree_list args1 args2 nil",
                    "c6_goal : Val.lessdef_list args1 args2",
                    "c6_H0 : Logic.or (vagree_list args1 args2 (cons All nil))\n  (Logic.or (vagree_list args1 args2 (cons All (cons All nil)))\n     (vagree_list args1 args2 (cons All (cons All (cons All nil)))))"
                ]
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c5_goal : Val.lessdef_list args1 args2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c6_goal : Val.lessdef_list args1 args2",
                    "c2_H0 : Logic.or (vagree_list args1 args2 nil)\n  (Logic.or (vagree_list args1 args2 (cons (default nv) nil))\n     (Logic.or\n        (vagree_list args1 args2\n           (cons (default nv) (cons (default nv) nil)))\n        (vagree_list args1 args2\n           (cons (default nv)\n              (cons (default nv) (cons (default nv) nil))))))"
                ],
                "tactic_res": [
                    "c7_goal : Val.lessdef_list args1 args2",
                    "c7_H0 : vagree_list args1 args2 (cons All nil)",
                    "c8_goal : Val.lessdef_list args1 args2",
                    "c8_H0 : Logic.or (vagree_list args1 args2 (cons All (cons All nil)))\n  (vagree_list args1 args2 (cons All (cons All (cons All nil))))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c7_goal : Val.lessdef_list args1 args2",
                    "c2_H0 : Logic.or (vagree_list args1 args2 nil)\n  (Logic.or (vagree_list args1 args2 (cons (default nv) nil))\n     (Logic.or\n        (vagree_list args1 args2\n           (cons (default nv) (cons (default nv) nil)))\n        (vagree_list args1 args2\n           (cons (default nv)\n              (cons (default nv) (cons (default nv) nil))))))"
                ],
                "tactic_res": [
                    "c9_goal : Val.lessdef_list nil nil",
                    "c9_H : eq (eval_operation ge (Vptr sp Ptrofs.zero) op nil m1) (Some v1)",
                    "c10_goal : Val.lessdef_list (cons v0 vl1) (cons v2 vl2)",
                    "c10_H8 : vagree_list vl1 vl2 nil",
                    "c10_H7 : vagree v0 v2 All",
                    "c10_vl2 : list val",
                    "c10_v2 : val",
                    "c10_H : eq (eval_operation ge (Vptr sp Ptrofs.zero) op (cons v0 vl1) m1)\n  (Some v1)",
                    "c10_vl1 : list val",
                    "c10_v0 : val"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c9_goal : Val.lessdef_list nil nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c10_goal : Val.lessdef_list (cons v0 vl1) (cons v2 vl2)"
                ],
                "tactic_res": [
                    "c11_goal : Val.lessdef v0 v2",
                    "c12_goal : Val.lessdef_list vl1 vl2"
                ]
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c11_goal : Val.lessdef v0 v2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c12_goal : Val.lessdef_list vl1 vl2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c8_goal : Val.lessdef_list args1 args2",
                    "c2_H0 : Logic.or (vagree_list args1 args2 nil)\n  (Logic.or (vagree_list args1 args2 (cons (default nv) nil))\n     (Logic.or\n        (vagree_list args1 args2\n           (cons (default nv) (cons (default nv) nil)))\n        (vagree_list args1 args2\n           (cons (default nv)\n              (cons (default nv) (cons (default nv) nil))))))"
                ],
                "tactic_res": [
                    "c13_goal : Val.lessdef_list args1 args2",
                    "c13_H0 : vagree_list args1 args2 (cons All (cons All nil))",
                    "c14_goal : Val.lessdef_list args1 args2",
                    "c14_H0 : vagree_list args1 args2 (cons All (cons All (cons All nil)))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c13_goal : Val.lessdef_list args1 args2",
                    "c2_H0 : Logic.or (vagree_list args1 args2 nil)\n  (Logic.or (vagree_list args1 args2 (cons (default nv) nil))\n     (Logic.or\n        (vagree_list args1 args2\n           (cons (default nv) (cons (default nv) nil)))\n        (vagree_list args1 args2\n           (cons (default nv)\n              (cons (default nv) (cons (default nv) nil))))))"
                ],
                "tactic_res": [
                    "c15_goal : Val.lessdef_list nil nil",
                    "c15_H : eq (eval_operation ge (Vptr sp Ptrofs.zero) op nil m1) (Some v1)",
                    "c16_goal : Val.lessdef_list (cons v0 vl1) (cons v2 vl2)",
                    "c16_H8 : vagree_list vl1 vl2 (cons All nil)",
                    "c16_H7 : vagree v0 v2 All",
                    "c16_vl2 : list val",
                    "c16_v2 : val",
                    "c16_H : eq (eval_operation ge (Vptr sp Ptrofs.zero) op (cons v0 vl1) m1)\n  (Some v1)",
                    "c16_vl1 : list val",
                    "c16_v0 : val"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c15_goal : Val.lessdef_list nil nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c16_goal : Val.lessdef_list (cons v0 vl1) (cons v2 vl2)",
                    "c16_H8 : vagree_list vl1 vl2 (cons All nil)"
                ],
                "tactic_res": [
                    "c17_goal : Val.lessdef_list (cons v0 nil) (cons v2 nil)",
                    "c17_H : eq (eval_operation ge (Vptr sp Ptrofs.zero) op (cons v0 nil) m1)\n  (Some v1)",
                    "c18_goal : Val.lessdef_list (cons v0 (cons v3 vl0)) (cons v2 (cons v4 vl3))",
                    "c18_H9 : vagree_list vl0 vl3 nil",
                    "c18_H6 : vagree v3 v4 All",
                    "c18_vl3 : list val",
                    "c18_v4 : val",
                    "c18_H : eq\n  (eval_operation ge (Vptr sp Ptrofs.zero) op (cons v0 (cons v3 vl0))\n     m1) (Some v1)",
                    "c18_vl0 : list val",
                    "c18_v3 : val"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c17_goal : Val.lessdef_list (cons v0 nil) (cons v2 nil)"
                ],
                "tactic_res": [
                    "c19_goal : Val.lessdef v0 v2",
                    "c20_goal : Val.lessdef_list nil nil"
                ]
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c19_goal : Val.lessdef v0 v2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c20_goal : Val.lessdef_list nil nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c18_goal : Val.lessdef_list (cons v0 (cons v3 vl0)) (cons v2 (cons v4 vl3))"
                ],
                "tactic_res": [
                    "c21_goal : Val.lessdef v0 v2",
                    "c22_goal : Val.lessdef_list (cons v3 vl0) (cons v4 vl3)"
                ]
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c21_goal : Val.lessdef v0 v2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c22_goal : Val.lessdef_list (cons v3 vl0) (cons v4 vl3)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c14_goal : Val.lessdef_list args1 args2",
                    "c2_H0 : Logic.or (vagree_list args1 args2 nil)\n  (Logic.or (vagree_list args1 args2 (cons (default nv) nil))\n     (Logic.or\n        (vagree_list args1 args2\n           (cons (default nv) (cons (default nv) nil)))\n        (vagree_list args1 args2\n           (cons (default nv)\n              (cons (default nv) (cons (default nv) nil))))))"
                ],
                "tactic_res": [
                    "c23_goal : Val.lessdef_list nil nil",
                    "c23_H : eq (eval_operation ge (Vptr sp Ptrofs.zero) op nil m1) (Some v1)",
                    "c24_goal : Val.lessdef_list (cons v0 vl1) (cons v2 vl2)",
                    "c24_H8 : vagree_list vl1 vl2 (cons All (cons All nil))",
                    "c24_H7 : vagree v0 v2 All",
                    "c24_vl2 : list val",
                    "c24_v2 : val",
                    "c24_H : eq (eval_operation ge (Vptr sp Ptrofs.zero) op (cons v0 vl1) m1)\n  (Some v1)",
                    "c24_vl1 : list val",
                    "c24_v0 : val"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c23_goal : Val.lessdef_list nil nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c24_goal : Val.lessdef_list (cons v0 vl1) (cons v2 vl2)"
                ],
                "tactic_res": [
                    "c25_goal : Val.lessdef v0 v2",
                    "c26_goal : Val.lessdef_list vl1 vl2"
                ]
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c25_goal : Val.lessdef v0 v2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c26_goal : Val.lessdef_list vl1 vl2",
                    "c24_H8 : vagree_list vl1 vl2 (cons All (cons All nil))"
                ],
                "tactic_res": [
                    "c27_goal : Val.lessdef_list nil nil",
                    "c27_H : eq (eval_operation ge (Vptr sp Ptrofs.zero) op (cons v0 nil) m1)\n  (Some v1)",
                    "c28_goal : Val.lessdef_list (cons v3 vl0) (cons v4 vl3)",
                    "c28_H9 : vagree_list vl0 vl3 (cons All nil)",
                    "c28_H6 : vagree v3 v4 All",
                    "c28_vl3 : list val",
                    "c28_v4 : val",
                    "c28_H : eq\n  (eval_operation ge (Vptr sp Ptrofs.zero) op (cons v0 (cons v3 vl0))\n     m1) (Some v1)",
                    "c28_vl0 : list val",
                    "c28_v3 : val"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c27_goal : Val.lessdef_list nil nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c28_goal : Val.lessdef_list (cons v3 vl0) (cons v4 vl3)"
                ],
                "tactic_res": [
                    "c29_goal : Val.lessdef v3 v4",
                    "c30_goal : Val.lessdef_list vl0 vl3"
                ]
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c29_goal : Val.lessdef v3 v4"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c30_goal : Val.lessdef_list vl0 vl3",
                    "c28_H9 : vagree_list vl0 vl3 (cons All nil)"
                ],
                "tactic_res": [
                    "c31_goal : Val.lessdef_list nil nil",
                    "c31_H : eq\n  (eval_operation ge (Vptr sp Ptrofs.zero) op (cons v0 (cons v3 nil))\n     m1) (Some v1)",
                    "c32_goal : Val.lessdef_list (cons v5 vl1) (cons v6 vl2)",
                    "c32_H10 : vagree_list vl1 vl2 nil",
                    "c32_H8 : vagree v5 v6 All",
                    "c32_vl2 : list val",
                    "c32_v6 : val",
                    "c32_H : eq\n  (eval_operation ge (Vptr sp Ptrofs.zero) op\n     (cons v0 (cons v3 (cons v5 vl1))) m1) (Some v1)",
                    "c32_vl1 : list val",
                    "c32_v5 : val"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c31_goal : Val.lessdef_list nil nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c32_goal : Val.lessdef_list (cons v5 vl1) (cons v6 vl2)"
                ],
                "tactic_res": [
                    "c33_goal : Val.lessdef v5 v6",
                    "c34_goal : Val.lessdef_list vl1 vl2"
                ]
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c33_goal : Val.lessdef v5 v6"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto with na .",
                "tactic_sig_no_out_arg": "auto with na .",
                "tactic_args": [
                    "c34_goal : Val.lessdef_list vl1 vl2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit ( @eval_operation_inj _ _ _ _ _i _i inject_id ) .",
                "tactic_sig_no_out_arg": "exploit ( @eval_operation_inj _ _ _ _ _i _i inject_id ) .",
                "tactic_args": [
                    "c4_goal : ex\n  (fun v2 : val =>\n   Logic.and\n     (eq (eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2)\n        (Some v2)) (vagree v1 v2 nv))",
                    "c1_ge : genv",
                    "c1_ge : genv"
                ],
                "tactic_res": [
                    "c35_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.valid_pointer ?Goal b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.valid_pointer ?Goal0 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true",
                    "c36_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer ?Goal b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.weak_valid_pointer ?Goal0 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true",
                    "c37_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer ?Goal b1 (Ptrofs.unsigned ofs)) true),\nLogic.and\n  (Z.le 0\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta))))\n  (Z.le\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta)))\n     Ptrofs.max_unsigned)",
                    "c38_goal : forall (b1 : block) (ofs1 : Ptrofs.int) (b2 : block)\n  (ofs2 : Ptrofs.int) (b1' : block) (delta1 : Z) (b2' : block)\n  (delta2 : Z) (_ : not (eq b1 b2))\n  (_ : eq (Mem.valid_pointer ?Goal b1 (Ptrofs.unsigned ofs1)) true)\n  (_ : eq (Mem.valid_pointer ?Goal b2 (Ptrofs.unsigned ofs2)) true)\n  (_ : eq (inject_id b1) (Some (pair b1' delta1)))\n  (_ : eq (inject_id b2) (Some (pair b2' delta2))),\nLogic.or (not (eq b1' b2'))\n  (not\n     (eq (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)))\n        (Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)))))",
                    "c39_goal : forall (id : ident) (ofs : Ptrofs.int)\n  (_ : In id (globals_operation ?Goal5)),\nVal.inject inject_id (Genv.symbol_address ge id ofs)\n  (Genv.symbol_address ge id ofs)",
                    "c40_goal : Val.inject inject_id ?Goal6 ?Goal8",
                    "c41_goal : Val.inject_list inject_id ?Goal7 ?Goal9",
                    "c42_goal : eq (eval_operation ge ?Goal6 ?Goal5 ?Goal7 ?Goal) (Some ?Goal10)",
                    "c43_goal : forall\n  _ : ex\n        (fun v2 : val =>\n         Logic.and\n           (eq (eval_operation ge ?Goal8 ?Goal5 ?Goal9 ?Goal0)\n              (Some v2)) (Val.inject inject_id ?Goal10 v2)),\nex\n  (fun v2 : val =>\n   Logic.and\n     (eq (eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2)\n        (Some v2)) (vagree v1 v2 nv))"
                ]
            },
            {
                "tactic_sig": "eassumption .",
                "tactic_sig_no_out_arg": "eassumption .",
                "tactic_args": [
                    "c35_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.valid_pointer ?Goal b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.valid_pointer ?Goal0 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c36_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\neq\n  (Mem.weak_valid_pointer m2 b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))) true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c37_goal : forall (b1 : block) (ofs : Ptrofs.int) (b2 : block) \n  (delta : Z) (_ : eq (inject_id b1) (Some (pair b2 delta)))\n  (_ : eq (Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs)) true),\nLogic.and\n  (Z.le 0\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta))))\n  (Z.le\n     (Z.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned (Ptrofs.repr delta)))\n     Ptrofs.max_unsigned)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c38_goal : forall (b1 : block) (ofs1 : Ptrofs.int) (b2 : block)\n  (ofs2 : Ptrofs.int) (b1' : block) (delta1 : Z) (b2' : block)\n  (delta2 : Z) (_ : not (eq b1 b2))\n  (_ : eq (Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1)) true)\n  (_ : eq (Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2)) true)\n  (_ : eq (inject_id b1) (Some (pair b1' delta1)))\n  (_ : eq (inject_id b2) (Some (pair b2' delta2))),\nLogic.or (not (eq b1' b2'))\n  (not\n     (eq (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)))\n        (Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "instantiate ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := _i ) .",
                "tactic_args": [
                    "c39_goal : forall (id : ident) (ofs : Ptrofs.int)\n  (_ : In id (globals_operation ?Goal5)),\nVal.inject inject_id (Genv.symbol_address ge id ofs)\n  (Genv.symbol_address ge id ofs)",
                    "c2_op : operation"
                ],
                "tactic_res": [
                    "c44_goal : forall (id : ident) (ofs : Ptrofs.int)\n  (_ : In id (globals_operation op)),\nVal.inject inject_id (Genv.symbol_address ge id ofs)\n  (Genv.symbol_address ge id ofs)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c44_goal : forall (id : ident) (ofs : Ptrofs.int)\n  (_ : In id (globals_operation op)),\nVal.inject inject_id (Genv.symbol_address ge id ofs)\n  (Genv.symbol_address ge id ofs)"
                ],
                "tactic_res": [
                    "c45_goal : Val.inject inject_id (Genv.symbol_address ge id ofs)\n  (Genv.symbol_address ge id ofs)",
                    "c45_id : ident",
                    "c45_ofs : Ptrofs.int",
                    "c45_H4 : In id (globals_operation op)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c45_goal : Val.inject inject_id (Genv.symbol_address ge id ofs)\n  (Genv.symbol_address ge id ofs)",
                    "_global_1 : Z",
                    "_global_val_inject_lessdef : forall v1 v2 : val,\n       iff (Val.lessdef v1 v2)\n         (Val.inject (fun b : block => Some (pair b 0)) v1 v2)"
                ],
                "tactic_res": [
                    "c46_goal : Val.lessdef (Genv.symbol_address ge id ofs)\n  (Genv.symbol_address ge id ofs)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c46_goal : Val.lessdef (Genv.symbol_address ge id ofs)\n  (Genv.symbol_address ge id ofs)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c40_goal : Val.inject inject_id ?Goal6 ?Goal8",
                    "_global_1 : Z",
                    "_global_val_inject_lessdef : forall v1 v2 : val,\n       iff (Val.lessdef v1 v2)\n         (Val.inject (fun b : block => Some (pair b 0)) v1 v2)"
                ],
                "tactic_res": [
                    "c47_goal : Val.lessdef ?v1 ?v2"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := Vptr _i Ptrofs.zero ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := Vptr _i Ptrofs.zero ) .",
                "tactic_args": [
                    "c47_goal : Val.lessdef ?v1 ?v2",
                    "c1_sp : block"
                ],
                "tactic_res": [
                    "c48_goal : Val.lessdef ?v1 (Vptr sp Ptrofs.zero)"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := Vptr _i Ptrofs.zero ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := Vptr _i Ptrofs.zero ) .",
                "tactic_args": [
                    "c48_goal : Val.lessdef ?v1 (Vptr sp Ptrofs.zero)",
                    "c1_sp : block"
                ],
                "tactic_res": [
                    "c49_goal : Val.lessdef (Vptr sp Ptrofs.zero) (Vptr sp Ptrofs.zero)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c49_goal : Val.lessdef (Vptr sp Ptrofs.zero) (Vptr sp Ptrofs.zero)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c41_goal : Val.inject_list inject_id ?Goal7 ?Goal9",
                    "_global_1 : Z",
                    "_global_val_inject_list_lessdef : forall vl1 vl2 : list val,\n       iff (Val.lessdef_list vl1 vl2)\n         (Val.inject_list (fun b : block => Some (pair b 0)) vl1 vl2)"
                ],
                "tactic_res": [
                    "c50_goal : Val.lessdef_list ?vl1 ?vl2"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c50_goal : Val.lessdef_list ?vl1 ?vl2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c42_goal : eq (eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1) (Some ?Goal)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros ( _o & _o & _o ) .",
                "tactic_sig_no_out_arg": "intros ( v2 & A & B ) .",
                "tactic_args": [
                    "c43_goal : forall\n  _ : ex\n        (fun v2 : val =>\n         Logic.and\n           (eq (eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2)\n              (Some v2)) (Val.inject inject_id v1 v2)),\nex\n  (fun v2 : val =>\n   Logic.and\n     (eq (eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2)\n        (Some v2)) (vagree v1 v2 nv))"
                ],
                "tactic_res": [
                    "c51_goal : ex\n  (fun v2 : val =>\n   Logic.and\n     (eq (eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2)\n        (Some v2)) (vagree v1 v2 nv))",
                    "c51_v2 : val",
                    "c51_A : eq (eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2) (Some v2)",
                    "c51_B : Val.inject inject_id v1 v2"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "c51_goal : ex\n  (fun v2 : val =>\n   Logic.and\n     (eq (eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2)\n        (Some v2)) (vagree v1 v2 nv))",
                    "c51_v2 : val"
                ],
                "tactic_res": [
                    "c52_goal : Logic.and\n  (eq (eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2) (Some v2))\n  (vagree v1 v2 nv)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c52_goal : Logic.and\n  (eq (eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2) (Some v2))\n  (vagree v1 v2 nv)"
                ],
                "tactic_res": [
                    "c53_goal : eq (eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2) (Some v2)",
                    "c54_goal : vagree v1 v2 nv"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c53_goal : eq (eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2) (Some v2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c54_goal : vagree v1 v2 nv",
                    "_global_1 : Z",
                    "_global_vagree_lessdef : forall (v w : val) (x : nval) (_ : Val.lessdef v w), vagree v w x"
                ],
                "tactic_res": [
                    "c55_goal : Val.lessdef v1 v2"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c55_goal : Val.lessdef v1 v2",
                    "_global_1 : Z",
                    "_global_val_inject_lessdef : forall v1 v2 : val,\n       iff (Val.lessdef v1 v2)\n         (Val.inject (fun b : block => Some (pair b 0)) v1 v2)"
                ],
                "tactic_res": [
                    "c56_goal : Val.inject (fun b : block => Some (pair b 0)) v1 v2"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c56_goal : Val.inject (fun b : block => Some (pair b 0)) v1 v2"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "andimm_redundant_sound",
        "proof": [
            {
                "tactic_sig": "Lemma andimm_redundant_sound : forall v w x n , andimm_redundant x n = true -> vagree v w ( andimm x n ) -> vagree ( Val.and v ( Vint n ) ) w x .",
                "tactic_sig_no_out_arg": "Lemma andimm_redundant_sound : forall v w x n , andimm_redundant x n = true -> vagree v w ( andimm x n ) -> vagree ( Val.and v ( Vint n ) ) w x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : eq (andimm_redundant x n) true) (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) w x"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : eq (andimm_redundant x n) true) (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) w x",
                    "_global_1 : Z",
                    "_global_andimm_redundant : forall (_ : nval) (_ : Int.int), bool"
                ],
                "tactic_res": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : eq\n         match x with\n         | Nothing => true\n         | I m => Int.eq_dec (Int.and m (Int.not n)) Int.zero\n         | All => false\n         end true) (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) w x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : eq\n         match x with\n         | Nothing => true\n         | I m => Int.eq_dec (Int.and m (Int.not n)) Int.zero\n         | All => false\n         end true) (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) w x"
                ],
                "tactic_res": [
                    "c3_goal : vagree (Val.and v (Vint n)) w x",
                    "c3_v : val",
                    "c3_w : val",
                    "c3_x : nval",
                    "c3_n : Int.int",
                    "c3_H : eq\n  match x with\n  | Nothing => true\n  | I m => Int.eq_dec (Int.and m (Int.not n)) Int.zero\n  | All => false\n  end true",
                    "c3_H0 : vagree v w (andimm x n)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o | _o _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : vagree (Val.and v (Vint n)) w x",
                    "c3_x : nval"
                ],
                "tactic_res": [
                    "c4_goal : vagree (Val.and v (Vint n)) w Nothing",
                    "c4_H0 : vagree v w (andimm Nothing n)",
                    "c4_H : eq true true",
                    "c5_goal : vagree (Val.and v (Vint n)) w (I m)",
                    "c5_H0 : vagree v w (andimm (I m) n)",
                    "c5_H : eq (Int.eq_dec (Int.and m (Int.not n)) Int.zero) true",
                    "c5_m : Int.int",
                    "c6_goal : vagree (Val.and v (Vint n)) w All",
                    "c6_H0 : vagree v w (andimm All n)",
                    "c6_H : eq false true"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c6_goal : vagree (Val.and v (Vint n)) w All"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : vagree (Val.and v (Vint n)) w Nothing"
                ],
                "tactic_res": [
                    "c7_goal : True"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c5_goal : vagree (Val.and v (Vint n)) w (I m)"
                ],
                "tactic_res": [
                    "c8_goal : match Val.and v (Vint n) with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend",
                    "c8_H0 : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.and m n)\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "unfold Val._i .",
                "tactic_sig_no_out_arg": "unfold Val._i .",
                "tactic_args": [
                    "c8_goal : match Val.and v (Vint n) with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend",
                    "_global_1 : Z",
                    "_global_and : forall (_ : aval) (_ : aval), aval"
                ],
                "tactic_res": [
                    "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c10_goal : iagree (Int.and i n) i0 m",
                    "c10_H0 : iagree i i0 (Int.and m n)",
                    "c10_i0 : Int.int",
                    "c10_i : Int.int"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c10_goal : iagree (Int.and i n) i0 m"
                ],
                "tactic_res": [
                    "c11_goal : forall (i1 : Z) (_ : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize))\n  (_ : eq (Int.testbit m i1) true),\neq (Int.testbit (Int.and i n) i1) (Int.testbit i0 i1)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c11_goal : forall (i1 : Z) (_ : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize))\n  (_ : eq (Int.testbit m i1) true),\neq (Int.testbit (Int.and i n) i1) (Int.testbit i0 i1)"
                ],
                "tactic_res": [
                    "c12_goal : eq (Int.testbit (Int.and i n) i1) (Int.testbit i0 i1)",
                    "c12_i1 : Z",
                    "c12_H1 : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)",
                    "c12_H2 : eq (Int.testbit m i1) true"
                ]
            },
            {
                "tactic_sig": "exploit ( eq_same_bits _i ) .",
                "tactic_sig_no_out_arg": "exploit ( eq_same_bits _i ) .",
                "tactic_args": [
                    "c12_goal : eq (Int.testbit (Int.and i n) i1) (Int.testbit i0 i1)",
                    "c12_i1 : Z"
                ],
                "tactic_res": [
                    "c13_goal : eq ?Goal ?Goal0",
                    "c14_goal : forall _ : eq (Int.testbit ?Goal i1) (Int.testbit ?Goal0 i1),\neq (Int.testbit (Int.and i n) i1) (Int.testbit i0 i1)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c13_goal : eq ?Goal ?Goal0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "autorewrite with ints .",
                "tactic_sig_no_out_arg": "autorewrite with ints .",
                "tactic_args": [
                    "c14_goal : forall\n  _ : eq (Int.testbit (Int.and m (Int.not n)) i1)\n        (Int.testbit Int.zero i1),\neq (Int.testbit (Int.and i n) i1) (Int.testbit i0 i1)"
                ],
                "tactic_res": [
                    "c15_goal : forall _ : eq (andb (Int.testbit m i1) (negb (Int.testbit n i1))) false,\neq (andb (Int.testbit i i1) (Int.testbit n i1)) (Int.testbit i0 i1)",
                    "c16_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)",
                    "c17_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)",
                    "c18_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c15_goal : forall _ : eq (andb (Int.testbit m i1) (negb (Int.testbit n i1))) false,\neq (andb (Int.testbit i i1) (Int.testbit n i1)) (Int.testbit i0 i1)",
                    "_global_1 : Z",
                    "c12_H2 : eq (Int.testbit m i1) true"
                ],
                "tactic_res": [
                    "c19_goal : forall _ : eq (andb true (negb (Int.testbit n i1))) false,\neq (andb (Int.testbit i i1) (Int.testbit n i1)) (Int.testbit i0 i1)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c19_goal : forall _ : eq (andb true (negb (Int.testbit n i1))) false,\neq (andb (Int.testbit i i1) (Int.testbit n i1)) (Int.testbit i0 i1)"
                ],
                "tactic_res": [
                    "c20_goal : forall _ : eq (negb (Int.testbit n i1)) false,\neq (andb (Int.testbit i i1) (Int.testbit n i1)) (Int.testbit i0 i1)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c20_goal : forall _ : eq (negb (Int.testbit n i1)) false,\neq (andb (Int.testbit i i1) (Int.testbit n i1)) (Int.testbit i0 i1)"
                ],
                "tactic_res": [
                    "c21_goal : eq (andb (Int.testbit i i1) (Int.testbit n i1)) (Int.testbit i0 i1)",
                    "c21_H3 : eq (negb (Int.testbit n i1)) false"
                ]
            },
            {
                "tactic_sig": "destruct ( Int.testbit _i _i ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( Int.testbit _i _i ) eqn : N .",
                "tactic_args": [
                    "c21_goal : eq (andb (Int.testbit i i1) (Int.testbit n i1)) (Int.testbit i0 i1)",
                    "c3_n : Int.int",
                    "c12_i1 : Z"
                ],
                "tactic_res": [
                    "c22_goal : eq (andb (Int.testbit i i1) true) (Int.testbit i0 i1)",
                    "c22_H3 : eq (negb true) false",
                    "c22_N : eq (Int.testbit n i1) true",
                    "c23_goal : eq (andb (Int.testbit i i1) false) (Int.testbit i0 i1)",
                    "c23_H3 : eq (negb false) false",
                    "c23_N : eq (Int.testbit n i1) false"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c23_goal : eq (andb (Int.testbit i i1) false) (Int.testbit i0 i1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c22_goal : eq (andb (Int.testbit i i1) true) (Int.testbit i0 i1)",
                    "_global_1 : Z",
                    "_global_andb_true_r : forall b : bool, eq (andb b true) b"
                ],
                "tactic_res": [
                    "c24_goal : eq (Int.testbit i i1) (Int.testbit i0 i1)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c24_goal : eq (Int.testbit i i1) (Int.testbit i0 i1)",
                    "_global_1 : Z",
                    "c3_H0 : vagree v w (andimm x n)"
                ],
                "tactic_res": [
                    "c25_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)",
                    "c26_goal : eq (Int.testbit (Int.and m n) i1) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c25_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "autorewrite with ints .",
                "tactic_sig_no_out_arg": "autorewrite with ints .",
                "tactic_args": [
                    "c26_goal : eq (Int.testbit (Int.and m n) i1) true"
                ],
                "tactic_res": [
                    "c27_goal : eq (andb (Int.testbit m i1) (Int.testbit n i1)) true",
                    "c28_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c28_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "c27_goal : eq (andb (Int.testbit m i1) (Int.testbit n i1)) true",
                    "_global_1 : Z",
                    "c12_H2 : eq (Int.testbit m i1) true",
                    "c22_N : eq (Int.testbit n i1) true"
                ],
                "tactic_res": [
                    "c29_goal : eq (andb true true) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c29_goal : eq (andb true true) true"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "orimm_redundant_sound",
        "proof": [
            {
                "tactic_sig": "Lemma orimm_redundant_sound : forall v w x n , orimm_redundant x n = true -> vagree v w ( orimm x n ) -> vagree ( Val.or v ( Vint n ) ) w x .",
                "tactic_sig_no_out_arg": "Lemma orimm_redundant_sound : forall v w x n , orimm_redundant x n = true -> vagree v w ( orimm x n ) -> vagree ( Val.or v ( Vint n ) ) w x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : eq (orimm_redundant x n) true) (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) w x"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : eq (orimm_redundant x n) true) (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) w x",
                    "_global_1 : Z",
                    "_global_orimm_redundant : forall (_ : nval) (_ : Int.int), bool"
                ],
                "tactic_res": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : eq\n         match x with\n         | Nothing => true\n         | I m => Int.eq_dec (Int.and m n) Int.zero\n         | All => false\n         end true) (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) w x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : eq\n         match x with\n         | Nothing => true\n         | I m => Int.eq_dec (Int.and m n) Int.zero\n         | All => false\n         end true) (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) w x"
                ],
                "tactic_res": [
                    "c3_goal : vagree (Val.or v (Vint n)) w x",
                    "c3_v : val",
                    "c3_w : val",
                    "c3_x : nval",
                    "c3_n : Int.int",
                    "c3_H : eq\n  match x with\n  | Nothing => true\n  | I m => Int.eq_dec (Int.and m n) Int.zero\n  | All => false\n  end true",
                    "c3_H0 : vagree v w (orimm x n)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o | _o _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : vagree (Val.or v (Vint n)) w x",
                    "c3_x : nval"
                ],
                "tactic_res": [
                    "c4_goal : vagree (Val.or v (Vint n)) w Nothing",
                    "c4_H0 : vagree v w (orimm Nothing n)",
                    "c4_H : eq true true",
                    "c5_goal : vagree (Val.or v (Vint n)) w (I m)",
                    "c5_H0 : vagree v w (orimm (I m) n)",
                    "c5_H : eq (Int.eq_dec (Int.and m n) Int.zero) true",
                    "c5_m : Int.int",
                    "c6_goal : vagree (Val.or v (Vint n)) w All",
                    "c6_H0 : vagree v w (orimm All n)",
                    "c6_H : eq false true"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c6_goal : vagree (Val.or v (Vint n)) w All"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : vagree (Val.or v (Vint n)) w Nothing"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c5_goal : vagree (Val.or v (Vint n)) w (I m)"
                ],
                "tactic_res": [
                    "c7_goal : match Val.or v (Vint n) with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend",
                    "c7_H0 : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.and m (Int.not n))\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "unfold Val._i .",
                "tactic_sig_no_out_arg": "unfold Val._i .",
                "tactic_args": [
                    "c7_goal : match Val.or v (Vint n) with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend",
                    "_global_1 : Z",
                    "_global_or : forall (_ : aval) (_ : aval), aval"
                ],
                "tactic_res": [
                    "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c9_goal : iagree (Int.or i n) i0 m",
                    "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                    "c9_i0 : Int.int",
                    "c9_i : Int.int"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : iagree (Int.or i n) i0 m",
                    "_global_1 : Z",
                    "_global_iagree_not' : forall (x y m : Int.int) (_ : iagree (Int.not x) (Int.not y) m),\n       iagree x y m"
                ],
                "tactic_res": [
                    "c10_goal : iagree (Int.not (Int.or i n)) (Int.not i0) m"
                ]
            },
            {
                "tactic_sig": "rewrite Int.not_or_and_not .",
                "tactic_sig_no_out_arg": "rewrite Int.not_or_and_not .",
                "tactic_args": [
                    "c10_goal : iagree (Int.not (Int.or i n)) (Int.not i0) m",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c11_goal : iagree (Int.and (Int.not i) (Int.not n)) (Int.not i0) m"
                ]
            },
            {
                "tactic_sig": "apply ( _i ( _i ( Int._i _i ) ) ( _i ( Int._i _i ) ) ( _i _i ) ( Int._i _i ) ) .",
                "tactic_sig_no_out_arg": "apply ( _i ( _i ( Int._i _i ) ) ( _i ( Int._i _i ) ) ( _i _i ) ( Int._i _i ) ) .",
                "tactic_args": [
                    "c11_goal : iagree (Int.and (Int.not i) (Int.not n)) (Int.not i0) m",
                    "_global_1 : Z",
                    "_global_andimm_redundant_sound : forall (v w : val) (x : nval) (n : Int.int)\n         (_ : eq (andimm_redundant x n) true) (_ : vagree v w (andimm x n)),\n       vagree (Val.and v (Vint n)) w x",
                    "_global_Vint : forall _ : Int.int, val",
                    "_global_not : forall _ : Prop, Prop",
                    "c9_i : Int.int",
                    "_global_Vint : forall _ : Int.int, val",
                    "_global_not : forall _ : Prop, Prop",
                    "c9_i0 : Int.int",
                    "_global_I : forall _ : Int.int, nval",
                    "c5_m : Int.int",
                    "_global_not : forall _ : Prop, Prop",
                    "c3_n : Int.int"
                ],
                "tactic_res": [
                    "c12_goal : eq (andimm_redundant (I m) (Int.not n)) true",
                    "c13_goal : vagree (Vint (Int.not i)) (Vint (Int.not i0))\n  (andimm (I m) (Int.not n))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c12_goal : eq (andimm_redundant (I m) (Int.not n)) true"
                ],
                "tactic_res": [
                    "c14_goal : eq (Int.eq_dec (Int.and m (Int.not (Int.not n))) Int.zero) true"
                ]
            },
            {
                "tactic_sig": "rewrite Int.not_involutive .",
                "tactic_sig_no_out_arg": "rewrite Int.not_involutive .",
                "tactic_args": [
                    "c14_goal : eq (Int.eq_dec (Int.and m (Int.not (Int.not n))) Int.zero) true",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c15_goal : eq (Int.eq_dec (Int.and m n) Int.zero) true"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : eq (Int.eq_dec (Int.and m n) Int.zero) true",
                    "_global_1 : Z",
                    "_global_proj_sumbool_is_true : forall (P : Prop) (a : sumbool P (not P)) (_ : P), eq a true"
                ],
                "tactic_res": [
                    "c16_goal : eq (Int.and m n) Int.zero"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : eq (Int.and m n) Int.zero"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c13_goal : vagree (Vint (Int.not i)) (Vint (Int.not i0))\n  (andimm (I m) (Int.not n))"
                ],
                "tactic_res": [
                    "c17_goal : iagree (Int.not i) (Int.not i0) (Int.and m (Int.not n))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c17_goal : iagree (Int.not i) (Int.not i0) (Int.and m (Int.not n))",
                    "_global_1 : Z",
                    "_global_iagree_not : forall (x y m : Int.int) (_ : iagree x y m),\n       iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                    "c18_goal : iagree i i0 (Int.and m (Int.not n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : iagree i i0 (Int.and m (Int.not n))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "rolm_redundant_sound",
        "proof": [
            {
                "tactic_sig": "Lemma rolm_redundant_sound : forall v w x amount mask , rolm_redundant x amount mask = true -> vagree v w ( rolm x amount mask ) -> vagree ( Val.rolm v amount mask ) w x .",
                "tactic_sig_no_out_arg": "Lemma rolm_redundant_sound : forall v w x amount mask , rolm_redundant x amount mask = true -> vagree v w ( rolm x amount mask ) -> vagree ( Val.rolm v amount mask ) w x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : eq (rolm_redundant x amount mask) true)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) w x"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : eq (rolm_redundant x amount mask) true)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) w x",
                    "_global_1 : Z",
                    "_global_rolm_redundant : forall (_ : nval) (_ : Int.int) (_ : Int.int), bool"
                ],
                "tactic_res": [
                    "c2_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : eq (andb (Int.eq_dec amount Int.zero) (andimm_redundant x mask))\n         true) (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) w x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : eq (andb (Int.eq_dec amount Int.zero) (andimm_redundant x mask))\n         true) (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) w x"
                ],
                "tactic_res": [
                    "c3_goal : vagree (Val.rolm v amount mask) w x",
                    "c3_v : val",
                    "c3_w : val",
                    "c3_x : nval",
                    "c3_amount : Int.int",
                    "c3_mask : Int.int",
                    "c3_H : eq (andb (Int.eq_dec amount Int.zero) (andimm_redundant x mask)) true",
                    "c3_H0 : vagree v w (rolm x amount mask)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c3_goal : vagree (Val.rolm v amount mask) w x",
                    "c3_amount : Int.int"
                ],
                "tactic_res": [
                    "c4_goal : vagree (Val.rolm v Int.zero mask) w x",
                    "c4_H0 : vagree v w (rolm x Int.zero mask)"
                ]
            },
            {
                "tactic_sig": "rewrite Val.rolm_zero .",
                "tactic_sig_no_out_arg": "rewrite Val.rolm_zero .",
                "tactic_args": [
                    "c4_goal : vagree (Val.rolm v Int.zero mask) w x",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c5_goal : vagree (Val.and v (Vint mask)) w x"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : vagree (Val.and v (Vint mask)) w x",
                    "_global_1 : Z",
                    "_global_andimm_redundant_sound : forall (v w : val) (x : nval) (n : Int.int)\n         (_ : eq (andimm_redundant x n) true) (_ : vagree v w (andimm x n)),\n       vagree (Val.and v (Vint n)) w x"
                ],
                "tactic_res": [
                    "c6_goal : eq (andimm_redundant x mask) true",
                    "c7_goal : vagree v w (andimm x mask)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : eq (andimm_redundant x mask) true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( forall n , Int.ror n Int.zero = n ) .",
                "tactic_sig_no_out_arg": "assert ( forall n , Int.ror n Int.zero = n ) .",
                "tactic_args": [
                    "c7_goal : vagree v w (andimm x mask)"
                ],
                "tactic_res": [
                    "c8_goal : forall n : Int.int, eq (Int.ror n Int.zero) n",
                    "c9_goal : vagree v w (andimm x mask)",
                    "c9_H : forall n : Int.int, eq (Int.ror n Int.zero) n"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall n : Int.int, eq (Int.ror n Int.zero) n"
                ],
                "tactic_res": [
                    "c10_goal : eq (Int.ror n Int.zero) n",
                    "c10_n : Int.int"
                ]
            },
            {
                "tactic_sig": "rewrite Int.ror_rol_neg by apply _i .",
                "tactic_sig_no_out_arg": "rewrite Int.ror_rol_neg by apply _i .",
                "tactic_args": [
                    "c10_goal : eq (Int.ror n Int.zero) n",
                    "_global_1 : Z",
                    "_global_int_wordsize_divides_modulus : Z.divide (Z.of_nat Int.wordsize) Int.modulus"
                ],
                "tactic_res": [
                    "c11_goal : eq (Int.rol n (Int.neg Int.zero)) n"
                ]
            },
            {
                "tactic_sig": "rewrite Int.neg_zero .",
                "tactic_sig_no_out_arg": "rewrite Int.neg_zero .",
                "tactic_args": [
                    "c11_goal : eq (Int.rol n (Int.neg Int.zero)) n",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c12_goal : eq (Int.rol n Int.zero) n"
                ]
            },
            {
                "tactic_sig": "apply Int.rol_zero .",
                "tactic_sig_no_out_arg": "apply Int.rol_zero .",
                "tactic_args": [
                    "c12_goal : eq (Int.rol n Int.zero) n",
                    "_global_1 : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i , _i , _i in * .",
                "tactic_sig_no_out_arg": "unfold _i , _i , _i in * .",
                "tactic_args": [
                    "c9_goal : vagree v w (andimm x mask)",
                    "_global_1 : Z",
                    "_global_rolm : forall (_ : nval) (_ : Int.int) (_ : Int.int), nval",
                    "_global_rol : forall (_ : nval) (_ : Int.int), nval",
                    "_global_andimm : forall (_ : nval) (_ : Int.int), nval"
                ],
                "tactic_res": [
                    "c13_goal : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.and m mask)\n  | All => I mask\n  end",
                    "c13_H0 : vagree v w\n  match\n    match x with\n    | Nothing => Nothing\n    | I m => I (Int.and m mask)\n    | All => I mask\n    end\n  with\n  | Nothing => Nothing\n  | I m => I (Int.ror m Int.zero)\n  | All => All\n  end"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o | _o _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c13_goal : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.and m mask)\n  | All => I mask\n  end",
                    "c3_x : nval"
                ],
                "tactic_res": [
                    "c14_goal : vagree v w Nothing",
                    "c14_H2 : eq (andimm_redundant Nothing mask) true",
                    "c14_H0 : vagree v w Nothing",
                    "c15_goal : vagree v w (I (Int.and m mask))",
                    "c15_H2 : eq (andimm_redundant (I m) mask) true",
                    "c15_H0 : vagree v w (I (Int.ror (Int.and m mask) Int.zero))",
                    "c15_m : Int.int",
                    "c16_goal : vagree v w (I mask)",
                    "c16_H2 : eq (andimm_redundant All mask) true",
                    "c16_H0 : vagree v w (I (Int.ror mask Int.zero))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : vagree v w Nothing"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c3_H : eq (andb (Int.eq_dec amount Int.zero) (andimm_redundant x mask)) true",
                    "c3_H0 : vagree v w (rolm x amount mask)"
                ],
                "tactic_res": [
                    "c15_H0 : vagree v w (I (Int.and m mask))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c15_goal : vagree v w (I (Int.and m mask))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c3_H : eq (andb (Int.eq_dec amount Int.zero) (andimm_redundant x mask)) true",
                    "c3_H0 : vagree v w (rolm x amount mask)"
                ],
                "tactic_res": [
                    "c16_H0 : vagree v w (I mask)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c16_goal : vagree v w (I mask)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "zero_ext_redundant_sound",
        "proof": [
            {
                "tactic_sig": "Lemma zero_ext_redundant_sound : forall v w x n , zero_ext_redundant n x = true -> vagree v w ( zero_ext n x ) -> 0 <= n -> vagree ( Val.zero_ext n v ) w x .",
                "tactic_sig_no_out_arg": "Lemma zero_ext_redundant_sound : forall v w x n , zero_ext_redundant n x = true -> vagree v w ( zero_ext n x ) -> 0 <= n -> vagree ( Val.zero_ext n v ) w x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Z)\n  (_ : eq (zero_ext_redundant n x) true)\n  (_ : vagree v w (zero_ext n x)) (_ : Z.le 0 n),\nvagree (Val.zero_ext n v) w x"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Z)\n  (_ : eq (zero_ext_redundant n x) true)\n  (_ : vagree v w (zero_ext n x)) (_ : Z.le 0 n),\nvagree (Val.zero_ext n v) w x",
                    "_global_1 : Z",
                    "_global_zero_ext_redundant : forall (_ : Z) (_ : nval), bool"
                ],
                "tactic_res": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Z)\n  (_ : eq\n         match x with\n         | Nothing => true\n         | I m => Int.eq_dec (Int.zero_ext n m) m\n         | All => false\n         end true) (_ : vagree v w (zero_ext n x)) \n  (_ : Z.le 0 n), vagree (Val.zero_ext n v) w x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Z)\n  (_ : eq\n         match x with\n         | Nothing => true\n         | I m => Int.eq_dec (Int.zero_ext n m) m\n         | All => false\n         end true) (_ : vagree v w (zero_ext n x)) \n  (_ : Z.le 0 n), vagree (Val.zero_ext n v) w x"
                ],
                "tactic_res": [
                    "c3_goal : vagree (Val.zero_ext n v) w x",
                    "c3_v : val",
                    "c3_w : val",
                    "c3_x : nval",
                    "c3_n : Z",
                    "c3_H : eq\n  match x with\n  | Nothing => true\n  | I m => Int.eq_dec (Int.zero_ext n m) m\n  | All => false\n  end true",
                    "c3_H0 : vagree v w (zero_ext n x)",
                    "c3_H1 : Z.le 0 n"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o | _o _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : vagree (Val.zero_ext n v) w x",
                    "c3_x : nval"
                ],
                "tactic_res": [
                    "c4_goal : vagree (Val.zero_ext n v) w Nothing",
                    "c4_H0 : vagree v w (zero_ext n Nothing)",
                    "c4_H : eq true true",
                    "c5_goal : vagree (Val.zero_ext n v) w (I m)",
                    "c5_H0 : vagree v w (zero_ext n (I m))",
                    "c5_H : eq (Int.eq_dec (Int.zero_ext n m) m) true",
                    "c5_m : Int.int",
                    "c6_goal : vagree (Val.zero_ext n v) w All",
                    "c6_H0 : vagree v w (zero_ext n All)",
                    "c6_H : eq false true"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c6_goal : vagree (Val.zero_ext n v) w All"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : vagree (Val.zero_ext n v) w Nothing"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c5_goal : vagree (Val.zero_ext n v) w (I m)"
                ],
                "tactic_res": [
                    "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend",
                    "c7_H0 : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.zero_ext n m)\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                    "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                    "c8_i0 : Int.int",
                    "c8_i : Int.int"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c9_goal : iagree (Int.zero_ext n i) i0 m"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c9_goal : iagree (Int.zero_ext n i) i0 m",
                    "_global_1 : Z",
                    "c3_H : eq\n  match x with\n  | Nothing => true\n  | I m => Int.eq_dec (Int.zero_ext n m) m\n  | All => false\n  end true"
                ],
                "tactic_res": [
                    "c10_goal : iagree (Int.zero_ext n i) i0 (Int.zero_ext n m)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c10_goal : iagree (Int.zero_ext n i) i0 (Int.zero_ext n m)"
                ],
                "tactic_res": [
                    "c11_goal : forall (i1 : Z) (_ : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize))\n  (_ : eq (Int.testbit (Int.zero_ext n m) i1) true),\neq (Int.testbit (Int.zero_ext n i) i1) (Int.testbit i0 i1)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c11_goal : forall (i1 : Z) (_ : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize))\n  (_ : eq (Int.testbit (Int.zero_ext n m) i1) true),\neq (Int.testbit (Int.zero_ext n i) i1) (Int.testbit i0 i1)"
                ],
                "tactic_res": [
                    "c12_goal : eq (Int.testbit (Int.zero_ext n i) i1) (Int.testbit i0 i1)",
                    "c12_i1 : Z",
                    "c12_H2 : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)",
                    "c12_H3 : eq (Int.testbit (Int.zero_ext n m) i1) true"
                ]
            },
            {
                "tactic_sig": "autorewrite with ints .",
                "tactic_sig_no_out_arg": "autorewrite with ints .",
                "tactic_args": [
                    "c12_goal : eq (Int.testbit (Int.zero_ext n i) i1) (Int.testbit i0 i1)"
                ],
                "tactic_res": [
                    "c13_goal : eq (if zlt i1 n then Int.testbit i i1 else false) (Int.testbit i0 i1)",
                    "c14_goal : Z.le 0 i1"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c14_goal : Z.le 0 i1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "c13_goal : eq (if zlt i1 n then Int.testbit i i1 else false) (Int.testbit i0 i1)",
                    "c12_i1 : Z",
                    "c3_n : Z"
                ],
                "tactic_res": [
                    "c15_goal : eq (Int.testbit i i1) (Int.testbit i0 i1)",
                    "c15_l : Z.lt i1 n",
                    "c16_goal : eq false (Int.testbit i0 i1)",
                    "c16_g : Z.ge i1 n"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : eq (Int.testbit i i1) (Int.testbit i0 i1)",
                    "_global_1 : Z",
                    "c3_H0 : vagree v w (zero_ext n x)"
                ],
                "tactic_res": [
                    "c17_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)",
                    "c18_goal : eq (Int.testbit (Int.zero_ext n m) i1) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c18_goal : eq (Int.testbit (Int.zero_ext n m) i1) true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite Int.bits_zero_ext in _i by lia .",
                "tactic_sig_no_out_arg": "rewrite Int.bits_zero_ext in _i by lia .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c12_H3 : eq (Int.testbit (Int.zero_ext n m) i1) true"
                ],
                "tactic_res": [
                    "c16_H3 : eq (if zlt i1 n then Int.testbit m i1 else false) true"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i by auto .",
                "tactic_sig_no_out_arg": "rewrite _i in _i by auto .",
                "tactic_args": [
                    "_global_1 : Z",
                    "_global_zlt_false : forall (A : Type) (x y : Z) (a b : A) (_ : Z.ge x y),\n       eq (if zlt x y then a else b) b",
                    "c12_H3 : eq (Int.testbit (Int.zero_ext n m) i1) true"
                ],
                "tactic_res": [
                    "c16_H3 : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c16_goal : eq false (Int.testbit i0 i1)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "sign_ext_redundant_sound",
        "proof": [
            {
                "tactic_sig": "Lemma sign_ext_redundant_sound : forall v w x n , sign_ext_redundant n x = true -> vagree v w ( sign_ext n x ) -> 0 < n -> vagree ( Val.sign_ext n v ) w x .",
                "tactic_sig_no_out_arg": "Lemma sign_ext_redundant_sound : forall v w x n , sign_ext_redundant n x = true -> vagree v w ( sign_ext n x ) -> 0 < n -> vagree ( Val.sign_ext n v ) w x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Z)\n  (_ : eq (sign_ext_redundant n x) true)\n  (_ : vagree v w (sign_ext n x)) (_ : Z.lt 0 n),\nvagree (Val.sign_ext n v) w x"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (v w : val) (x : nval) (n : Z)\n  (_ : eq (sign_ext_redundant n x) true)\n  (_ : vagree v w (sign_ext n x)) (_ : Z.lt 0 n),\nvagree (Val.sign_ext n v) w x",
                    "_global_1 : Z",
                    "_global_sign_ext_redundant : forall (_ : Z) (_ : nval), bool"
                ],
                "tactic_res": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Z)\n  (_ : eq\n         match x with\n         | Nothing => true\n         | I m => Int.eq_dec (Int.zero_ext n m) m\n         | All => false\n         end true) (_ : vagree v w (sign_ext n x)) \n  (_ : Z.lt 0 n), vagree (Val.sign_ext n v) w x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (v w : val) (x : nval) (n : Z)\n  (_ : eq\n         match x with\n         | Nothing => true\n         | I m => Int.eq_dec (Int.zero_ext n m) m\n         | All => false\n         end true) (_ : vagree v w (sign_ext n x)) \n  (_ : Z.lt 0 n), vagree (Val.sign_ext n v) w x"
                ],
                "tactic_res": [
                    "c3_goal : vagree (Val.sign_ext n v) w x",
                    "c3_v : val",
                    "c3_w : val",
                    "c3_x : nval",
                    "c3_n : Z",
                    "c3_H : eq\n  match x with\n  | Nothing => true\n  | I m => Int.eq_dec (Int.zero_ext n m) m\n  | All => false\n  end true",
                    "c3_H0 : vagree v w (sign_ext n x)",
                    "c3_H1 : Z.lt 0 n"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o _o | _o _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : vagree (Val.sign_ext n v) w x",
                    "c3_x : nval"
                ],
                "tactic_res": [
                    "c4_goal : vagree (Val.sign_ext n v) w Nothing",
                    "c4_H0 : vagree v w (sign_ext n Nothing)",
                    "c4_H : eq true true",
                    "c5_goal : vagree (Val.sign_ext n v) w (I m)",
                    "c5_H0 : vagree v w (sign_ext n (I m))",
                    "c5_H : eq (Int.eq_dec (Int.zero_ext n m) m) true",
                    "c5_m : Int.int",
                    "c6_goal : vagree (Val.sign_ext n v) w All",
                    "c6_H0 : vagree v w (sign_ext n All)",
                    "c6_H : eq false true"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c6_goal : vagree (Val.sign_ext n v) w All"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c4_goal : vagree (Val.sign_ext n v) w Nothing"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "c5_goal : vagree (Val.sign_ext n v) w (I m)"
                ],
                "tactic_res": [
                    "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend",
                    "c7_H0 : match v with\n| Vint p =>\n    match w with\n    | Vint q =>\n        iagree p q\n          (Int.or (Int.zero_ext n m)\n             (Int.shl Int.one (Int.repr (Z.sub n 1))))\n    | _ => False\n    end\n| _ => True\nend"
                ]
            },
            {
                "tactic_sig": "InvAgree .",
                "tactic_sig_no_out_arg": "InvAgree .",
                "tactic_args": [
                    "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                    "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                    "c8_i0 : Int.int",
                    "c8_i : Int.int"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend"
                ],
                "tactic_res": [
                    "c9_goal : iagree (Int.sign_ext n i) i0 m"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c9_goal : iagree (Int.sign_ext n i) i0 m",
                    "_global_1 : Z",
                    "c3_H : eq\n  match x with\n  | Nothing => true\n  | I m => Int.eq_dec (Int.zero_ext n m) m\n  | All => false\n  end true"
                ],
                "tactic_res": [
                    "c10_goal : iagree (Int.sign_ext n i) i0 (Int.zero_ext n m)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c10_goal : iagree (Int.sign_ext n i) i0 (Int.zero_ext n m)"
                ],
                "tactic_res": [
                    "c11_goal : forall (i1 : Z) (_ : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize))\n  (_ : eq (Int.testbit (Int.zero_ext n m) i1) true),\neq (Int.testbit (Int.sign_ext n i) i1) (Int.testbit i0 i1)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c11_goal : forall (i1 : Z) (_ : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize))\n  (_ : eq (Int.testbit (Int.zero_ext n m) i1) true),\neq (Int.testbit (Int.sign_ext n i) i1) (Int.testbit i0 i1)"
                ],
                "tactic_res": [
                    "c12_goal : eq (Int.testbit (Int.sign_ext n i) i1) (Int.testbit i0 i1)",
                    "c12_i1 : Z",
                    "c12_H2 : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)",
                    "c12_H3 : eq (Int.testbit (Int.zero_ext n m) i1) true"
                ]
            },
            {
                "tactic_sig": "autorewrite with ints .",
                "tactic_sig_no_out_arg": "autorewrite with ints .",
                "tactic_args": [
                    "c12_goal : eq (Int.testbit (Int.sign_ext n i) i1) (Int.testbit i0 i1)"
                ],
                "tactic_res": [
                    "c13_goal : eq (Int.testbit i (if zlt i1 n then i1 else Z.sub n 1))\n  (Int.testbit i0 i1)",
                    "c14_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "c14_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "c13_goal : eq (Int.testbit i (if zlt i1 n then i1 else Z.sub n 1))\n  (Int.testbit i0 i1)",
                    "c12_i1 : Z",
                    "c3_n : Z"
                ],
                "tactic_res": [
                    "c15_goal : eq (Int.testbit i i1) (Int.testbit i0 i1)",
                    "c15_l : Z.lt i1 n",
                    "c16_goal : eq (Int.testbit i (Z.sub n 1)) (Int.testbit i0 i1)",
                    "c16_g : Z.ge i1 n"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c15_goal : eq (Int.testbit i i1) (Int.testbit i0 i1)",
                    "_global_1 : Z",
                    "c3_H0 : vagree v w (sign_ext n x)"
                ],
                "tactic_res": [
                    "c17_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)",
                    "c18_goal : eq\n  (Int.testbit\n     (Int.or (Int.zero_ext n m)\n        (Int.shl Int.one (Int.repr (Z.sub n 1)))) i1) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite Int.bits_or .",
                "tactic_sig_no_out_arg": "rewrite Int.bits_or .",
                "tactic_args": [
                    "c18_goal : eq\n  (Int.testbit\n     (Int.or (Int.zero_ext n m)\n        (Int.shl Int.one (Int.repr (Z.sub n 1)))) i1) true",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c19_goal : eq\n  (orb (Int.testbit (Int.zero_ext n m) i1)\n     (Int.testbit (Int.shl Int.one (Int.repr (Z.sub n 1))) i1)) true",
                    "c20_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c20_goal : Logic.and (Z.le 0 i1) (Z.lt i1 Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c19_goal : eq\n  (orb (Int.testbit (Int.zero_ext n m) i1)\n     (Int.testbit (Int.shl Int.one (Int.repr (Z.sub n 1))) i1)) true",
                    "_global_1 : Z",
                    "c12_H3 : eq (Int.testbit (Int.zero_ext n m) i1) true"
                ],
                "tactic_res": [
                    "c21_goal : eq (orb true (Int.testbit (Int.shl Int.one (Int.repr (Z.sub n 1))) i1))\n  true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c21_goal : eq (orb true (Int.testbit (Int.shl Int.one (Int.repr (Z.sub n 1))) i1))\n  true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite Int.bits_zero_ext in _i by lia .",
                "tactic_sig_no_out_arg": "rewrite Int.bits_zero_ext in _i by lia .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c12_H3 : eq (Int.testbit (Int.zero_ext n m) i1) true"
                ],
                "tactic_res": [
                    "c16_H3 : eq (if zlt i1 n then Int.testbit m i1 else false) true"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i by auto .",
                "tactic_sig_no_out_arg": "rewrite _i in _i by auto .",
                "tactic_args": [
                    "_global_1 : Z",
                    "_global_zlt_false : forall (A : Type) (x y : Z) (a b : A) (_ : Z.ge x y),\n       eq (if zlt x y then a else b) b",
                    "c12_H3 : eq (Int.testbit (Int.zero_ext n m) i1) true"
                ],
                "tactic_res": [
                    "c16_H3 : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c16_goal : eq (Int.testbit i (Z.sub n 1)) (Int.testbit i0 i1)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "beq_correct",
        "proof": [
            {
                "tactic_sig": "Lemma beq_correct : forall x y , beq x y = true -> eq x y .",
                "tactic_sig_no_out_arg": "Lemma beq_correct : forall x y , beq x y = true -> eq x y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y : t) (_ : Logic.eq (beq x y) true), eq x y"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (x y : t) (_ : Logic.eq (beq x y) true), eq x y",
                    "_global_1 : Z",
                    "_global_beq : forall (_ : t) (_ : t), bool"
                ],
                "tactic_res": [
                    "c2_goal : forall (x y : t) (_ : Logic.eq (eq_nval x y) true), eq x y"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (x y : t) (_ : Logic.eq (eq_nval x y) true), eq x y"
                ],
                "tactic_res": [
                    "c3_goal : eq x y",
                    "c3_x : True",
                    "c3_y : True",
                    "c3_H : Logic.eq (eq_nval x y) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c3_goal : eq x y"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "ge_refl",
        "proof": [
            {
                "tactic_sig": "Lemma ge_refl : forall x y , eq x y -> ge x y .",
                "tactic_sig_no_out_arg": "Lemma ge_refl : forall x y , eq x y -> ge x y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y : t) (_ : eq x y), ge x y"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c1_goal : forall (x y : t) (_ : eq x y), ge x y",
                    "_global_1 : Z",
                    "_global_eq : forall (_ : t) (_ : t), Prop",
                    "_global_ge : forall (_ : nval) (_ : nval), Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall (x y : t) (_ : Logic.eq x y), nge x y"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (x y : t) (_ : Logic.eq x y), nge x y"
                ],
                "tactic_res": [
                    "c3_goal : nge x y",
                    "c3_x : True",
                    "c3_y : True",
                    "c3_H : Logic.eq x y"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c3_goal : nge x y",
                    "c3_y : True"
                ],
                "tactic_res": [
                    "c4_goal : nge x x"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : nge x x",
                    "_global_1 : Z",
                    "_global_nge_refl : forall x : nval, nge x x"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "ge_trans",
        "proof": [
            {
                "tactic_sig": "Lemma ge_trans : forall x y z , ge x y -> ge y z -> ge x z .",
                "tactic_sig_no_out_arg": "Lemma ge_trans : forall x y z , ge x y -> ge y z -> ge x z .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y z : nval) (_ : ge x y) (_ : ge y z), ge x z"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (x y z : nval) (_ : ge x y) (_ : ge y z), ge x z",
                    "_global_1 : Z",
                    "_global_ge : forall (_ : nval) (_ : nval), Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall (x y z : nval) (_ : nge x y) (_ : nge y z), nge x z"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (x y z : nval) (_ : nge x y) (_ : nge y z), nge x z"
                ],
                "tactic_res": [
                    "c3_goal : nge x z",
                    "c3_x : nval",
                    "c3_y : nval",
                    "c3_z : nval",
                    "c3_H : nge x y",
                    "c3_H0 : nge y z"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c3_goal : nge x z",
                    "_global_1 : Z",
                    "_global_nge_trans : forall (x y : nval) (_ : nge x y) (z : nval) (_ : nge y z), nge x z"
                ],
                "tactic_res": [
                    "c4_goal : nge x ?y",
                    "c5_goal : nge ?y z"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c4_goal : nge x ?y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c5_goal : nge y z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "ge_bot",
        "proof": [
            {
                "tactic_sig": "Lemma ge_bot : forall x , ge x bot .",
                "tactic_sig_no_out_arg": "Lemma ge_bot : forall x , ge x bot .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : nval, ge x bot"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": [
                    "c2_goal : ge x bot",
                    "c2_x : nval"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c2_goal : ge x bot"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "ge_lub_left",
        "proof": [
            {
                "tactic_sig": "Lemma ge_lub_left : forall x y , ge ( lub x y ) x .",
                "tactic_sig_no_out_arg": "Lemma ge_lub_left : forall x y , ge ( lub x y ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : nval, ge (lub x y) x"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c1_goal : forall x y : nval, ge (lub x y) x",
                    "_global_1 : Z",
                    "_global_nge_lub_l : forall x y : nval, nge (nlub x y) x"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "ge_lub_right",
        "proof": [
            {
                "tactic_sig": "Lemma ge_lub_right : forall x y , ge ( lub x y ) y .",
                "tactic_sig_no_out_arg": "Lemma ge_lub_right : forall x y , ge ( lub x y ) y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : nval, ge (lub x y) y"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c1_goal : forall x y : nval, ge (lub x y) y",
                    "_global_1 : Z",
                    "_global_nge_lub_r : forall x y : nval, nge (nlub x y) y"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nreg_agree",
        "proof": [
            {
                "tactic_sig": "Lemma nreg_agree : forall rs1 rs2 ne r , eagree rs1 rs2 ne -> vagree rs1#r rs2#r ( nreg ne r ) .",
                "tactic_sig_no_out_arg": "Lemma nreg_agree : forall rs1 rs2 ne r , eagree rs1 rs2 ne -> vagree rs1#r rs2#r ( nreg ne r ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
                ],
                "tactic_res": [
                    "c2_goal : vagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)",
                    "c2_rs1 : regset",
                    "c2_rs2 : regset",
                    "c2_ne : nenv",
                    "c2_r : positive",
                    "c2_H : eagree rs1 rs2 ne"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c2_goal : vagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)",
                    "_global_1 : Z",
                    "c2_H : eagree rs1 rs2 ne"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eagree_ge",
        "proof": [
            {
                "tactic_sig": "Lemma eagree_ge : forall e1 e2 ne ne' , eagree e1 e2 ne -> NE.ge ne ne' -> eagree e1 e2 ne' .",
                "tactic_sig_no_out_arg": "Lemma eagree_ge : forall e1 e2 ne ne' , eagree e1 e2 ne -> NE.ge ne ne' -> eagree e1 e2 ne' .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (e1 e2 : regset) (ne : nenv) (ne' : NE.t) (_ : eagree e1 e2 ne)\n  (_ : NE.ge ne ne'), eagree e1 e2 ne'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (e1 e2 : regset) (ne : nenv) (ne' : NE.t) (_ : eagree e1 e2 ne)\n  (_ : NE.ge ne ne'), eagree e1 e2 ne'"
                ],
                "tactic_res": [
                    "c2_goal : eagree e1 e2 ne'",
                    "c2_e1 : regset",
                    "c2_e2 : regset",
                    "c2_ne : nenv",
                    "c2_ne' : NE.t",
                    "c2_H : eagree e1 e2 ne",
                    "c2_H0 : NE.ge ne ne'"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : eagree e1 e2 ne'"
                ],
                "tactic_res": [
                    "c3_goal : forall r : positive,\nvagree (Regmap.get val r e1) (Regmap.get val r e2) (NE.get r ne')"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall r : positive,\nvagree (Regmap.get val r e1) (Regmap.get val r e2) (NE.get r ne')"
                ],
                "tactic_res": [
                    "c4_goal : vagree (Regmap.get val r e1) (Regmap.get val r e2) (NE.get r ne')",
                    "c4_r : positive"
                ]
            },
            {
                "tactic_sig": "apply _i with ( NE._i _i _i ) .",
                "tactic_sig_no_out_arg": "apply _i with ( NE._i _i _i ) .",
                "tactic_args": [
                    "c4_goal : vagree (Regmap.get val r e1) (Regmap.get val r e2) (NE.get r ne')",
                    "_global_1 : Z",
                    "_global_nge_agree : forall (v w : val) (x y : nval) (_ : nge x y) (_ : vagree v w x),\n       vagree v w y",
                    "_global_get : forall (_ : nat) (_ : string), option Ascii.ascii",
                    "c4_r : positive",
                    "c2_ne : nenv"
                ],
                "tactic_res": [
                    "c5_goal : nge (NE.get r ne) (NE.get r ne')",
                    "c6_goal : vagree (Regmap.get val r e1) (Regmap.get val r e2) (NE.get r ne)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : vagree (Regmap.get val r e1) (Regmap.get val r e2) (NE.get r ne)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c5_goal : nge (NE.get r ne) (NE.get r ne')",
                    "_global_1 : Z",
                    "c2_H0 : NE.ge ne ne'"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eagree_bot",
        "proof": [
            {
                "tactic_sig": "Lemma eagree_bot : forall e1 e2 , eagree e1 e2 NE.bot .",
                "tactic_sig_no_out_arg": "Lemma eagree_bot : forall e1 e2 , eagree e1 e2 NE.bot .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall e1 e2 : regset, eagree e1 e2 NE.bot"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall e1 e2 : regset, eagree e1 e2 NE.bot"
                ],
                "tactic_res": [
                    "c2_goal : eagree e1 e2 NE.bot",
                    "c2_e1 : regset",
                    "c2_e2 : regset"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : eagree e1 e2 NE.bot"
                ],
                "tactic_res": [
                    "c3_goal : forall r : positive,\nvagree (Regmap.get val r e1) (Regmap.get val r e2) (NE.get r NE.bot)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall r : positive,\nvagree (Regmap.get val r e1) (Regmap.get val r e2) (NE.get r NE.bot)"
                ],
                "tactic_res": [
                    "c4_goal : vagree (Regmap.get val r e1) (Regmap.get val r e2) (NE.get r NE.bot)",
                    "c4_r : positive"
                ]
            },
            {
                "tactic_sig": "rewrite NE.get_bot .",
                "tactic_sig_no_out_arg": "rewrite NE.get_bot .",
                "tactic_args": [
                    "c4_goal : vagree (Regmap.get val r e1) (Regmap.get val r e2) (NE.get r NE.bot)",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c5_goal : vagree (Regmap.get val r e1) (Regmap.get val r e2) NVal.bot"
                ]
            },
            {
                "tactic_sig": "exact Logic.I .",
                "tactic_sig_no_out_arg": "exact Logic.I .",
                "tactic_args": [
                    "c5_goal : vagree (Regmap.get val r e1) (Regmap.get val r e2) NVal.bot"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eagree_same",
        "proof": [
            {
                "tactic_sig": "Lemma eagree_same : forall e ne , eagree e e ne .",
                "tactic_sig_no_out_arg": "Lemma eagree_same : forall e ne , eagree e e ne .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (e : regset) (ne : nenv), eagree e e ne"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (e : regset) (ne : nenv), eagree e e ne"
                ],
                "tactic_res": [
                    "c2_goal : eagree e e ne",
                    "c2_e : regset",
                    "c2_ne : nenv"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : eagree e e ne"
                ],
                "tactic_res": [
                    "c3_goal : forall r : positive,\nvagree (Regmap.get val r e) (Regmap.get val r e) (NE.get r ne)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall r : positive,\nvagree (Regmap.get val r e) (Regmap.get val r e) (NE.get r ne)"
                ],
                "tactic_res": [
                    "c4_goal : vagree (Regmap.get val r e) (Regmap.get val r e) (NE.get r ne)",
                    "c4_r : positive"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : vagree (Regmap.get val r e) (Regmap.get val r e) (NE.get r ne)",
                    "_global_1 : Z",
                    "_global_vagree_same : forall (v : val) (x : nval), vagree v v x"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eagree_update_1",
        "proof": [
            {
                "tactic_sig": "Lemma eagree_update_1 : forall e1 e2 ne v1 v2 nv r , eagree e1 e2 ne -> vagree v1 v2 nv -> eagree ( e1#r <- v1 ) ( e2#r <- v2 ) ( NE.set r nv ne ) .",
                "tactic_sig_no_out_arg": "Lemma eagree_update_1 : forall e1 e2 ne v1 v2 nv r , eagree e1 e2 ne -> vagree v1 v2 nv -> eagree ( e1#r <- v1 ) ( e2#r <- v2 ) ( NE.set r nv ne ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (e1 e2 : regset) (ne : nenv) (v1 v2 : val) \n  (nv : nval) (r : positive) (_ : eagree e1 e2 ne)\n  (_ : vagree v1 v2 nv),\neagree (Regmap.set val r v1 e1) (Regmap.set val r v2 e2)\n  (NE.set r nv ne)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (e1 e2 : regset) (ne : nenv) (v1 v2 : val) \n  (nv : nval) (r : positive) (_ : eagree e1 e2 ne)\n  (_ : vagree v1 v2 nv),\neagree (Regmap.set val r v1 e1) (Regmap.set val r v2 e2)\n  (NE.set r nv ne)"
                ],
                "tactic_res": [
                    "c2_goal : eagree (Regmap.set val r v1 e1) (Regmap.set val r v2 e2)\n  (NE.set r nv ne)",
                    "c2_e1 : regset",
                    "c2_e2 : regset",
                    "c2_ne : nenv",
                    "c2_v1 : val",
                    "c2_v2 : val",
                    "c2_nv : nval",
                    "c2_r : positive",
                    "c2_H : eagree e1 e2 ne",
                    "c2_H0 : vagree v1 v2 nv"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : eagree (Regmap.set val r v1 e1) (Regmap.set val r v2 e2)\n  (NE.set r nv ne)"
                ],
                "tactic_res": [
                    "c3_goal : forall r0 : positive,\nvagree (Regmap.get val r0 (Regmap.set val r v1 e1))\n  (Regmap.get val r0 (Regmap.set val r v2 e2))\n  (NE.get r0 (NE.set r nv ne))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall r0 : positive,\nvagree (Regmap.get val r0 (Regmap.set val r v1 e1))\n  (Regmap.get val r0 (Regmap.set val r v2 e2))\n  (NE.get r0 (NE.set r nv ne))"
                ],
                "tactic_res": [
                    "c4_goal : vagree (Regmap.get val r0 (Regmap.set val r v1 e1))\n  (Regmap.get val r0 (Regmap.set val r v2 e2))\n  (NE.get r0 (NE.set r nv ne))",
                    "c4_r0 : positive"
                ]
            },
            {
                "tactic_sig": "rewrite NE.gsspec .",
                "tactic_sig_no_out_arg": "rewrite NE.gsspec .",
                "tactic_args": [
                    "c4_goal : vagree (Regmap.get val r0 (Regmap.set val r v1 e1))\n  (Regmap.get val r0 (Regmap.set val r v2 e2))\n  (NE.get r0 (NE.set r nv ne))",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c5_goal : vagree (Regmap.get val r0 (Regmap.set val r v1 e1))\n  (Regmap.get val r0 (Regmap.set val r v2 e2))\n  (if peq r0 r then nv else NE.get r0 ne)"
                ]
            },
            {
                "tactic_sig": "rewrite ! PMap.gsspec .",
                "tactic_sig_no_out_arg": "rewrite ! PMap.gsspec .",
                "tactic_args": [
                    "c5_goal : vagree (Regmap.get val r0 (Regmap.set val r v1 e1))\n  (Regmap.get val r0 (Regmap.set val r v2 e2))\n  (if peq r0 r then nv else NE.get r0 ne)",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c6_goal : vagree (if peq r0 r then v1 else PMap.get r0 e1)\n  (if peq r0 r then v2 else PMap.get r0 e2)\n  (if peq r0 r then nv else NE.get r0 ne)"
                ]
            },
            {
                "tactic_sig": "destruct ( peq _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( peq _i _i ) .",
                "tactic_args": [
                    "c6_goal : vagree (if peq r0 r then v1 else PMap.get r0 e1)\n  (if peq r0 r then v2 else PMap.get r0 e2)\n  (if peq r0 r then nv else NE.get r0 ne)",
                    "c4_r0 : positive",
                    "c2_r : positive"
                ],
                "tactic_res": [
                    "c7_goal : vagree v1 v2 nv",
                    "c7_e : eq r0 r",
                    "c8_goal : vagree (PMap.get r0 e1) (PMap.get r0 e2) (NE.get r0 ne)",
                    "c8_n : not (eq r0 r)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : vagree v1 v2 nv"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : vagree (PMap.get r0 e1) (PMap.get r0 e2) (NE.get r0 ne)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eagree_update",
        "proof": [
            {
                "tactic_sig": "Lemma eagree_update : forall e1 e2 ne v1 v2 r , vagree v1 v2 ( nreg ne r ) -> eagree e1 e2 ( NE.set r Nothing ne ) -> eagree ( e1#r <- v1 ) ( e2#r <- v2 ) ne .",
                "tactic_sig_no_out_arg": "Lemma eagree_update : forall e1 e2 ne v1 v2 r , vagree v1 v2 ( nreg ne r ) -> eagree e1 e2 ( NE.set r Nothing ne ) -> eagree ( e1#r <- v1 ) ( e2#r <- v2 ) ne .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (e1 e2 : regset) (ne : nenv) (v1 v2 : val) \n  (r : reg) (_ : vagree v1 v2 (nreg ne r))\n  (_ : eagree e1 e2 (NE.set r Nothing ne)),\neagree (Regmap.set val r v1 e1) (Regmap.set val r v2 e2) ne"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (e1 e2 : regset) (ne : nenv) (v1 v2 : val) \n  (r : reg) (_ : vagree v1 v2 (nreg ne r))\n  (_ : eagree e1 e2 (NE.set r Nothing ne)),\neagree (Regmap.set val r v1 e1) (Regmap.set val r v2 e2) ne"
                ],
                "tactic_res": [
                    "c2_goal : eagree (Regmap.set val r v1 e1) (Regmap.set val r v2 e2) ne",
                    "c2_e1 : regset",
                    "c2_e2 : regset",
                    "c2_ne : nenv",
                    "c2_v1 : val",
                    "c2_v2 : val",
                    "c2_r : reg",
                    "c2_H : vagree v1 v2 (nreg ne r)",
                    "c2_H0 : eagree e1 e2 (NE.set r Nothing ne)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : eagree (Regmap.set val r v1 e1) (Regmap.set val r v2 e2) ne"
                ],
                "tactic_res": [
                    "c3_goal : forall r0 : positive,\nvagree (Regmap.get val r0 (Regmap.set val r v1 e1))\n  (Regmap.get val r0 (Regmap.set val r v2 e2)) (NE.get r0 ne)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall r0 : positive,\nvagree (Regmap.get val r0 (Regmap.set val r v1 e1))\n  (Regmap.get val r0 (Regmap.set val r v2 e2)) (NE.get r0 ne)"
                ],
                "tactic_res": [
                    "c4_goal : vagree (Regmap.get val r0 (Regmap.set val r v1 e1))\n  (Regmap.get val r0 (Regmap.set val r v2 e2)) (NE.get r0 ne)",
                    "c4_r0 : positive"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "c2_H0 : eagree e1 e2 (NE.set r Nothing ne)",
                    "c4_r0 : positive"
                ],
                "tactic_res": [
                    "c4_H0 : vagree (Regmap.get val r0 e1) (Regmap.get val r0 e2)\n  (NE.get r0 (NE.set r Nothing ne))"
                ]
            },
            {
                "tactic_sig": "rewrite NE.gsspec in _i .",
                "tactic_sig_no_out_arg": "rewrite NE.gsspec in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c2_H0 : eagree e1 e2 (NE.set r Nothing ne)"
                ],
                "tactic_res": [
                    "c4_H0 : vagree (Regmap.get val r0 e1) (Regmap.get val r0 e2)\n  (if peq r0 r then Nothing else NE.get r0 ne)"
                ]
            },
            {
                "tactic_sig": "rewrite ! PMap.gsspec .",
                "tactic_sig_no_out_arg": "rewrite ! PMap.gsspec .",
                "tactic_args": [
                    "c4_goal : vagree (Regmap.get val r0 (Regmap.set val r v1 e1))\n  (Regmap.get val r0 (Regmap.set val r v2 e2)) (NE.get r0 ne)",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c5_goal : vagree (if peq r0 r then v1 else PMap.get r0 e1)\n  (if peq r0 r then v2 else PMap.get r0 e2) (NE.get r0 ne)"
                ]
            },
            {
                "tactic_sig": "destruct ( peq _i _i ) as [  _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( peq _i _i ) .",
                "tactic_args": [
                    "c5_goal : vagree (if peq r0 r then v1 else PMap.get r0 e1)\n  (if peq r0 r then v2 else PMap.get r0 e2) (NE.get r0 ne)",
                    "c4_r0 : positive",
                    "c2_r : reg"
                ],
                "tactic_res": [
                    "c6_goal : vagree v1 v2 (NE.get r0 ne)",
                    "c6_H0 : vagree (Regmap.get val r0 e1) (Regmap.get val r0 e2) Nothing",
                    "c6_e : eq r0 r",
                    "c7_goal : vagree (PMap.get r0 e1) (PMap.get r0 e2) (NE.get r0 ne)",
                    "c7_H0 : vagree (Regmap.get val r0 e1) (Regmap.get val r0 e2) (NE.get r0 ne)",
                    "c7_n : not (eq r0 r)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c6_goal : vagree v1 v2 (NE.get r0 ne)",
                    "c4_r0 : positive"
                ],
                "tactic_res": [
                    "c8_goal : vagree v1 v2 (NE.get r ne)",
                    "c8_H0 : vagree (Regmap.get val r e1) (Regmap.get val r e2) Nothing"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : vagree v1 v2 (NE.get r ne)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : vagree (PMap.get r0 e1) (PMap.get r0 e2) (NE.get r0 ne)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eagree_update_dead",
        "proof": [
            {
                "tactic_sig": "Lemma eagree_update_dead : forall e1 e2 ne v1 r , nreg ne r = Nothing -> eagree e1 e2 ne -> eagree ( e1#r <- v1 ) e2 ne .",
                "tactic_sig_no_out_arg": "Lemma eagree_update_dead : forall e1 e2 ne v1 r , nreg ne r = Nothing -> eagree e1 e2 ne -> eagree ( e1#r <- v1 ) e2 ne .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (e1 e2 : regset) (ne : nenv) (v1 : val) (r : reg)\n  (_ : eq (nreg ne r) Nothing) (_ : eagree e1 e2 ne),\neagree (Regmap.set val r v1 e1) e2 ne"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (e1 e2 : regset) (ne : nenv) (v1 : val) (r : reg)\n  (_ : eq (nreg ne r) Nothing) (_ : eagree e1 e2 ne),\neagree (Regmap.set val r v1 e1) e2 ne"
                ],
                "tactic_res": [
                    "c2_goal : eagree (Regmap.set val r v1 e1) e2 ne",
                    "c2_e1 : regset",
                    "c2_e2 : regset",
                    "c2_ne : nenv",
                    "c2_v1 : val",
                    "c2_r : reg",
                    "c2_H : eq (nreg ne r) Nothing",
                    "c2_H0 : eagree e1 e2 ne"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c2_goal : eagree (Regmap.set val r v1 e1) e2 ne"
                ],
                "tactic_res": [
                    "c3_goal : forall r0 : positive,\nvagree (Regmap.get val r0 (Regmap.set val r v1 e1))\n  (Regmap.get val r0 e2) (NE.get r0 ne)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall r0 : positive,\nvagree (Regmap.get val r0 (Regmap.set val r v1 e1))\n  (Regmap.get val r0 e2) (NE.get r0 ne)"
                ],
                "tactic_res": [
                    "c4_goal : vagree (Regmap.get val r0 (Regmap.set val r v1 e1))\n  (Regmap.get val r0 e2) (NE.get r0 ne)",
                    "c4_r0 : positive"
                ]
            },
            {
                "tactic_sig": "rewrite PMap.gsspec .",
                "tactic_sig_no_out_arg": "rewrite PMap.gsspec .",
                "tactic_args": [
                    "c4_goal : vagree (Regmap.get val r0 (Regmap.set val r v1 e1))\n  (Regmap.get val r0 e2) (NE.get r0 ne)",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c5_goal : vagree (if peq r0 r then v1 else PMap.get r0 e1) (Regmap.get val r0 e2)\n  (NE.get r0 ne)"
                ]
            },
            {
                "tactic_sig": "destruct ( peq _i _i ) as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( peq _i _i ) .",
                "tactic_args": [
                    "c5_goal : vagree (if peq r0 r then v1 else PMap.get r0 e1) (Regmap.get val r0 e2)\n  (NE.get r0 ne)",
                    "c4_r0 : positive",
                    "c2_r : reg"
                ],
                "tactic_res": [
                    "c6_goal : vagree v1 (Regmap.get val r0 e2) (NE.get r0 ne)",
                    "c6_e : eq r0 r",
                    "c7_goal : vagree (PMap.get r0 e1) (Regmap.get val r0 e2) (NE.get r0 ne)",
                    "c7_n : not (eq r0 r)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : vagree (PMap.get r0 e1) (Regmap.get val r0 e2) (NE.get r0 ne)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "c6_goal : vagree v1 (Regmap.get val r0 e2) (NE.get r0 ne)"
                ],
                "tactic_res": [
                    "c8_goal : vagree v1 (Regmap.get val r e2) (NE.get r ne)"
                ]
            },
            {
                "tactic_sig": "unfold _i in _i .",
                "tactic_sig_no_out_arg": "unfold _i in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "_global_nreg : forall (_ : nenv) (_ : reg), NVal.t",
                    "c2_H : eq (nreg ne r) Nothing"
                ],
                "tactic_res": [
                    "c8_H : eq (NE.get r ne) Nothing"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c8_goal : vagree v1 (Regmap.get val r e2) (NE.get r ne)",
                    "_global_1 : Z",
                    "c2_H : eq (nreg ne r) Nothing"
                ],
                "tactic_res": [
                    "c9_goal : vagree v1 (Regmap.get val r e2) Nothing"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c9_goal : vagree v1 (Regmap.get val r e2) Nothing"
                ],
                "tactic_res": [
                    "c10_goal : True"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : True"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nlive_all",
        "proof": [
            {
                "tactic_sig": "Lemma nlive_all : forall b ofs , nlive nmem_all b ofs .",
                "tactic_sig_no_out_arg": "Lemma nlive_all : forall b ofs , nlive nmem_all b ofs .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (b : block) (ofs : Z), nlive nmem_all b ofs",
                    "c1_sp : block",
                    "c1_ge : genv"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (b : block) (ofs : Z), nlive nmem_all b ofs"
                ],
                "tactic_res": [
                    "c2_goal : nlive nmem_all b ofs",
                    "c2_b : block",
                    "c2_ofs : Z"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c2_goal : nlive nmem_all b ofs"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : eq b sp, not (ISet.In ofs ISet.empty)",
                    "c4_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id (PTree.empty ISet.t)) (Some iv)),\nnot (ISet.In ofs iv)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall _ : eq b sp, not (ISet.In ofs ISet.empty)"
                ],
                "tactic_res": [
                    "c5_goal : not (ISet.In ofs ISet.empty)",
                    "c5_H : eq b sp"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id (PTree.empty ISet.t)) (Some iv)),\nnot (ISet.In ofs iv)"
                ],
                "tactic_res": [
                    "c6_goal : not (ISet.In ofs iv)",
                    "c6_id : ident",
                    "c6_iv : ISet.t",
                    "c6_H : eq (Genv.find_symbol ge id) (Some b)",
                    "c6_H0 : eq (PTree.get id (PTree.empty ISet.t)) (Some iv)"
                ]
            },
            {
                "tactic_sig": "apply ISet.In_empty .",
                "tactic_sig_no_out_arg": "apply ISet.In_empty .",
                "tactic_args": [
                    "c5_goal : not (ISet.In ofs ISet.empty)",
                    "_global_1 : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite PTree.gempty in _i .",
                "tactic_sig_no_out_arg": "rewrite PTree.gempty in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c6_H0 : eq (PTree.get id (PTree.empty ISet.t)) (Some iv)"
                ],
                "tactic_res": [
                    "c6_H0 : eq None (Some iv)"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c6_goal : not (ISet.In ofs iv)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nlive_add",
        "proof": [
            {
                "tactic_sig": "Lemma nlive_add : forall bc b ofs p nm sz i , genv_match bc ge -> bc sp = BCstack -> pmatch bc b ofs p -> Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz -> nlive ( nmem_add nm p sz ) b i .",
                "tactic_sig_no_out_arg": "Lemma nlive_add : forall bc b ofs p nm sz i , genv_match bc ge -> bc sp = BCstack -> pmatch bc b ofs p -> Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz -> nlive ( nmem_add nm p sz ) b i .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (bc : block_classification) (b : block) (ofs : Ptrofs.int)\n  (p : aptr) (nm : nmem) (sz i : Z) (_ : genv_match bc ge)\n  (_ : eq (bc sp) BCstack) (_ : pmatch bc b ofs p)\n  (_ : Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n         (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz))),\nnlive (nmem_add nm p sz) b i",
                    "c1_sp : block",
                    "c1_ge : genv"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (bc : block_classification) (b : block) (ofs : Ptrofs.int)\n  (p : aptr) (nm : nmem) (sz i : Z) (_ : genv_match bc ge)\n  (_ : eq (bc sp) BCstack) (_ : pmatch bc b ofs p)\n  (_ : Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n         (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz))),\nnlive (nmem_add nm p sz) b i"
                ],
                "tactic_res": [
                    "c2_goal : nlive (nmem_add nm p sz) b i",
                    "c2_bc : block_classification",
                    "c2_b : block",
                    "c2_ofs : Ptrofs.int",
                    "c2_p : aptr",
                    "c2_nm : nmem",
                    "c2_sz : Z",
                    "c2_i : Z",
                    "c2_H : genv_match bc ge",
                    "c2_H0 : eq (bc sp) BCstack",
                    "c2_H1 : pmatch bc b ofs p",
                    "c2_H2 : Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n  (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz))"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c2_goal : nlive (nmem_add nm p sz) b i",
                    "_global_1 : Z",
                    "_global_nmem_add : forall (_ : nmem) (_ : aptr) (_ : Z), nmem"
                ],
                "tactic_res": [
                    "c3_goal : nlive\n  match nm with\n  | NMemDead => nmem_all\n  | NMem stk gl =>\n      match p with\n      | Gl id ofs =>\n          match PTree.get id gl with\n          | Some iv =>\n              NMem stk\n                (PTree.set id\n                   (ISet.remove (Ptrofs.unsigned ofs)\n                      (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)\n          | None => nm\n          end\n      | Glo id => NMem stk (PTree.remove id gl)\n      | Stk ofs =>\n          NMem\n            (ISet.remove (Ptrofs.unsigned ofs)\n               (Z.add (Ptrofs.unsigned ofs) sz) stk) gl\n      | Stack => NMem ISet.empty gl\n      | _ => nmem_all\n      end\n  end b i"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : nlive\n  match nm with\n  | NMemDead => nmem_all\n  | NMem stk gl =>\n      match p with\n      | Gl id ofs =>\n          match PTree.get id gl with\n          | Some iv =>\n              NMem stk\n                (PTree.set id\n                   (ISet.remove (Ptrofs.unsigned ofs)\n                      (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)\n          | None => nm\n          end\n      | Glo id => NMem stk (PTree.remove id gl)\n      | Stk ofs =>\n          NMem\n            (ISet.remove (Ptrofs.unsigned ofs)\n               (Z.add (Ptrofs.unsigned ofs) sz) stk) gl\n      | Stack => NMem ISet.empty gl\n      | _ => nmem_all\n      end\n  end b i",
                    "c2_nm : nmem"
                ],
                "tactic_res": [
                    "c4_goal : nlive nmem_all b i",
                    "c5_goal : nlive\n  match p with\n  | Gl id ofs =>\n      match PTree.get id gl with\n      | Some iv =>\n          NMem stk\n            (PTree.set id\n               (ISet.remove (Ptrofs.unsigned ofs)\n                  (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)\n      | None => NMem stk gl\n      end\n  | Glo id => NMem stk (PTree.remove id gl)\n  | Stk ofs =>\n      NMem\n        (ISet.remove (Ptrofs.unsigned ofs)\n           (Z.add (Ptrofs.unsigned ofs) sz) stk) gl\n  | Stack => NMem ISet.empty gl\n  | _ => nmem_all\n  end b i",
                    "c5_gl : PTree.t ISet.t",
                    "c5_stk : ISet.t"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c4_goal : nlive nmem_all b i",
                    "_global_1 : Z",
                    "_global_nlive_all : forall (b : block) (ofs : Z), nlive nmem_all b ofs"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c5_goal : nlive\n  match p with\n  | Gl id ofs =>\n      match PTree.get id gl with\n      | Some iv =>\n          NMem stk\n            (PTree.set id\n               (ISet.remove (Ptrofs.unsigned ofs)\n                  (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)\n      | None => NMem stk gl\n      end\n  | Glo id => NMem stk (PTree.remove id gl)\n  | Stk ofs =>\n      NMem\n        (ISet.remove (Ptrofs.unsigned ofs)\n           (Z.add (Ptrofs.unsigned ofs) sz) stk) gl\n  | Stack => NMem ISet.empty gl\n  | _ => nmem_all\n  end b i",
                    "c2_H1 : pmatch bc b ofs p"
                ],
                "tactic_res": [
                    "c6_goal : nlive\n  match PTree.get id gl with\n  | Some iv =>\n      NMem stk\n        (PTree.set id\n           (ISet.remove (Ptrofs.unsigned ofs)\n              (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)\n  | None => NMem stk gl\n  end b i",
                    "c6_H3 : eq (bc b) (BCglob id)",
                    "c6_id : ident",
                    "c7_goal : nlive (NMem stk (PTree.remove id gl)) b i",
                    "c7_H3 : eq (bc b) (BCglob id)",
                    "c7_id : ident",
                    "c8_goal : nlive nmem_all b i",
                    "c8_H3 : eq (bc b) (BCglob id)",
                    "c8_id : ident",
                    "c9_goal : nlive\n  (NMem\n     (ISet.remove (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz) stk) gl) b i",
                    "c9_H3 : eq (bc b) BCstack",
                    "c10_goal : nlive (NMem ISet.empty gl) b i",
                    "c10_H3 : eq (bc b) BCstack",
                    "c11_goal : nlive nmem_all b i",
                    "c11_H4 : not (eq (bc b) BCinvalid)",
                    "c11_H3 : not (eq (bc b) BCstack)",
                    "c12_goal : nlive nmem_all b i",
                    "c12_H3 : not (eq (bc b) BCinvalid)"
                ]
            },
            {
                "tactic_sig": "try ( apply nlive_all ) .",
                "tactic_sig_no_out_arg": "try ( apply nlive_all ) .",
                "tactic_args": [
                    "c8_goal : nlive nmem_all b i"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( apply nlive_all ) .",
                "tactic_sig_no_out_arg": "try ( apply nlive_all ) .",
                "tactic_args": [
                    "c11_goal : nlive nmem_all b i"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( apply nlive_all ) .",
                "tactic_sig_no_out_arg": "try ( apply nlive_all ) .",
                "tactic_args": [
                    "c12_goal : nlive nmem_all b i"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( Genv.find_symbol _i _i = Some _i ) by ( eapply _i ; eauto ) .",
                "tactic_sig_no_out_arg": "assert ( Genv.find_symbol _i _i = Some _i ) by ( eapply _i ; eauto ) .",
                "tactic_args": [
                    "c1_ge : genv",
                    "c6_id : ident",
                    "c2_b : block",
                    "c2_H : genv_match bc ge"
                ],
                "tactic_res": [
                    "c6_H1 : eq (Genv.find_symbol ge id) (Some b)"
                ]
            },
            {
                "tactic_sig": "destruct gl!id as [ iv| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct gl!id as [ iv| ] eqn : NG .",
                "tactic_args": [
                    "c6_goal : nlive\n  match PTree.get id gl with\n  | Some iv =>\n      NMem stk\n        (PTree.set id\n           (ISet.remove (Ptrofs.unsigned ofs)\n              (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)\n  | None => NMem stk gl\n  end b i"
                ],
                "tactic_res": [
                    "c13_goal : nlive\n  (NMem stk\n     (PTree.set id\n        (ISet.remove (Ptrofs.unsigned ofs)\n           (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)) b i",
                    "c13_NG : eq (PTree.get id gl) (Some iv)",
                    "c13_iv : ISet.t",
                    "c14_goal : nlive (NMem stk gl) b i",
                    "c14_NG : eq (PTree.get id gl) None"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c13_goal : nlive\n  (NMem stk\n     (PTree.set id\n        (ISet.remove (Ptrofs.unsigned ofs)\n           (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)) b i"
                ],
                "tactic_res": [
                    "c15_goal : forall _ : eq b sp, not (ISet.In i stk)",
                    "c16_goal : forall (id0 : ident) (iv0 : ISet.t)\n  (_ : eq (Genv.find_symbol ge id0) (Some b))\n  (_ : eq\n         (PTree.get id0\n            (PTree.set id\n               (ISet.remove (Ptrofs.unsigned ofs)\n                  (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)) \n         (Some iv0)), not (ISet.In i iv0)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c15_goal : forall _ : eq b sp, not (ISet.In i stk)"
                ],
                "tactic_res": [
                    "c17_goal : not (ISet.In i stk)",
                    "c17_H4 : eq b sp"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c16_goal : forall (id0 : ident) (iv0 : ISet.t)\n  (_ : eq (Genv.find_symbol ge id0) (Some b))\n  (_ : eq\n         (PTree.get id0\n            (PTree.set id\n               (ISet.remove (Ptrofs.unsigned ofs)\n                  (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)) \n         (Some iv0)), not (ISet.In i iv0)"
                ],
                "tactic_res": [
                    "c18_goal : not (ISet.In i iv0)",
                    "c18_id0 : ident",
                    "c18_iv0 : ISet.t",
                    "c18_H4 : eq (Genv.find_symbol ge id0) (Some b)",
                    "c18_H5 : eq\n  (PTree.get id0\n     (PTree.set id\n        (ISet.remove (Ptrofs.unsigned ofs)\n           (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)) \n  (Some iv0)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c17_goal : not (ISet.In i stk)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( _i = _i ) by ( eapply Genv.genv_vars_inj ; eauto ) .",
                "tactic_sig_no_out_arg": "assert ( _i = _i ) by ( eapply Genv.genv_vars_inj ; eauto ) .",
                "tactic_args": [
                    "c18_id0 : ident",
                    "c6_id : ident"
                ],
                "tactic_res": [
                    "c18_H6 : eq id0 id"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c18_id0 : ident"
                ],
                "tactic_res": [
                    "c18_H4 : eq (Genv.find_symbol ge id) (Some b)",
                    "c18_H5 : eq\n  (PTree.get id\n     (PTree.set id\n        (ISet.remove (Ptrofs.unsigned ofs)\n           (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)) \n  (Some iv0)"
                ]
            },
            {
                "tactic_sig": "rewrite PTree.gss in _i .",
                "tactic_sig_no_out_arg": "rewrite PTree.gss in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c18_H5 : eq\n  (PTree.get id0\n     (PTree.set id\n        (ISet.remove (Ptrofs.unsigned ofs)\n           (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)) \n  (Some iv0)"
                ],
                "tactic_res": [
                    "c18_H5 : eq\n  (Some\n     (ISet.remove (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz) iv)) (Some iv0)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c18_goal : not (ISet.In i iv0)",
                    "c18_H5 : eq\n  (PTree.get id0\n     (PTree.set id\n        (ISet.remove (Ptrofs.unsigned ofs)\n           (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)) \n  (Some iv0)"
                ],
                "tactic_res": [
                    "c19_goal : not\n  (ISet.In i\n     (ISet.remove (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz) iv))"
                ]
            },
            {
                "tactic_sig": "rewrite ISet.In_remove .",
                "tactic_sig_no_out_arg": "rewrite ISet.In_remove .",
                "tactic_args": [
                    "c19_goal : not\n  (ISet.In i\n     (ISet.remove (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz) iv))",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c20_goal : not\n  (Logic.and\n     (not\n        (Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n           (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz)))) \n     (ISet.In i iv))"
                ]
            },
            {
                "tactic_sig": "intros [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ A B ] .",
                "tactic_args": [
                    "c20_goal : not\n  (Logic.and\n     (not\n        (Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n           (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz)))) \n     (ISet.In i iv))"
                ],
                "tactic_res": [
                    "c21_goal : False",
                    "c21_A : not\n  (Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n     (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz)))",
                    "c21_B : ISet.In i iv"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c21_goal : False",
                    "c21_A : not\n  (Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n     (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz)))"
                ],
                "tactic_res": [
                    "c22_goal : Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n  (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c22_goal : Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n  (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c14_goal : nlive (NMem stk gl) b i"
                ],
                "tactic_res": [
                    "c23_goal : forall _ : eq b sp, not (ISet.In i stk)",
                    "c24_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c23_goal : forall _ : eq b sp, not (ISet.In i stk)"
                ],
                "tactic_res": [
                    "c25_goal : not (ISet.In i stk)",
                    "c25_H4 : eq b sp"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c24_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)"
                ],
                "tactic_res": [
                    "c26_goal : not (ISet.In i iv)",
                    "c26_id0 : ident",
                    "c26_iv : ISet.t",
                    "c26_H4 : eq (Genv.find_symbol ge id0) (Some b)",
                    "c26_H5 : eq (PTree.get id0 gl) (Some iv)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c25_goal : not (ISet.In i stk)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( _i = _i ) by ( eapply Genv.genv_vars_inj ; eauto ) .",
                "tactic_sig_no_out_arg": "assert ( _i = _i ) by ( eapply Genv.genv_vars_inj ; eauto ) .",
                "tactic_args": [
                    "c26_id0 : ident",
                    "c6_id : ident"
                ],
                "tactic_res": [
                    "c26_H6 : eq id0 id"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c26_id0 : ident"
                ],
                "tactic_res": [
                    "c26_H4 : eq (Genv.find_symbol ge id) (Some b)",
                    "c26_H5 : eq (PTree.get id gl) (Some iv)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c26_goal : not (ISet.In i iv)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( Genv.find_symbol _i _i = Some _i ) by ( eapply _i ; eauto ) .",
                "tactic_sig_no_out_arg": "assert ( Genv.find_symbol _i _i = Some _i ) by ( eapply _i ; eauto ) .",
                "tactic_args": [
                    "c1_ge : genv",
                    "c6_id : ident",
                    "c2_b : block",
                    "c2_H : genv_match bc ge"
                ],
                "tactic_res": [
                    "c7_H1 : eq (Genv.find_symbol ge id) (Some b)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : nlive (NMem stk (PTree.remove id gl)) b i"
                ],
                "tactic_res": [
                    "c27_goal : forall _ : eq b sp, not (ISet.In i stk)",
                    "c28_goal : forall (id0 : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id0) (Some b))\n  (_ : eq (PTree.get id0 (PTree.remove id gl)) (Some iv)),\nnot (ISet.In i iv)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c27_goal : forall _ : eq b sp, not (ISet.In i stk)"
                ],
                "tactic_res": [
                    "c29_goal : not (ISet.In i stk)",
                    "c29_H4 : eq b sp"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c28_goal : forall (id0 : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id0) (Some b))\n  (_ : eq (PTree.get id0 (PTree.remove id gl)) (Some iv)),\nnot (ISet.In i iv)"
                ],
                "tactic_res": [
                    "c30_goal : not (ISet.In i iv)",
                    "c30_id0 : ident",
                    "c30_iv : ISet.t",
                    "c30_H4 : eq (Genv.find_symbol ge id0) (Some b)",
                    "c30_H5 : eq (PTree.get id0 (PTree.remove id gl)) (Some iv)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c29_goal : not (ISet.In i stk)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( _i = _i ) by ( eapply Genv.genv_vars_inj ; eauto ) .",
                "tactic_sig_no_out_arg": "assert ( _i = _i ) by ( eapply Genv.genv_vars_inj ; eauto ) .",
                "tactic_args": [
                    "c30_id0 : ident",
                    "c6_id : ident"
                ],
                "tactic_res": [
                    "c30_H6 : eq id0 id"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c30_id0 : ident"
                ],
                "tactic_res": [
                    "c30_H4 : eq (Genv.find_symbol ge id) (Some b)",
                    "c30_H5 : eq (PTree.get id (PTree.remove id gl)) (Some iv)"
                ]
            },
            {
                "tactic_sig": "rewrite PTree.grs in _i .",
                "tactic_sig_no_out_arg": "rewrite PTree.grs in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c30_H5 : eq (PTree.get id0 (PTree.remove id gl)) (Some iv)"
                ],
                "tactic_res": [
                    "c30_H5 : eq None (Some iv)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c30_goal : not (ISet.In i iv)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c9_goal : nlive\n  (NMem\n     (ISet.remove (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz) stk) gl) b i"
                ],
                "tactic_res": [
                    "c31_goal : forall _ : eq b sp,\nnot\n  (ISet.In i\n     (ISet.remove (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz) stk))",
                    "c32_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c31_goal : forall _ : eq b sp,\nnot\n  (ISet.In i\n     (ISet.remove (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz) stk))"
                ],
                "tactic_res": [
                    "c33_goal : not\n  (ISet.In i\n     (ISet.remove (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz) stk))",
                    "c33_H1 : eq b sp"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c32_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)"
                ],
                "tactic_res": [
                    "c34_goal : not (ISet.In i iv)",
                    "c34_id : ident",
                    "c34_iv : ISet.t",
                    "c34_H1 : eq (Genv.find_symbol ge id) (Some b)",
                    "c34_H4 : eq (PTree.get id gl) (Some iv)"
                ]
            },
            {
                "tactic_sig": "rewrite ISet.In_remove .",
                "tactic_sig_no_out_arg": "rewrite ISet.In_remove .",
                "tactic_args": [
                    "c33_goal : not\n  (ISet.In i\n     (ISet.remove (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz) stk))",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c35_goal : not\n  (Logic.and\n     (not\n        (Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n           (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz)))) \n     (ISet.In i stk))"
                ]
            },
            {
                "tactic_sig": "intros [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ A B ] .",
                "tactic_args": [
                    "c35_goal : not\n  (Logic.and\n     (not\n        (Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n           (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz)))) \n     (ISet.In i stk))"
                ],
                "tactic_res": [
                    "c36_goal : False",
                    "c36_A : not\n  (Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n     (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz)))",
                    "c36_B : ISet.In i stk"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c36_goal : False",
                    "c36_A : not\n  (Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n     (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz)))"
                ],
                "tactic_res": [
                    "c37_goal : Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n  (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c37_goal : Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n  (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( _i _i = BCglob _i ) by ( eapply _i ; eauto ) .",
                "tactic_sig_no_out_arg": "assert ( _i _i = BCglob _i ) by ( eapply _i ; eauto ) .",
                "tactic_args": [
                    "c2_bc : block_classification",
                    "c2_b : block",
                    "c6_id : ident",
                    "c2_H : genv_match bc ge"
                ],
                "tactic_res": [
                    "c34_H5 : eq (bc b) (BCglob id)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c34_goal : not (ISet.In i iv)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c10_goal : nlive (NMem ISet.empty gl) b i"
                ],
                "tactic_res": [
                    "c38_goal : forall _ : eq b sp, not (ISet.In i ISet.empty)",
                    "c39_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c38_goal : forall _ : eq b sp, not (ISet.In i ISet.empty)"
                ],
                "tactic_res": [
                    "c40_goal : not (ISet.In i ISet.empty)",
                    "c40_H1 : eq b sp"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c39_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)"
                ],
                "tactic_res": [
                    "c41_goal : not (ISet.In i iv)",
                    "c41_id : ident",
                    "c41_iv : ISet.t",
                    "c41_H1 : eq (Genv.find_symbol ge id) (Some b)",
                    "c41_H4 : eq (PTree.get id gl) (Some iv)"
                ]
            },
            {
                "tactic_sig": "apply ISet.In_empty .",
                "tactic_sig_no_out_arg": "apply ISet.In_empty .",
                "tactic_args": [
                    "c40_goal : not (ISet.In i ISet.empty)",
                    "_global_1 : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( _i _i = BCglob _i ) by ( eapply _i ; eauto ) .",
                "tactic_sig_no_out_arg": "assert ( _i _i = BCglob _i ) by ( eapply _i ; eauto ) .",
                "tactic_args": [
                    "c2_bc : block_classification",
                    "c2_b : block",
                    "c6_id : ident",
                    "c2_H : genv_match bc ge"
                ],
                "tactic_res": [
                    "c41_H5 : eq (bc b) (BCglob id)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c41_goal : not (ISet.In i iv)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "incl_nmem_add",
        "proof": [
            {
                "tactic_sig": "Lemma incl_nmem_add : forall nm b i p sz , nlive nm b i -> nlive ( nmem_add nm p sz ) b i .",
                "tactic_sig_no_out_arg": "Lemma incl_nmem_add : forall nm b i p sz , nlive nm b i -> nlive ( nmem_add nm p sz ) b i .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (nm : nmem) (b : block) (i : Z) (p : aptr) \n  (sz : Z) (_ : nlive nm b i), nlive (nmem_add nm p sz) b i",
                    "c1_sp : block",
                    "c1_ge : genv"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (nm : nmem) (b : block) (i : Z) (p : aptr) \n  (sz : Z) (_ : nlive nm b i), nlive (nmem_add nm p sz) b i"
                ],
                "tactic_res": [
                    "c2_goal : nlive (nmem_add nm p sz) b i",
                    "c2_nm : nmem",
                    "c2_b : block",
                    "c2_i : Z",
                    "c2_p : aptr",
                    "c2_sz : Z",
                    "c2_H : nlive nm b i"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "c2_goal : nlive (nmem_add nm p sz) b i",
                    "c2_H : nlive nm b i"
                ],
                "tactic_res": [
                    "c3_goal : nlive (nmem_add (NMem stk gl) p sz) b i",
                    "c3_H2 : eq ofs i",
                    "c3_H1 : eq b0 b",
                    "c3_H0 : eq (NMem stk gl) nm",
                    "c3_GL : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)",
                    "c3_STK : forall _ : eq b sp, not (ISet.In i stk)",
                    "c3_ofs : Z",
                    "c3_b0 : block",
                    "c3_gl : PTree.tree ISet.t",
                    "c3_stk : ISet.t"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : nlive (nmem_add (NMem stk gl) p sz) b i",
                    "_global_1 : Z",
                    "_global_nmem_add : forall (_ : nmem) (_ : aptr) (_ : Z), nmem"
                ],
                "tactic_res": [
                    "c4_goal : nlive\n  match p with\n  | Gl id ofs =>\n      match PTree.get id gl with\n      | Some iv =>\n          NMem stk\n            (PTree.set id\n               (ISet.remove (Ptrofs.unsigned ofs)\n                  (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)\n      | None => NMem stk gl\n      end\n  | Glo id => NMem stk (PTree.remove id gl)\n  | Stk ofs =>\n      NMem\n        (ISet.remove (Ptrofs.unsigned ofs)\n           (Z.add (Ptrofs.unsigned ofs) sz) stk) gl\n  | Stack => NMem ISet.empty gl\n  | _ => nmem_all\n  end b i"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | _o _o | _o | | _o | | | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c4_goal : nlive\n  match p with\n  | Gl id ofs =>\n      match PTree.get id gl with\n      | Some iv =>\n          NMem stk\n            (PTree.set id\n               (ISet.remove (Ptrofs.unsigned ofs)\n                  (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)\n      | None => NMem stk gl\n      end\n  | Glo id => NMem stk (PTree.remove id gl)\n  | Stk ofs =>\n      NMem\n        (ISet.remove (Ptrofs.unsigned ofs)\n           (Z.add (Ptrofs.unsigned ofs) sz) stk) gl\n  | Stack => NMem ISet.empty gl\n  | _ => nmem_all\n  end b i",
                    "c2_p : aptr"
                ],
                "tactic_res": [
                    "c5_goal : nlive nmem_all b i",
                    "c6_goal : nlive\n  match PTree.get id gl with\n  | Some iv =>\n      NMem stk\n        (PTree.set id\n           (ISet.remove (Ptrofs.unsigned ofs)\n              (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)\n  | None => NMem stk gl\n  end b i",
                    "c6_ofs : Ptrofs.int",
                    "c6_id : ident",
                    "c7_goal : nlive (NMem stk (PTree.remove id gl)) b i",
                    "c7_id : ident",
                    "c8_goal : nlive nmem_all b i",
                    "c9_goal : nlive\n  (NMem\n     (ISet.remove (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz) stk) gl) b i",
                    "c9_ofs : Ptrofs.int",
                    "c10_goal : nlive (NMem ISet.empty gl) b i",
                    "c11_goal : nlive nmem_all b i",
                    "c12_goal : nlive nmem_all b i"
                ]
            },
            {
                "tactic_sig": "try ( apply nlive_all ) .",
                "tactic_sig_no_out_arg": "try ( apply nlive_all ) .",
                "tactic_args": [
                    "c5_goal : nlive nmem_all b i"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( apply nlive_all ) .",
                "tactic_sig_no_out_arg": "try ( apply nlive_all ) .",
                "tactic_args": [
                    "c8_goal : nlive nmem_all b i"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( apply nlive_all ) .",
                "tactic_sig_no_out_arg": "try ( apply nlive_all ) .",
                "tactic_args": [
                    "c11_goal : nlive nmem_all b i"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( apply nlive_all ) .",
                "tactic_sig_no_out_arg": "try ( apply nlive_all ) .",
                "tactic_args": [
                    "c12_goal : nlive nmem_all b i"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct gl!id as [ iv| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct gl!id as [ iv| ] eqn : NG .",
                "tactic_args": [
                    "c6_goal : nlive\n  match PTree.get id gl with\n  | Some iv =>\n      NMem stk\n        (PTree.set id\n           (ISet.remove (Ptrofs.unsigned ofs)\n              (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)\n  | None => NMem stk gl\n  end b i"
                ],
                "tactic_res": [
                    "c13_goal : nlive\n  (NMem stk\n     (PTree.set id\n        (ISet.remove (Ptrofs.unsigned ofs)\n           (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)) b i",
                    "c13_NG : eq (PTree.get id gl) (Some iv)",
                    "c13_iv : ISet.t",
                    "c14_goal : nlive (NMem stk gl) b i",
                    "c14_NG : eq (PTree.get id gl) None"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c13_goal : nlive\n  (NMem stk\n     (PTree.set id\n        (ISet.remove (Ptrofs.unsigned ofs)\n           (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)) b i"
                ],
                "tactic_res": [
                    "c15_goal : forall _ : eq b sp, not (ISet.In i stk)",
                    "c16_goal : forall (id0 : ident) (iv0 : ISet.t)\n  (_ : eq (Genv.find_symbol ge id0) (Some b))\n  (_ : eq\n         (PTree.get id0\n            (PTree.set id\n               (ISet.remove (Ptrofs.unsigned ofs)\n                  (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)) \n         (Some iv0)), not (ISet.In i iv0)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c15_goal : forall _ : eq b sp, not (ISet.In i stk)"
                ],
                "tactic_res": [
                    "c17_goal : not (ISet.In i stk)",
                    "c17_H0 : eq b sp"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c16_goal : forall (id0 : ident) (iv0 : ISet.t)\n  (_ : eq (Genv.find_symbol ge id0) (Some b))\n  (_ : eq\n         (PTree.get id0\n            (PTree.set id\n               (ISet.remove (Ptrofs.unsigned ofs)\n                  (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)) \n         (Some iv0)), not (ISet.In i iv0)"
                ],
                "tactic_res": [
                    "c18_goal : not (ISet.In i iv0)",
                    "c18_id0 : ident",
                    "c18_iv0 : ISet.t",
                    "c18_H0 : eq (Genv.find_symbol ge id0) (Some b)",
                    "c18_H1 : eq\n  (PTree.get id0\n     (PTree.set id\n        (ISet.remove (Ptrofs.unsigned ofs)\n           (Z.add (Ptrofs.unsigned ofs) sz) iv) gl)) \n  (Some iv0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c17_goal : not (ISet.In i stk)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite PTree.gsspec in _i .",
                "tactic_sig_no_out_arg": "rewrite PTree.gsspec in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c3_H1 : eq b0 b"
                ],
                "tactic_res": [
                    "c18_H1 : eq\n  (if peq id0 id\n   then\n    Some\n      (ISet.remove (Ptrofs.unsigned ofs)\n         (Z.add (Ptrofs.unsigned ofs) sz) iv)\n   else PTree.get id0 gl) (Some iv0)"
                ]
            },
            {
                "tactic_sig": "destruct ( peq _i _i ) as [  _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( peq _i _i ) .",
                "tactic_args": [
                    "c18_goal : not (ISet.In i iv0)",
                    "c18_id0 : ident",
                    "c6_id : ident"
                ],
                "tactic_res": [
                    "c19_goal : not (ISet.In i iv0)",
                    "c19_H1 : eq\n  (Some\n     (ISet.remove (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz) iv)) (Some iv0)",
                    "c19_e : eq id0 id",
                    "c20_goal : not (ISet.In i iv0)",
                    "c20_H1 : eq (PTree.get id0 gl) (Some iv0)",
                    "c20_n : not (eq id0 id)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c20_goal : not (ISet.In i iv0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c19_goal : not (ISet.In i iv0)",
                    "c3_H1 : eq b0 b"
                ],
                "tactic_res": [
                    "c21_goal : not\n  (ISet.In i\n     (ISet.remove (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz) iv))",
                    "c21_H0 : eq (Genv.find_symbol ge id) (Some b)"
                ]
            },
            {
                "tactic_sig": "rewrite ISet.In_remove .",
                "tactic_sig_no_out_arg": "rewrite ISet.In_remove .",
                "tactic_args": [
                    "c21_goal : not\n  (ISet.In i\n     (ISet.remove (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz) iv))",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c22_goal : not\n  (Logic.and\n     (not\n        (Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n           (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz)))) \n     (ISet.In i iv))"
                ]
            },
            {
                "tactic_sig": "intros [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ P Q ] .",
                "tactic_args": [
                    "c22_goal : not\n  (Logic.and\n     (not\n        (Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n           (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz)))) \n     (ISet.In i iv))"
                ],
                "tactic_res": [
                    "c23_goal : False",
                    "c23_P : not\n  (Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n     (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz)))",
                    "c23_Q : ISet.In i iv"
                ]
            },
            {
                "tactic_sig": "eelim _i .",
                "tactic_sig_no_out_arg": "eelim _i .",
                "tactic_args": [
                    "c23_goal : False",
                    "c3_GL : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)"
                ],
                "tactic_res": [
                    "c24_goal : eq (Genv.find_symbol ge ?id) (Some b)",
                    "c25_goal : eq (PTree.get ?id gl) (Some ?iv)",
                    "c26_goal : ISet.In i ?iv"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c24_goal : eq (Genv.find_symbol ge ?id) (Some b)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c25_goal : eq (PTree.get id gl) (Some ?iv)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c26_goal : ISet.In i iv"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c14_goal : nlive (NMem stk gl) b i"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c7_goal : nlive (NMem stk (PTree.remove id gl)) b i"
                ],
                "tactic_res": [
                    "c27_goal : forall _ : eq b sp, not (ISet.In i stk)",
                    "c28_goal : forall (id0 : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id0) (Some b))\n  (_ : eq (PTree.get id0 (PTree.remove id gl)) (Some iv)),\nnot (ISet.In i iv)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c27_goal : forall _ : eq b sp, not (ISet.In i stk)"
                ],
                "tactic_res": [
                    "c29_goal : not (ISet.In i stk)",
                    "c29_H0 : eq b sp"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c28_goal : forall (id0 : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id0) (Some b))\n  (_ : eq (PTree.get id0 (PTree.remove id gl)) (Some iv)),\nnot (ISet.In i iv)"
                ],
                "tactic_res": [
                    "c30_goal : not (ISet.In i iv)",
                    "c30_id0 : ident",
                    "c30_iv : ISet.t",
                    "c30_H0 : eq (Genv.find_symbol ge id0) (Some b)",
                    "c30_H1 : eq (PTree.get id0 (PTree.remove id gl)) (Some iv)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c29_goal : not (ISet.In i stk)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite PTree.grspec in _i .",
                "tactic_sig_no_out_arg": "rewrite PTree.grspec in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c3_H1 : eq b0 b"
                ],
                "tactic_res": [
                    "c30_H1 : eq (if PTree.elt_eq id0 id then None else PTree.get id0 gl) (Some iv)"
                ]
            },
            {
                "tactic_sig": "destruct ( PTree.elt_eq _i _i ) as [  _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( PTree.elt_eq _i _i ) .",
                "tactic_args": [
                    "c30_goal : not (ISet.In i iv)",
                    "c30_id0 : ident",
                    "c6_id : ident"
                ],
                "tactic_res": [
                    "c31_goal : not (ISet.In i iv)",
                    "c31_H1 : eq None (Some iv)",
                    "c31_e : eq id0 id",
                    "c32_goal : not (ISet.In i iv)",
                    "c32_H1 : eq (PTree.get id0 gl) (Some iv)",
                    "c32_n : not (eq id0 id)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c31_goal : not (ISet.In i iv)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c32_goal : not (ISet.In i iv)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c9_goal : nlive\n  (NMem\n     (ISet.remove (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz) stk) gl) b i"
                ],
                "tactic_res": [
                    "c33_goal : forall _ : eq b sp,\nnot\n  (ISet.In i\n     (ISet.remove (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz) stk))",
                    "c34_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c33_goal : forall _ : eq b sp,\nnot\n  (ISet.In i\n     (ISet.remove (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz) stk))"
                ],
                "tactic_res": [
                    "c35_goal : not\n  (ISet.In i\n     (ISet.remove (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz) stk))",
                    "c35_H0 : eq b sp"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c34_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)"
                ],
                "tactic_res": [
                    "c36_goal : not (ISet.In i iv)",
                    "c36_id : ident",
                    "c36_iv : ISet.t",
                    "c36_H0 : eq (Genv.find_symbol ge id) (Some b)",
                    "c36_H1 : eq (PTree.get id gl) (Some iv)"
                ]
            },
            {
                "tactic_sig": "rewrite ISet.In_remove .",
                "tactic_sig_no_out_arg": "rewrite ISet.In_remove .",
                "tactic_args": [
                    "c35_goal : not\n  (ISet.In i\n     (ISet.remove (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz) stk))",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c37_goal : not\n  (Logic.and\n     (not\n        (Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n           (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz)))) \n     (ISet.In i stk))"
                ]
            },
            {
                "tactic_sig": "intros [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ P Q ] .",
                "tactic_args": [
                    "c37_goal : not\n  (Logic.and\n     (not\n        (Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n           (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz)))) \n     (ISet.In i stk))"
                ],
                "tactic_res": [
                    "c38_goal : False",
                    "c38_P : not\n  (Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n     (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz)))",
                    "c38_Q : ISet.In i stk"
                ]
            },
            {
                "tactic_sig": "eelim _i .",
                "tactic_sig_no_out_arg": "eelim _i .",
                "tactic_args": [
                    "c38_goal : False",
                    "c3_STK : forall _ : eq b sp, not (ISet.In i stk)"
                ],
                "tactic_res": [
                    "c39_goal : eq b sp",
                    "c40_goal : ISet.In i stk"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c39_goal : eq b sp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c40_goal : ISet.In i stk"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c36_goal : not (ISet.In i iv)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c10_goal : nlive (NMem ISet.empty gl) b i"
                ],
                "tactic_res": [
                    "c41_goal : forall _ : eq b sp, not (ISet.In i ISet.empty)",
                    "c42_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c41_goal : forall _ : eq b sp, not (ISet.In i ISet.empty)"
                ],
                "tactic_res": [
                    "c43_goal : not (ISet.In i ISet.empty)",
                    "c43_H0 : eq b sp"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c42_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)"
                ],
                "tactic_res": [
                    "c44_goal : not (ISet.In i iv)",
                    "c44_id : ident",
                    "c44_iv : ISet.t",
                    "c44_H0 : eq (Genv.find_symbol ge id) (Some b)",
                    "c44_H1 : eq (PTree.get id gl) (Some iv)"
                ]
            },
            {
                "tactic_sig": "apply ISet.In_empty .",
                "tactic_sig_no_out_arg": "apply ISet.In_empty .",
                "tactic_args": [
                    "c43_goal : not (ISet.In i ISet.empty)",
                    "_global_1 : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c44_goal : not (ISet.In i iv)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nlive_remove",
        "proof": [
            {
                "tactic_sig": "Lemma nlive_remove : forall bc b ofs p nm sz b' i , genv_match bc ge -> bc sp = BCstack -> pmatch bc b ofs p -> nlive nm b' i -> b' <> b \\/ i < Ptrofs.unsigned ofs \\/ Ptrofs.unsigned ofs + sz <= i -> nlive ( nmem_remove nm p sz ) b' i .",
                "tactic_sig_no_out_arg": "Lemma nlive_remove : forall bc b ofs p nm sz b' i , genv_match bc ge -> bc sp = BCstack -> pmatch bc b ofs p -> nlive nm b' i -> b' <> b \\/ i < Ptrofs.unsigned ofs \\/ Ptrofs.unsigned ofs + sz <= i -> nlive ( nmem_remove nm p sz ) b' i .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (bc : block_classification) (b : block) (ofs : Ptrofs.int)\n  (p : aptr) (nm : nmem) (sz : Z) (b' : block) (i : Z)\n  (_ : genv_match bc ge) (_ : eq (bc sp) BCstack)\n  (_ : pmatch bc b ofs p) (_ : nlive nm b' i)\n  (_ : Logic.or (not (eq b' b))\n         (Logic.or (Z.lt i (Ptrofs.unsigned ofs))\n            (Z.le (Z.add (Ptrofs.unsigned ofs) sz) i))),\nnlive (nmem_remove nm p sz) b' i",
                    "c1_sp : block",
                    "c1_ge : genv"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (bc : block_classification) (b : block) (ofs : Ptrofs.int)\n  (p : aptr) (nm : nmem) (sz : Z) (b' : block) (i : Z)\n  (_ : genv_match bc ge) (_ : eq (bc sp) BCstack)\n  (_ : pmatch bc b ofs p) (_ : nlive nm b' i)\n  (_ : Logic.or (not (eq b' b))\n         (Logic.or (Z.lt i (Ptrofs.unsigned ofs))\n            (Z.le (Z.add (Ptrofs.unsigned ofs) sz) i))),\nnlive (nmem_remove nm p sz) b' i"
                ],
                "tactic_res": [
                    "c2_goal : nlive (nmem_remove nm p sz) b' i",
                    "c2_bc : block_classification",
                    "c2_b : block",
                    "c2_ofs : Ptrofs.int",
                    "c2_p : aptr",
                    "c2_nm : nmem",
                    "c2_sz : Z",
                    "c2_b' : block",
                    "c2_i : Z",
                    "c2_H : genv_match bc ge",
                    "c2_H0 : eq (bc sp) BCstack",
                    "c2_H1 : pmatch bc b ofs p",
                    "c2_H2 : nlive nm b' i",
                    "c2_H3 : Logic.or (not (eq b' b))\n  (Logic.or (Z.lt i (Ptrofs.unsigned ofs))\n     (Z.le (Z.add (Ptrofs.unsigned ofs) sz) i))"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "c2_goal : nlive (nmem_remove nm p sz) b' i",
                    "c2_H2 : nlive nm b' i"
                ],
                "tactic_res": [
                    "c3_goal : nlive (nmem_remove (NMem stk gl) p sz) b' i",
                    "c3_H6 : eq ofs0 i",
                    "c3_H5 : eq b0 b'",
                    "c3_H4 : eq (NMem stk gl) nm",
                    "c3_GL : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b'))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)",
                    "c3_STK : forall _ : eq b' sp, not (ISet.In i stk)",
                    "c3_ofs0 : Z",
                    "c3_b0 : block",
                    "c3_gl : PTree.tree ISet.t",
                    "c3_stk : ISet.t"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c3_goal : nlive (nmem_remove (NMem stk gl) p sz) b' i",
                    "_global_1 : Z",
                    "_global_nmem_remove : forall (_ : nmem) (_ : aptr) (_ : Z), nmem"
                ],
                "tactic_res": [
                    "c4_goal : nlive\n  match p with\n  | Gl id ofs =>\n      NMem stk\n        (PTree.set id\n           match PTree.get id gl with\n           | Some iv =>\n               ISet.add (Ptrofs.unsigned ofs)\n                 (Z.add (Ptrofs.unsigned ofs) sz) iv\n           | None =>\n               ISet.interval (Ptrofs.unsigned ofs)\n                 (Z.add (Ptrofs.unsigned ofs) sz)\n           end gl)\n  | Stk ofs =>\n      NMem\n        (ISet.add (Ptrofs.unsigned ofs)\n           (Z.add (Ptrofs.unsigned ofs) sz) stk) gl\n  | _ => NMem stk gl\n  end b' i"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c4_goal : nlive\n  match p with\n  | Gl id ofs =>\n      NMem stk\n        (PTree.set id\n           match PTree.get id gl with\n           | Some iv =>\n               ISet.add (Ptrofs.unsigned ofs)\n                 (Z.add (Ptrofs.unsigned ofs) sz) iv\n           | None =>\n               ISet.interval (Ptrofs.unsigned ofs)\n                 (Z.add (Ptrofs.unsigned ofs) sz)\n           end gl)\n  | Stk ofs =>\n      NMem\n        (ISet.add (Ptrofs.unsigned ofs)\n           (Z.add (Ptrofs.unsigned ofs) sz) stk) gl\n  | _ => NMem stk gl\n  end b' i",
                    "c2_H1 : pmatch bc b ofs p"
                ],
                "tactic_res": [
                    "c5_goal : nlive\n  (NMem stk\n     (PTree.set id\n        match PTree.get id gl with\n        | Some iv =>\n            ISet.add (Ptrofs.unsigned ofs)\n              (Z.add (Ptrofs.unsigned ofs) sz) iv\n        | None =>\n            ISet.interval (Ptrofs.unsigned ofs)\n              (Z.add (Ptrofs.unsigned ofs) sz)\n        end gl)) b' i",
                    "c5_H4 : eq (bc b) (BCglob id)",
                    "c5_id : ident",
                    "c6_goal : nlive (NMem stk gl) b' i",
                    "c6_H4 : eq (bc b) (BCglob id)",
                    "c6_id : ident",
                    "c7_goal : nlive (NMem stk gl) b' i",
                    "c7_H4 : eq (bc b) (BCglob id)",
                    "c7_id : ident",
                    "c8_goal : nlive\n  (NMem\n     (ISet.add (Ptrofs.unsigned ofs) (Z.add (Ptrofs.unsigned ofs) sz)\n        stk) gl) b' i",
                    "c8_H4 : eq (bc b) BCstack",
                    "c9_goal : nlive (NMem stk gl) b' i",
                    "c9_H4 : eq (bc b) BCstack",
                    "c10_goal : nlive (NMem stk gl) b' i",
                    "c10_H5 : not (eq (bc b) BCinvalid)",
                    "c10_H4 : not (eq (bc b) BCstack)",
                    "c11_goal : nlive (NMem stk gl) b' i",
                    "c11_H4 : not (eq (bc b) BCinvalid)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : nlive (NMem stk gl) b' i"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : nlive (NMem stk gl) b' i"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c9_goal : nlive (NMem stk gl) b' i"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : nlive (NMem stk gl) b' i"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : nlive (NMem stk gl) b' i"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "set ( iv' := match gl!id with | Some iv => ISet.add ( Ptrofs.unsigned _i ) ( Ptrofs.unsigned _i + _i ) iv | None => ISet.interval ( Ptrofs.unsigned _i ) ( Ptrofs.unsigned _i + _i ) end ) .",
                "tactic_sig_no_out_arg": "set ( iv' := match gl!id with | Some iv => ISet.add ( Ptrofs.unsigned _i ) ( Ptrofs.unsigned _i + _i ) iv | None => ISet.interval ( Ptrofs.unsigned _i ) ( Ptrofs.unsigned _i + _i ) end ) .",
                "tactic_args": [
                    "c5_goal : nlive\n  (NMem stk\n     (PTree.set id\n        match PTree.get id gl with\n        | Some iv =>\n            ISet.add (Ptrofs.unsigned ofs)\n              (Z.add (Ptrofs.unsigned ofs) sz) iv\n        | None =>\n            ISet.interval (Ptrofs.unsigned ofs)\n              (Z.add (Ptrofs.unsigned ofs) sz)\n        end gl)) b' i",
                    "c2_ofs : Ptrofs.int",
                    "c2_ofs : Ptrofs.int",
                    "c2_sz : Z",
                    "c2_ofs : Ptrofs.int",
                    "c2_ofs : Ptrofs.int",
                    "c2_sz : Z"
                ],
                "tactic_res": [
                    "c12_goal : nlive (NMem stk (PTree.set id iv' gl)) b' i",
                    "c12_iv' : ISet.t"
                ]
            },
            {
                "tactic_sig": "assert ( Genv.find_symbol _i _i = Some _i ) by ( eapply _i ; eauto ) .",
                "tactic_sig_no_out_arg": "assert ( Genv.find_symbol _i _i = Some _i ) by ( eapply _i ; eauto ) .",
                "tactic_args": [
                    "c1_ge : genv",
                    "c5_id : ident",
                    "c2_b : block",
                    "c2_H : genv_match bc ge"
                ],
                "tactic_res": [
                    "c12_H1 : eq (Genv.find_symbol ge id) (Some b)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c12_goal : nlive (NMem stk (PTree.set id iv' gl)) b' i"
                ],
                "tactic_res": [
                    "c13_goal : forall _ : eq b' sp, not (ISet.In i stk)",
                    "c14_goal : forall (id0 : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id0) (Some b'))\n  (_ : eq (PTree.get id0 (PTree.set id iv' gl)) (Some iv)),\nnot (ISet.In i iv)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c13_goal : forall _ : eq b' sp, not (ISet.In i stk)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c14_goal : forall (id0 : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id0) (Some b'))\n  (_ : eq (PTree.get id0 (PTree.set id iv' gl)) (Some iv)),\nnot (ISet.In i iv)"
                ],
                "tactic_res": [
                    "c15_goal : not (ISet.In i iv)",
                    "c15_id0 : ident",
                    "c15_iv : ISet.t",
                    "c15_H5 : eq (Genv.find_symbol ge id0) (Some b')",
                    "c15_H6 : eq (PTree.get id0 (PTree.set id iv' gl)) (Some iv)"
                ]
            },
            {
                "tactic_sig": "rewrite PTree.gsspec in _i .",
                "tactic_sig_no_out_arg": "rewrite PTree.gsspec in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c3_H6 : eq ofs0 i"
                ],
                "tactic_res": [
                    "c15_H6 : eq (if peq id0 id then Some iv' else PTree.get id0 gl) (Some iv)"
                ]
            },
            {
                "tactic_sig": "destruct ( peq _i _i ) as [  _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( peq _i _i ) .",
                "tactic_args": [
                    "c15_goal : not (ISet.In i iv)",
                    "c15_id0 : ident",
                    "c5_id : ident"
                ],
                "tactic_res": [
                    "c16_goal : not (ISet.In i iv)",
                    "c16_H6 : eq (Some iv') (Some iv)",
                    "c16_e : eq id0 id",
                    "c17_goal : not (ISet.In i iv)",
                    "c17_H6 : eq (PTree.get id0 gl) (Some iv)",
                    "c17_n : not (eq id0 id)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c16_goal : not (ISet.In i iv)",
                    "c3_H6 : eq ofs0 i"
                ],
                "tactic_res": [
                    "c18_goal : not (ISet.In i iv')",
                    "c18_H5 : eq (Genv.find_symbol ge id) (Some b')"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c18_goal : not (ISet.In i iv')",
                    "c2_H3 : Logic.or (not (eq b' b))\n  (Logic.or (Z.lt i (Ptrofs.unsigned ofs))\n     (Z.le (Z.add (Ptrofs.unsigned ofs) sz) i))"
                ],
                "tactic_res": [
                    "c19_goal : not (ISet.In i iv')",
                    "c19_H3 : not (eq b' b)",
                    "c20_goal : not (ISet.In i iv')",
                    "c20_H3 : Logic.or (Z.lt i (Ptrofs.unsigned ofs))\n  (Z.le (Z.add (Ptrofs.unsigned ofs) sz) i)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "c19_goal : not (ISet.In i iv')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct gl!id as [ iv0| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct gl!id as [ iv0| ] eqn : NG .",
                "tactic_args": [
                    "c20_goal : not (ISet.In i iv')"
                ],
                "tactic_res": [
                    "c21_goal : not (ISet.In i iv')",
                    "c21_NG : eq (PTree.get id gl) (Some iv0)",
                    "c21_iv0 : ISet.t",
                    "c22_goal : not (ISet.In i iv')",
                    "c22_NG : eq (PTree.get id gl) None"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c21_goal : not (ISet.In i iv')",
                    "_global_1 : Z",
                    "c12_iv' : ISet.t"
                ],
                "tactic_res": [
                    "c23_goal : not\n  (ISet.In i\n     (ISet.add (Ptrofs.unsigned ofs) (Z.add (Ptrofs.unsigned ofs) sz)\n        iv0))"
                ]
            },
            {
                "tactic_sig": "rewrite ISet.In_add .",
                "tactic_sig_no_out_arg": "rewrite ISet.In_add .",
                "tactic_args": [
                    "c23_goal : not\n  (ISet.In i\n     (ISet.add (Ptrofs.unsigned ofs) (Z.add (Ptrofs.unsigned ofs) sz)\n        iv0))",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c24_goal : not\n  (Logic.or\n     (Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n        (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz))) \n     (ISet.In i iv0))"
                ]
            },
            {
                "tactic_sig": "intros [ P|P ] .",
                "tactic_sig_no_out_arg": "intros [ P|P ] .",
                "tactic_args": [
                    "c24_goal : not\n  (Logic.or\n     (Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n        (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz))) \n     (ISet.In i iv0))"
                ],
                "tactic_res": [
                    "c25_goal : False",
                    "c26_P : ISet.In i iv0",
                    "c26_goal : False",
                    "c25_P : Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n  (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c25_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eelim _i .",
                "tactic_sig_no_out_arg": "eelim _i .",
                "tactic_args": [
                    "c26_goal : False",
                    "c3_GL : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b'))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)"
                ],
                "tactic_res": [
                    "c27_goal : eq (Genv.find_symbol ge ?id) (Some b')",
                    "c28_goal : eq (PTree.get ?id gl) (Some ?iv)",
                    "c29_goal : ISet.In i ?iv"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c27_goal : eq (Genv.find_symbol ge ?id) (Some b')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c28_goal : eq (PTree.get id gl) (Some ?iv)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c29_goal : ISet.In i iv0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c22_goal : not (ISet.In i iv')",
                    "_global_1 : Z",
                    "c12_iv' : ISet.t"
                ],
                "tactic_res": [
                    "c30_goal : not\n  (ISet.In i\n     (ISet.interval (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz)))"
                ]
            },
            {
                "tactic_sig": "rewrite ISet.In_interval .",
                "tactic_sig_no_out_arg": "rewrite ISet.In_interval .",
                "tactic_args": [
                    "c30_goal : not\n  (ISet.In i\n     (ISet.interval (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz)))",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c31_goal : not\n  (Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n     (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz)))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c31_goal : not\n  (Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n     (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c17_goal : not (ISet.In i iv)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c8_goal : nlive\n  (NMem\n     (ISet.add (Ptrofs.unsigned ofs) (Z.add (Ptrofs.unsigned ofs) sz)\n        stk) gl) b' i"
                ],
                "tactic_res": [
                    "c32_goal : forall _ : eq b' sp,\nnot\n  (ISet.In i\n     (ISet.add (Ptrofs.unsigned ofs) (Z.add (Ptrofs.unsigned ofs) sz)\n        stk))",
                    "c33_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b'))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c32_goal : forall _ : eq b' sp,\nnot\n  (ISet.In i\n     (ISet.add (Ptrofs.unsigned ofs) (Z.add (Ptrofs.unsigned ofs) sz)\n        stk))"
                ],
                "tactic_res": [
                    "c34_goal : not\n  (ISet.In i\n     (ISet.add (Ptrofs.unsigned ofs) (Z.add (Ptrofs.unsigned ofs) sz)\n        stk))",
                    "c34_H1 : eq b' sp"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c33_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b'))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [  _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c34_goal : not\n  (ISet.In i\n     (ISet.add (Ptrofs.unsigned ofs) (Z.add (Ptrofs.unsigned ofs) sz)\n        stk))",
                    "c2_H3 : Logic.or (not (eq b' b))\n  (Logic.or (Z.lt i (Ptrofs.unsigned ofs))\n     (Z.le (Z.add (Ptrofs.unsigned ofs) sz) i))"
                ],
                "tactic_res": [
                    "c35_goal : not\n  (ISet.In i\n     (ISet.add (Ptrofs.unsigned ofs) (Z.add (Ptrofs.unsigned ofs) sz)\n        stk))",
                    "c35_H3 : not (eq b' b)",
                    "c36_goal : not\n  (ISet.In i\n     (ISet.add (Ptrofs.unsigned ofs) (Z.add (Ptrofs.unsigned ofs) sz)\n        stk))",
                    "c36_H3 : Logic.or (Z.lt i (Ptrofs.unsigned ofs))\n  (Z.le (Z.add (Ptrofs.unsigned ofs) sz) i)"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "c35_goal : not\n  (ISet.In i\n     (ISet.add (Ptrofs.unsigned ofs) (Z.add (Ptrofs.unsigned ofs) sz)\n        stk))",
                    "c2_H3 : Logic.or (not (eq b' b))\n  (Logic.or (Z.lt i (Ptrofs.unsigned ofs))\n     (Z.le (Z.add (Ptrofs.unsigned ofs) sz) i))"
                ],
                "tactic_res": [
                    "c37_goal : eq b' b"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "c37_goal : eq b' b",
                    "c2_b' : block"
                ],
                "tactic_res": [
                    "c38_goal : eq sp b",
                    "c38_H2 : nlive (NMem stk gl) sp i",
                    "c38_H3 : not (eq sp b)",
                    "c38_STK : forall _ : eq sp sp, not (ISet.In i stk)",
                    "c38_GL : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some sp))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c38_goal : eq sp b",
                    "_global_1 : Z",
                    "_global_bc_stack : forall (b : block_classification) (b1 b2 : block)\n         (_ : eq (b b1) BCstack) (_ : eq (b b2) BCstack), \n       eq b1 b2"
                ],
                "tactic_res": [
                    "c39_goal : eq (?b sp) BCstack",
                    "c40_goal : eq (?b b) BCstack"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c39_goal : eq (?b sp) BCstack"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c40_goal : eq (bc b) BCstack"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ISet.In_add .",
                "tactic_sig_no_out_arg": "rewrite ISet.In_add .",
                "tactic_args": [
                    "c36_goal : not\n  (ISet.In i\n     (ISet.add (Ptrofs.unsigned ofs) (Z.add (Ptrofs.unsigned ofs) sz)\n        stk))",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c41_goal : not\n  (Logic.or\n     (Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n        (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz))) \n     (ISet.In i stk))"
                ]
            },
            {
                "tactic_sig": "intros [ P|P ] .",
                "tactic_sig_no_out_arg": "intros [ P|P ] .",
                "tactic_args": [
                    "c41_goal : not\n  (Logic.or\n     (Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n        (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz))) \n     (ISet.In i stk))"
                ],
                "tactic_res": [
                    "c42_goal : False",
                    "c43_P : ISet.In i stk",
                    "c43_goal : False",
                    "c42_P : Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n  (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "c42_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c43_goal : False",
                    "_global_1 : Z",
                    "c3_STK : forall _ : eq b' sp, not (ISet.In i stk)"
                ],
                "tactic_res": [
                    "c44_goal : eq b' sp",
                    "c45_goal : ISet.In i stk"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c44_goal : eq b' sp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c45_goal : ISet.In i stk"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nlive_contains",
        "proof": [
            {
                "tactic_sig": "Lemma nlive_contains : forall bc b ofs p nm sz i , genv_match bc ge -> bc sp = BCstack -> pmatch bc b ofs p -> nmem_contains nm p sz = false -> Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz -> ~ ( nlive nm b i ) .",
                "tactic_sig_no_out_arg": "Lemma nlive_contains : forall bc b ofs p nm sz i , genv_match bc ge -> bc sp = BCstack -> pmatch bc b ofs p -> nmem_contains nm p sz = false -> Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz -> ~ ( nlive nm b i ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (bc : block_classification) (b : block) (ofs : Ptrofs.int)\n  (p : aptr) (nm : nmem) (sz i : Z) (_ : genv_match bc ge)\n  (_ : eq (bc sp) BCstack) (_ : pmatch bc b ofs p)\n  (_ : eq (nmem_contains nm p sz) false)\n  (_ : Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n         (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz))), \nnot (nlive nm b i)",
                    "c1_sp : block",
                    "c1_ge : genv"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (bc : block_classification) (b : block) (ofs : Ptrofs.int)\n  (p : aptr) (nm : nmem) (sz i : Z) (_ : genv_match bc ge)\n  (_ : eq (bc sp) BCstack) (_ : pmatch bc b ofs p)\n  (_ : eq (nmem_contains nm p sz) false)\n  (_ : Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n         (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz))), \nnot (nlive nm b i)",
                    "_global_1 : Z",
                    "_global_nmem_contains : forall (_ : nmem) (_ : aptr) (_ : Z), bool"
                ],
                "tactic_res": [
                    "c2_goal : forall (bc : block_classification) (b : block) (ofs : Ptrofs.int)\n  (p : aptr) (nm : nmem) (sz i : Z) (_ : genv_match bc ge)\n  (_ : eq (bc sp) BCstack) (_ : pmatch bc b ofs p)\n  (_ : eq\n         match nm with\n         | NMemDead => false\n         | NMem stk gl =>\n             match p with\n             | Gl id ofs0 =>\n                 match PTree.get id gl with\n                 | Some iv =>\n                     negb\n                       (ISet.contains (Ptrofs.unsigned ofs0)\n                          (Z.add (Ptrofs.unsigned ofs0) sz) iv)\n                 | None => true\n                 end\n             | Stk ofs0 =>\n                 negb\n                   (ISet.contains (Ptrofs.unsigned ofs0)\n                      (Z.add (Ptrofs.unsigned ofs0) sz) stk)\n             | _ => true\n             end\n         end false)\n  (_ : Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n         (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz))), \nnot (nlive nm b i)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (bc : block_classification) (b : block) (ofs : Ptrofs.int)\n  (p : aptr) (nm : nmem) (sz i : Z) (_ : genv_match bc ge)\n  (_ : eq (bc sp) BCstack) (_ : pmatch bc b ofs p)\n  (_ : eq\n         match nm with\n         | NMemDead => false\n         | NMem stk gl =>\n             match p with\n             | Gl id ofs0 =>\n                 match PTree.get id gl with\n                 | Some iv =>\n                     negb\n                       (ISet.contains (Ptrofs.unsigned ofs0)\n                          (Z.add (Ptrofs.unsigned ofs0) sz) iv)\n                 | None => true\n                 end\n             | Stk ofs0 =>\n                 negb\n                   (ISet.contains (Ptrofs.unsigned ofs0)\n                      (Z.add (Ptrofs.unsigned ofs0) sz) stk)\n             | _ => true\n             end\n         end false)\n  (_ : Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n         (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz))), \nnot (nlive nm b i)"
                ],
                "tactic_res": [
                    "c3_goal : not (nlive nm b i)",
                    "c3_bc : block_classification",
                    "c3_b : block",
                    "c3_ofs : Ptrofs.int",
                    "c3_p : aptr",
                    "c3_nm : nmem",
                    "c3_sz : Z",
                    "c3_i : Z",
                    "c3_H : genv_match bc ge",
                    "c3_H0 : eq (bc sp) BCstack",
                    "c3_H1 : pmatch bc b ofs p",
                    "c3_H2 : eq\n  match nm with\n  | NMemDead => false\n  | NMem stk gl =>\n      match p with\n      | Gl id ofs =>\n          match PTree.get id gl with\n          | Some iv =>\n              negb\n                (ISet.contains (Ptrofs.unsigned ofs)\n                   (Z.add (Ptrofs.unsigned ofs) sz) iv)\n          | None => true\n          end\n      | Stk ofs =>\n          negb\n            (ISet.contains (Ptrofs.unsigned ofs)\n               (Z.add (Ptrofs.unsigned ofs) sz) stk)\n      | _ => true\n      end\n  end false",
                    "c3_H3 : Logic.and (Z.le (Ptrofs.unsigned ofs) i)\n  (Z.lt i (Z.add (Ptrofs.unsigned ofs) sz))"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "c3_goal : not (nlive nm b i)"
                ],
                "tactic_res": [
                    "c4_goal : forall _ : nlive nm b i, False"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros L .",
                "tactic_args": [
                    "c4_goal : forall _ : nlive nm b i, False"
                ],
                "tactic_res": [
                    "c5_goal : False",
                    "c5_L : nlive nm b i"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c5_L : nlive nm b i"
                ],
                "tactic_res": [
                    "c5_GL : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)",
                    "c5_STK : forall _ : eq b sp, not (ISet.In i stk)",
                    "c5_H2 : eq\n  match p with\n  | Gl id ofs =>\n      match PTree.get id gl with\n      | Some iv =>\n          negb\n            (ISet.contains (Ptrofs.unsigned ofs)\n               (Z.add (Ptrofs.unsigned ofs) sz) iv)\n      | None => true\n      end\n  | Stk ofs =>\n      negb\n        (ISet.contains (Ptrofs.unsigned ofs)\n           (Z.add (Ptrofs.unsigned ofs) sz) stk)\n  | _ => true\n  end false",
                    "c5_gl : PTree.tree ISet.t",
                    "c5_stk : ISet.t"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c5_goal : False",
                    "c3_H1 : pmatch bc b ofs p"
                ],
                "tactic_res": [
                    "c6_goal : False",
                    "c6_H4 : eq (bc b) (BCglob id)",
                    "c6_H2 : eq\n  match PTree.get id gl with\n  | Some iv =>\n      negb\n        (ISet.contains (Ptrofs.unsigned ofs)\n           (Z.add (Ptrofs.unsigned ofs) sz) iv)\n  | None => true\n  end false",
                    "c6_id : ident",
                    "c7_goal : False",
                    "c7_H4 : eq (bc b) (BCglob id)",
                    "c7_id : ident",
                    "c7_H2 : eq true false",
                    "c8_goal : False",
                    "c8_H4 : eq (bc b) (BCglob id)",
                    "c8_id : ident",
                    "c8_H2 : eq true false",
                    "c9_goal : False",
                    "c9_H4 : eq (bc b) BCstack",
                    "c9_H2 : eq\n  (negb\n     (ISet.contains (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz) stk)) false",
                    "c10_goal : False",
                    "c10_H4 : eq (bc b) BCstack",
                    "c10_H2 : eq true false",
                    "c11_goal : False",
                    "c11_H5 : not (eq (bc b) BCinvalid)",
                    "c11_H4 : not (eq (bc b) BCstack)",
                    "c11_H2 : eq true false",
                    "c12_goal : False",
                    "c12_H4 : not (eq (bc b) BCinvalid)",
                    "c12_H2 : eq true false"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c7_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c8_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c10_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c11_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c12_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( Genv.find_symbol _i _i = Some _i ) by ( eapply _i ; eauto ) .",
                "tactic_sig_no_out_arg": "assert ( Genv.find_symbol _i _i = Some _i ) by ( eapply _i ; eauto ) .",
                "tactic_args": [
                    "c1_ge : genv",
                    "c6_id : ident",
                    "c3_b : block",
                    "c3_H : genv_match bc ge"
                ],
                "tactic_res": [
                    "c6_H1 : eq (Genv.find_symbol ge id) (Some b)"
                ]
            },
            {
                "tactic_sig": "destruct gl!id as [ iv| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct gl!id as [ iv| ] eqn : HG .",
                "tactic_args": [
                    "c6_goal : False"
                ],
                "tactic_res": [
                    "c13_goal : False",
                    "c13_H2 : eq\n  (negb\n     (ISet.contains (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz) iv)) false",
                    "c13_HG : eq (PTree.get id gl) (Some iv)",
                    "c13_iv : ISet.t",
                    "c14_goal : False",
                    "c14_H2 : eq true false",
                    "c14_HG : eq (PTree.get id gl) None"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c3_H2 : eq\n  match nm with\n  | NMemDead => false\n  | NMem stk gl =>\n      match p with\n      | Gl id ofs =>\n          match PTree.get id gl with\n          | Some iv =>\n              negb\n                (ISet.contains (Ptrofs.unsigned ofs)\n                   (Z.add (Ptrofs.unsigned ofs) sz) iv)\n          | None => true\n          end\n      | Stk ofs =>\n          negb\n            (ISet.contains (Ptrofs.unsigned ofs)\n               (Z.add (Ptrofs.unsigned ofs) sz) stk)\n      | _ => true\n      end\n  end false"
                ],
                "tactic_res": [
                    "c13_H6 : eq\n  (negb\n     (ISet.contains (Ptrofs.unsigned ofs)\n        (Z.add (Ptrofs.unsigned ofs) sz) iv)) false"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c14_goal : False",
                    "c3_H2 : eq\n  match nm with\n  | NMemDead => false\n  | NMem stk gl =>\n      match p with\n      | Gl id ofs =>\n          match PTree.get id gl with\n          | Some iv =>\n              negb\n                (ISet.contains (Ptrofs.unsigned ofs)\n                   (Z.add (Ptrofs.unsigned ofs) sz) iv)\n          | None => true\n          end\n      | Stk ofs =>\n          negb\n            (ISet.contains (Ptrofs.unsigned ofs)\n               (Z.add (Ptrofs.unsigned ofs) sz) stk)\n      | _ => true\n      end\n  end false"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( ISet.contains ( Ptrofs.unsigned _i ) ( Ptrofs.unsigned _i + _i ) _i ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( ISet.contains ( Ptrofs.unsigned _i ) ( Ptrofs.unsigned _i + _i ) _i ) eqn : IC .",
                "tactic_args": [
                    "c13_goal : False",
                    "c3_ofs : Ptrofs.int",
                    "c3_ofs : Ptrofs.int",
                    "c3_sz : Z",
                    "c13_iv : ISet.t"
                ],
                "tactic_res": [
                    "c15_goal : False",
                    "c15_H6 : eq (negb true) false",
                    "c15_IC : eq\n  (ISet.contains (Ptrofs.unsigned ofs) (Z.add (Ptrofs.unsigned ofs) sz)\n     iv) true",
                    "c16_goal : False",
                    "c16_H6 : eq (negb false) false",
                    "c16_IC : eq\n  (ISet.contains (Ptrofs.unsigned ofs) (Z.add (Ptrofs.unsigned ofs) sz)\n     iv) false"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c16_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ISet.contains_spec in _i .",
                "tactic_sig_no_out_arg": "rewrite ISet.contains_spec in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c15_IC : eq\n  (ISet.contains (Ptrofs.unsigned ofs) (Z.add (Ptrofs.unsigned ofs) sz)\n     iv) true"
                ],
                "tactic_res": [
                    "c15_IC : forall (x : Z)\n  (_ : Logic.and (Z.le (Ptrofs.unsigned ofs) x)\n         (Z.lt x (Z.add (Ptrofs.unsigned ofs) sz))), \nISet.In x iv"
                ]
            },
            {
                "tactic_sig": "eelim _i .",
                "tactic_sig_no_out_arg": "eelim _i .",
                "tactic_args": [
                    "c15_goal : False",
                    "c5_GL : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)"
                ],
                "tactic_res": [
                    "c17_goal : eq (Genv.find_symbol ge ?id) (Some b)",
                    "c18_goal : eq (PTree.get ?id gl) (Some ?iv)",
                    "c19_goal : ISet.In i ?iv"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c17_goal : eq (Genv.find_symbol ge ?id) (Some b)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c18_goal : eq (PTree.get id gl) (Some ?iv)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c19_goal : ISet.In i iv"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( ISet.contains ( Ptrofs.unsigned _i ) ( Ptrofs.unsigned _i + _i ) _i ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( ISet.contains ( Ptrofs.unsigned _i ) ( Ptrofs.unsigned _i + _i ) _i ) eqn : IC .",
                "tactic_args": [
                    "c9_goal : False",
                    "c3_ofs : Ptrofs.int",
                    "c3_ofs : Ptrofs.int",
                    "c3_sz : Z",
                    "c5_stk : ISet.t"
                ],
                "tactic_res": [
                    "c20_goal : False",
                    "c20_H2 : eq (negb true) false",
                    "c20_IC : eq\n  (ISet.contains (Ptrofs.unsigned ofs) (Z.add (Ptrofs.unsigned ofs) sz)\n     stk) true",
                    "c21_goal : False",
                    "c21_H2 : eq (negb false) false",
                    "c21_IC : eq\n  (ISet.contains (Ptrofs.unsigned ofs) (Z.add (Ptrofs.unsigned ofs) sz)\n     stk) false"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c21_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ISet.contains_spec in _i .",
                "tactic_sig_no_out_arg": "rewrite ISet.contains_spec in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c20_IC : eq\n  (ISet.contains (Ptrofs.unsigned ofs) (Z.add (Ptrofs.unsigned ofs) sz)\n     stk) true"
                ],
                "tactic_res": [
                    "c20_IC : forall (x : Z)\n  (_ : Logic.and (Z.le (Ptrofs.unsigned ofs) x)\n         (Z.lt x (Z.add (Ptrofs.unsigned ofs) sz))), \nISet.In x stk"
                ]
            },
            {
                "tactic_sig": "eelim _i .",
                "tactic_sig_no_out_arg": "eelim _i .",
                "tactic_args": [
                    "c20_goal : False",
                    "c5_STK : forall _ : eq b sp, not (ISet.In i stk)"
                ],
                "tactic_res": [
                    "c22_goal : eq b sp",
                    "c23_goal : ISet.In i stk"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c23_goal : ISet.In i stk"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "c22_goal : eq b sp",
                    "_global_1 : Z",
                    "_global_bc_stack : forall (b : block_classification) (b1 b2 : block)\n         (_ : eq (b b1) BCstack) (_ : eq (b b2) BCstack), \n       eq b1 b2"
                ],
                "tactic_res": [
                    "c24_goal : eq (?b b) BCstack",
                    "c25_goal : eq (?b sp) BCstack"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c24_goal : eq (?b b) BCstack"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c25_goal : eq (bc sp) BCstack"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nlive_dead_stack",
        "proof": [
            {
                "tactic_sig": "Lemma nlive_dead_stack : forall sz b' i , b' <> sp \\/ ~ ( 0 <= i < sz ) -> nlive ( nmem_dead_stack sz ) b' i .",
                "tactic_sig_no_out_arg": "Lemma nlive_dead_stack : forall sz b' i , b' <> sp \\/ ~ ( 0 <= i < sz ) -> nlive ( nmem_dead_stack sz ) b' i .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (sz : Z) (b' : block) (i : Z)\n  (_ : Logic.or (not (eq b' sp))\n         (not (Logic.and (Z.le 0 i) (Z.lt i sz)))),\nnlive (nmem_dead_stack sz) b' i",
                    "c1_sp : block",
                    "c1_ge : genv"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (sz : Z) (b' : block) (i : Z)\n  (_ : Logic.or (not (eq b' sp))\n         (not (Logic.and (Z.le 0 i) (Z.lt i sz)))),\nnlive (nmem_dead_stack sz) b' i"
                ],
                "tactic_res": [
                    "c2_goal : nlive (nmem_dead_stack sz) b' i",
                    "c2_sz : Z",
                    "c2_b' : block",
                    "c2_i : Z",
                    "c2_H : Logic.or (not (eq b' sp)) (not (Logic.and (Z.le 0 i) (Z.lt i sz)))"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c2_goal : nlive (nmem_dead_stack sz) b' i"
                ],
                "tactic_res": [
                    "c3_goal : forall _ : eq b' sp, not (ISet.In i (ISet.interval 0 sz))",
                    "c4_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b'))\n  (_ : eq (PTree.get id (PTree.empty ISet.t)) (Some iv)),\nnot (ISet.In i iv)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c3_goal : forall _ : eq b' sp, not (ISet.In i (ISet.interval 0 sz))"
                ],
                "tactic_res": [
                    "c5_goal : not (ISet.In i (ISet.interval 0 sz))",
                    "c5_H0 : eq b' sp"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b'))\n  (_ : eq (PTree.get id (PTree.empty ISet.t)) (Some iv)),\nnot (ISet.In i iv)"
                ],
                "tactic_res": [
                    "c6_goal : not (ISet.In i iv)",
                    "c6_id : ident",
                    "c6_iv : ISet.t",
                    "c6_H0 : eq (Genv.find_symbol ge id) (Some b')",
                    "c6_H1 : eq (PTree.get id (PTree.empty ISet.t)) (Some iv)"
                ]
            },
            {
                "tactic_sig": "rewrite ISet.In_interval .",
                "tactic_sig_no_out_arg": "rewrite ISet.In_interval .",
                "tactic_args": [
                    "c5_goal : not (ISet.In i (ISet.interval 0 sz))",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c7_goal : not (Logic.and (Z.le 0 i) (Z.lt i sz))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "c7_goal : not (Logic.and (Z.le 0 i) (Z.lt i sz))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite PTree.gempty in _i .",
                "tactic_sig_no_out_arg": "rewrite PTree.gempty in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c6_H1 : eq (PTree.get id (PTree.empty ISet.t)) (Some iv)"
                ],
                "tactic_res": [
                    "c6_H1 : eq None (Some iv)"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "c6_goal : not (ISet.In i iv)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nlive_lub_l",
        "proof": [
            {
                "tactic_sig": "Lemma nlive_lub_l : forall nm1 nm2 b i , nlive nm1 b i -> nlive ( nmem_lub nm1 nm2 ) b i .",
                "tactic_sig_no_out_arg": "Lemma nlive_lub_l : forall nm1 nm2 b i , nlive nm1 b i -> nlive ( nmem_lub nm1 nm2 ) b i .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (nm1 nm2 : nmem) (b : block) (i : Z) (_ : nlive nm1 b i),\nnlive (nmem_lub nm1 nm2) b i",
                    "c1_sp : block",
                    "c1_ge : genv"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (nm1 nm2 : nmem) (b : block) (i : Z) (_ : nlive nm1 b i),\nnlive (nmem_lub nm1 nm2) b i"
                ],
                "tactic_res": [
                    "c2_goal : nlive (nmem_lub nm1 nm2) b i",
                    "c2_nm1 : nmem",
                    "c2_nm2 : nmem",
                    "c2_b : block",
                    "c2_i : Z",
                    "c2_H : nlive nm1 b i"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "c2_goal : nlive (nmem_lub nm1 nm2) b i",
                    "c2_H : nlive nm1 b i"
                ],
                "tactic_res": [
                    "c3_goal : nlive (nmem_lub (NMem stk gl) nm2) b i",
                    "c3_H2 : eq ofs i",
                    "c3_H1 : eq b0 b",
                    "c3_H0 : eq (NMem stk gl) nm1",
                    "c3_GL : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)",
                    "c3_STK : forall _ : eq b sp, not (ISet.In i stk)",
                    "c3_ofs : Z",
                    "c3_b0 : block",
                    "c3_gl : PTree.tree ISet.t",
                    "c3_stk : ISet.t"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : nlive (nmem_lub (NMem stk gl) nm2) b i",
                    "c2_nm2 : nmem"
                ],
                "tactic_res": [
                    "c4_goal : nlive (nmem_lub (NMem stk gl) NMemDead) b i",
                    "c5_goal : nlive (nmem_lub (NMem stk gl) (NMem stk0 gl0)) b i",
                    "c5_gl0 : PTree.t ISet.t",
                    "c5_stk0 : ISet.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : nlive (nmem_lub (NMem stk gl) NMemDead) b i"
                ],
                "tactic_res": [
                    "c6_goal : nlive (NMem stk gl) b i"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : nlive (nmem_lub (NMem stk gl) (NMem stk0 gl0)) b i"
                ],
                "tactic_res": [
                    "c7_goal : nlive\n  (NMem (ISet.inter stk stk0)\n     (PTree.combine\n        (fun o1 o2 : option ISet.t =>\n         match o1 with\n         | Some iv1 =>\n             match o2 with\n             | Some iv2 => Some (ISet.inter iv1 iv2)\n             | None => None\n             end\n         | None => None\n         end) gl gl0)) b i"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : nlive (NMem stk gl) b i"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : nlive\n  (NMem (ISet.inter stk stk0)\n     (PTree.combine\n        (fun o1 o2 : option ISet.t =>\n         match o1 with\n         | Some iv1 =>\n             match o2 with\n             | Some iv2 => Some (ISet.inter iv1 iv2)\n             | None => None\n             end\n         | None => None\n         end) gl gl0)) b i"
                ],
                "tactic_res": [
                    "c8_goal : forall _ : eq b sp, not (ISet.In i (ISet.inter stk stk0))",
                    "c9_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq\n         (PTree.get id\n            (PTree.combine\n               (fun o1 o2 : option ISet.t =>\n                match o1 with\n                | Some iv1 =>\n                    match o2 with\n                    | Some iv2 => Some (ISet.inter iv1 iv2)\n                    | None => None\n                    end\n                | None => None\n                end) gl gl0)) (Some iv)), not (ISet.In i iv)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall _ : eq b sp, not (ISet.In i (ISet.inter stk stk0))"
                ],
                "tactic_res": [
                    "c10_goal : not (ISet.In i (ISet.inter stk stk0))",
                    "c10_H0 : eq b sp"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c9_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq\n         (PTree.get id\n            (PTree.combine\n               (fun o1 o2 : option ISet.t =>\n                match o1 with\n                | Some iv1 =>\n                    match o2 with\n                    | Some iv2 => Some (ISet.inter iv1 iv2)\n                    | None => None\n                    end\n                | None => None\n                end) gl gl0)) (Some iv)), not (ISet.In i iv)"
                ],
                "tactic_res": [
                    "c11_goal : not (ISet.In i iv)",
                    "c11_id : ident",
                    "c11_iv : ISet.t",
                    "c11_H0 : eq (Genv.find_symbol ge id) (Some b)",
                    "c11_H1 : eq\n  (PTree.get id\n     (PTree.combine\n        (fun o1 o2 : option ISet.t =>\n         match o1 with\n         | Some iv1 =>\n             match o2 with\n             | Some iv2 => Some (ISet.inter iv1 iv2)\n             | None => None\n             end\n         | None => None\n         end) gl gl0)) (Some iv)"
                ]
            },
            {
                "tactic_sig": "rewrite ISet.In_inter .",
                "tactic_sig_no_out_arg": "rewrite ISet.In_inter .",
                "tactic_args": [
                    "c10_goal : not (ISet.In i (ISet.inter stk stk0))",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c12_goal : not (Logic.and (ISet.In i stk) (ISet.In i stk0))"
                ]
            },
            {
                "tactic_sig": "intros [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ P Q ] .",
                "tactic_args": [
                    "c12_goal : not (Logic.and (ISet.In i stk) (ISet.In i stk0))"
                ],
                "tactic_res": [
                    "c13_goal : False",
                    "c13_P : ISet.In i stk",
                    "c13_Q : ISet.In i stk0"
                ]
            },
            {
                "tactic_sig": "eelim _i .",
                "tactic_sig_no_out_arg": "eelim _i .",
                "tactic_args": [
                    "c13_goal : False",
                    "c3_STK : forall _ : eq b sp, not (ISet.In i stk)"
                ],
                "tactic_res": [
                    "c14_goal : eq b sp",
                    "c15_goal : ISet.In i stk"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c14_goal : eq b sp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c15_goal : ISet.In i stk"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite PTree.gcombine in _i by auto .",
                "tactic_sig_no_out_arg": "rewrite PTree.gcombine in _i by auto .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c3_H1 : eq b0 b"
                ],
                "tactic_res": [
                    "c11_H1 : eq\n  match PTree.get id gl with\n  | Some iv1 =>\n      match PTree.get id gl0 with\n      | Some iv2 => Some (ISet.inter iv1 iv2)\n      | None => None\n      end\n  | None => None\n  end (Some iv)"
                ]
            },
            {
                "tactic_sig": "destruct gl!id as [ iv1| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct gl!id as [ iv1| ] eqn : NG1 .",
                "tactic_args": [
                    "c11_goal : not (ISet.In i iv)"
                ],
                "tactic_res": [
                    "c16_goal : not (ISet.In i iv)",
                    "c16_H1 : eq\n  match PTree.get id gl0 with\n  | Some iv2 => Some (ISet.inter iv1 iv2)\n  | None => None\n  end (Some iv)",
                    "c16_NG1 : eq (PTree.get id gl) (Some iv1)",
                    "c16_iv1 : ISet.t",
                    "c17_goal : not (ISet.In i iv)",
                    "c17_H1 : eq None (Some iv)",
                    "c17_NG1 : eq (PTree.get id gl) None"
                ]
            },
            {
                "tactic_sig": "destruct gl0!id as [ iv2| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct gl0!id as [ iv2| ] eqn : NG2 .",
                "tactic_args": [
                    "c16_goal : not (ISet.In i iv)"
                ],
                "tactic_res": [
                    "c18_goal : not (ISet.In i iv)",
                    "c18_H1 : eq (Some (ISet.inter iv1 iv2)) (Some iv)",
                    "c18_NG2 : eq (PTree.get id gl0) (Some iv2)",
                    "c18_iv2 : ISet.t",
                    "c19_goal : not (ISet.In i iv)",
                    "c19_H1 : eq None (Some iv)",
                    "c19_NG2 : eq (PTree.get id gl0) None"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c18_goal : not (ISet.In i iv)",
                    "c3_H1 : eq b0 b"
                ],
                "tactic_res": [
                    "c20_goal : not (ISet.In i (ISet.inter iv1 iv2))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c19_goal : not (ISet.In i iv)",
                    "c3_H1 : eq b0 b"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c17_goal : not (ISet.In i iv)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ISet.In_inter .",
                "tactic_sig_no_out_arg": "rewrite ISet.In_inter .",
                "tactic_args": [
                    "c20_goal : not (ISet.In i (ISet.inter iv1 iv2))",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c21_goal : not (Logic.and (ISet.In i iv1) (ISet.In i iv2))"
                ]
            },
            {
                "tactic_sig": "intros [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ P Q ] .",
                "tactic_args": [
                    "c21_goal : not (Logic.and (ISet.In i iv1) (ISet.In i iv2))"
                ],
                "tactic_res": [
                    "c22_goal : False",
                    "c22_P : ISet.In i iv1",
                    "c22_Q : ISet.In i iv2"
                ]
            },
            {
                "tactic_sig": "eelim _i .",
                "tactic_sig_no_out_arg": "eelim _i .",
                "tactic_args": [
                    "c22_goal : False",
                    "c3_GL : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)"
                ],
                "tactic_res": [
                    "c23_goal : eq (Genv.find_symbol ge ?id) (Some b)",
                    "c24_goal : eq (PTree.get ?id gl) (Some ?iv)",
                    "c25_goal : ISet.In i ?iv"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c23_goal : eq (Genv.find_symbol ge ?id) (Some b)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c24_goal : eq (PTree.get id gl) (Some ?iv)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c25_goal : ISet.In i iv1"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nlive_lub_r",
        "proof": [
            {
                "tactic_sig": "Lemma nlive_lub_r : forall nm1 nm2 b i , nlive nm2 b i -> nlive ( nmem_lub nm1 nm2 ) b i .",
                "tactic_sig_no_out_arg": "Lemma nlive_lub_r : forall nm1 nm2 b i , nlive nm2 b i -> nlive ( nmem_lub nm1 nm2 ) b i .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (nm1 nm2 : nmem) (b : block) (i : Z) (_ : nlive nm2 b i),\nnlive (nmem_lub nm1 nm2) b i",
                    "c1_sp : block",
                    "c1_ge : genv"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c1_goal : forall (nm1 nm2 : nmem) (b : block) (i : Z) (_ : nlive nm2 b i),\nnlive (nmem_lub nm1 nm2) b i"
                ],
                "tactic_res": [
                    "c2_goal : nlive (nmem_lub nm1 nm2) b i",
                    "c2_nm1 : nmem",
                    "c2_nm2 : nmem",
                    "c2_b : block",
                    "c2_i : Z",
                    "c2_H : nlive nm2 b i"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "c2_goal : nlive (nmem_lub nm1 nm2) b i",
                    "c2_H : nlive nm2 b i"
                ],
                "tactic_res": [
                    "c3_goal : nlive (nmem_lub nm1 (NMem stk gl)) b i",
                    "c3_H2 : eq ofs i",
                    "c3_H1 : eq b0 b",
                    "c3_H0 : eq (NMem stk gl) nm2",
                    "c3_GL : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)",
                    "c3_STK : forall _ : eq b sp, not (ISet.In i stk)",
                    "c3_ofs : Z",
                    "c3_b0 : block",
                    "c3_gl : PTree.tree ISet.t",
                    "c3_stk : ISet.t"
                ]
            },
            {
                "tactic_sig": "destruct _i as [  | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "c3_goal : nlive (nmem_lub nm1 (NMem stk gl)) b i",
                    "c2_nm1 : nmem"
                ],
                "tactic_res": [
                    "c4_goal : nlive (nmem_lub NMemDead (NMem stk gl)) b i",
                    "c5_goal : nlive (nmem_lub (NMem stk0 gl0) (NMem stk gl)) b i",
                    "c5_gl0 : PTree.t ISet.t",
                    "c5_stk0 : ISet.t"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c4_goal : nlive (nmem_lub NMemDead (NMem stk gl)) b i"
                ],
                "tactic_res": [
                    "c6_goal : nlive (NMem stk gl) b i"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c5_goal : nlive (nmem_lub (NMem stk0 gl0) (NMem stk gl)) b i"
                ],
                "tactic_res": [
                    "c7_goal : nlive\n  (NMem (ISet.inter stk0 stk)\n     (PTree.combine\n        (fun o1 o2 : option ISet.t =>\n         match o1 with\n         | Some iv1 =>\n             match o2 with\n             | Some iv2 => Some (ISet.inter iv1 iv2)\n             | None => None\n             end\n         | None => None\n         end) gl0 gl)) b i"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c6_goal : nlive (NMem stk gl) b i"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c7_goal : nlive\n  (NMem (ISet.inter stk0 stk)\n     (PTree.combine\n        (fun o1 o2 : option ISet.t =>\n         match o1 with\n         | Some iv1 =>\n             match o2 with\n             | Some iv2 => Some (ISet.inter iv1 iv2)\n             | None => None\n             end\n         | None => None\n         end) gl0 gl)) b i"
                ],
                "tactic_res": [
                    "c8_goal : forall _ : eq b sp, not (ISet.In i (ISet.inter stk0 stk))",
                    "c9_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq\n         (PTree.get id\n            (PTree.combine\n               (fun o1 o2 : option ISet.t =>\n                match o1 with\n                | Some iv1 =>\n                    match o2 with\n                    | Some iv2 => Some (ISet.inter iv1 iv2)\n                    | None => None\n                    end\n                | None => None\n                end) gl0 gl)) (Some iv)), not (ISet.In i iv)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c8_goal : forall _ : eq b sp, not (ISet.In i (ISet.inter stk0 stk))"
                ],
                "tactic_res": [
                    "c10_goal : not (ISet.In i (ISet.inter stk0 stk))",
                    "c10_H0 : eq b sp"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c9_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq\n         (PTree.get id\n            (PTree.combine\n               (fun o1 o2 : option ISet.t =>\n                match o1 with\n                | Some iv1 =>\n                    match o2 with\n                    | Some iv2 => Some (ISet.inter iv1 iv2)\n                    | None => None\n                    end\n                | None => None\n                end) gl0 gl)) (Some iv)), not (ISet.In i iv)"
                ],
                "tactic_res": [
                    "c11_goal : not (ISet.In i iv)",
                    "c11_id : ident",
                    "c11_iv : ISet.t",
                    "c11_H0 : eq (Genv.find_symbol ge id) (Some b)",
                    "c11_H1 : eq\n  (PTree.get id\n     (PTree.combine\n        (fun o1 o2 : option ISet.t =>\n         match o1 with\n         | Some iv1 =>\n             match o2 with\n             | Some iv2 => Some (ISet.inter iv1 iv2)\n             | None => None\n             end\n         | None => None\n         end) gl0 gl)) (Some iv)"
                ]
            },
            {
                "tactic_sig": "rewrite ISet.In_inter .",
                "tactic_sig_no_out_arg": "rewrite ISet.In_inter .",
                "tactic_args": [
                    "c10_goal : not (ISet.In i (ISet.inter stk0 stk))",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c12_goal : not (Logic.and (ISet.In i stk0) (ISet.In i stk))"
                ]
            },
            {
                "tactic_sig": "intros [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ P Q ] .",
                "tactic_args": [
                    "c12_goal : not (Logic.and (ISet.In i stk0) (ISet.In i stk))"
                ],
                "tactic_res": [
                    "c13_goal : False",
                    "c13_P : ISet.In i stk0",
                    "c13_Q : ISet.In i stk"
                ]
            },
            {
                "tactic_sig": "eelim _i .",
                "tactic_sig_no_out_arg": "eelim _i .",
                "tactic_args": [
                    "c13_goal : False",
                    "c3_STK : forall _ : eq b sp, not (ISet.In i stk)"
                ],
                "tactic_res": [
                    "c14_goal : eq b sp",
                    "c15_goal : ISet.In i stk"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c14_goal : eq b sp"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c15_goal : ISet.In i stk"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite PTree.gcombine in _i by auto .",
                "tactic_sig_no_out_arg": "rewrite PTree.gcombine in _i by auto .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c3_H1 : eq b0 b"
                ],
                "tactic_res": [
                    "c11_H1 : eq\n  match PTree.get id gl0 with\n  | Some iv1 =>\n      match PTree.get id gl with\n      | Some iv2 => Some (ISet.inter iv1 iv2)\n      | None => None\n      end\n  | None => None\n  end (Some iv)"
                ]
            },
            {
                "tactic_sig": "destruct gl0!id as [ iv1| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct gl0!id as [ iv1| ] eqn : NG1 .",
                "tactic_args": [
                    "c11_goal : not (ISet.In i iv)"
                ],
                "tactic_res": [
                    "c16_goal : not (ISet.In i iv)",
                    "c16_H1 : eq\n  match PTree.get id gl with\n  | Some iv2 => Some (ISet.inter iv1 iv2)\n  | None => None\n  end (Some iv)",
                    "c16_NG1 : eq (PTree.get id gl0) (Some iv1)",
                    "c16_iv1 : ISet.t",
                    "c17_goal : not (ISet.In i iv)",
                    "c17_H1 : eq None (Some iv)",
                    "c17_NG1 : eq (PTree.get id gl0) None"
                ]
            },
            {
                "tactic_sig": "destruct gl!id as [ iv2| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct gl!id as [ iv2| ] eqn : NG2 .",
                "tactic_args": [
                    "c16_goal : not (ISet.In i iv)"
                ],
                "tactic_res": [
                    "c18_goal : not (ISet.In i iv)",
                    "c18_H1 : eq (Some (ISet.inter iv1 iv2)) (Some iv)",
                    "c18_NG2 : eq (PTree.get id gl) (Some iv2)",
                    "c18_iv2 : ISet.t",
                    "c19_goal : not (ISet.In i iv)",
                    "c19_H1 : eq None (Some iv)",
                    "c19_NG2 : eq (PTree.get id gl) None"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c18_goal : not (ISet.In i iv)",
                    "c3_H1 : eq b0 b"
                ],
                "tactic_res": [
                    "c20_goal : not (ISet.In i (ISet.inter iv1 iv2))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c19_goal : not (ISet.In i iv)",
                    "c3_H1 : eq b0 b"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c17_goal : not (ISet.In i iv)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ISet.In_inter .",
                "tactic_sig_no_out_arg": "rewrite ISet.In_inter .",
                "tactic_args": [
                    "c20_goal : not (ISet.In i (ISet.inter iv1 iv2))",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c21_goal : not (Logic.and (ISet.In i iv1) (ISet.In i iv2))"
                ]
            },
            {
                "tactic_sig": "intros [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ P Q ] .",
                "tactic_args": [
                    "c21_goal : not (Logic.and (ISet.In i iv1) (ISet.In i iv2))"
                ],
                "tactic_res": [
                    "c22_goal : False",
                    "c22_P : ISet.In i iv1",
                    "c22_Q : ISet.In i iv2"
                ]
            },
            {
                "tactic_sig": "eelim _i .",
                "tactic_sig_no_out_arg": "eelim _i .",
                "tactic_args": [
                    "c22_goal : False",
                    "c3_GL : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl) (Some iv)), not (ISet.In i iv)"
                ],
                "tactic_res": [
                    "c23_goal : eq (Genv.find_symbol ge ?id) (Some b)",
                    "c24_goal : eq (PTree.get ?id gl) (Some ?iv)",
                    "c25_goal : ISet.In i ?iv"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c23_goal : eq (Genv.find_symbol ge ?id) (Some b)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c24_goal : eq (PTree.get id gl) (Some ?iv)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c25_goal : ISet.In i iv2"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nmem_beq_sound",
        "proof": [
            {
                "tactic_sig": "Lemma nmem_beq_sound : forall nm1 nm2 b ofs , nmem_beq nm1 nm2 = true -> ( nlive nm1 b ofs <- > nlive nm2 b ofs ) .",
                "tactic_sig_no_out_arg": "Lemma nmem_beq_sound : forall nm1 nm2 b ofs , nmem_beq nm1 nm2 = true -> ( nlive nm1 b ofs <- > nlive nm2 b ofs ) .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (nm1 nm2 : nmem) (b : block) (ofs : Z)\n  (_ : eq (nmem_beq nm1 nm2) true),\niff (nlive nm1 b ofs) (nlive nm2 b ofs)",
                    "c1_sp : block",
                    "c1_ge : genv"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (nm1 nm2 : nmem) (b : block) (ofs : Z)\n  (_ : eq (nmem_beq nm1 nm2) true),\niff (nlive nm1 b ofs) (nlive nm2 b ofs)",
                    "_global_1 : Z",
                    "_global_nmem_beq : forall (_ : nmem) (_ : nmem), bool"
                ],
                "tactic_res": [
                    "c2_goal : forall (nm1 nm2 : nmem) (b : block) (ofs : Z)\n  (_ : eq\n         match nm1 with\n         | NMemDead =>\n             match nm2 with\n             | NMemDead => true\n             | NMem _ _ => false\n             end\n         | NMem stk1 gl1 =>\n             match nm2 with\n             | NMemDead => false\n             | NMem stk2 gl2 =>\n                 andb (ISet.beq stk1 stk2) (PTree.beq ISet.beq gl1 gl2)\n             end\n         end true), iff (nlive nm1 b ofs) (nlive nm2 b ofs)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c2_goal : forall (nm1 nm2 : nmem) (b : block) (ofs : Z)\n  (_ : eq\n         match nm1 with\n         | NMemDead =>\n             match nm2 with\n             | NMemDead => true\n             | NMem _ _ => false\n             end\n         | NMem stk1 gl1 =>\n             match nm2 with\n             | NMemDead => false\n             | NMem stk2 gl2 =>\n                 andb (ISet.beq stk1 stk2) (PTree.beq ISet.beq gl1 gl2)\n             end\n         end true), iff (nlive nm1 b ofs) (nlive nm2 b ofs)"
                ],
                "tactic_res": [
                    "c3_goal : iff (nlive nm1 b ofs) (nlive nm2 b ofs)",
                    "c3_nm1 : nmem",
                    "c3_nm2 : nmem",
                    "c3_b : block",
                    "c3_ofs : Z",
                    "c3_H : eq\n  match nm1 with\n  | NMemDead =>\n      match nm2 with\n      | NMemDead => true\n      | NMem _ _ => false\n      end\n  | NMem stk1 gl1 =>\n      match nm2 with\n      | NMemDead => false\n      | NMem stk2 gl2 =>\n          andb (ISet.beq stk1 stk2) (PTree.beq ISet.beq gl1 gl2)\n      end\n  end true"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ | stk1 gl1 ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ | stk1 gl1 ] .",
                "tactic_args": [
                    "c3_goal : iff (nlive nm1 b ofs) (nlive nm2 b ofs)",
                    "c3_nm1 : nmem"
                ],
                "tactic_res": [
                    "c4_goal : iff (nlive NMemDead b ofs) (nlive nm2 b ofs)",
                    "c4_H : eq match nm2 with\n   | NMemDead => true\n   | NMem _ _ => false\n   end true",
                    "c5_goal : iff (nlive (NMem stk1 gl1) b ofs) (nlive nm2 b ofs)",
                    "c5_H : eq\n  match nm2 with\n  | NMemDead => false\n  | NMem stk2 gl2 =>\n      andb (ISet.beq stk1 stk2) (PTree.beq ISet.beq gl1 gl2)\n  end true",
                    "c5_gl1 : PTree.t ISet.t",
                    "c5_stk1 : ISet.t"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ | stk2 gl2 ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ | stk2 gl2 ] .",
                "tactic_args": [
                    "c4_goal : iff (nlive NMemDead b ofs) (nlive nm2 b ofs)",
                    "c3_nm2 : nmem"
                ],
                "tactic_res": [
                    "c6_goal : iff (nlive NMemDead b ofs) (nlive NMemDead b ofs)",
                    "c6_H : eq true true",
                    "c7_goal : iff (nlive NMemDead b ofs) (nlive (NMem stk2 gl2) b ofs)",
                    "c7_H : eq false true",
                    "c7_gl2 : PTree.t ISet.t",
                    "c7_stk2 : ISet.t"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c7_goal : iff (nlive NMemDead b ofs) (nlive (NMem stk2 gl2) b ofs)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [ | stk2 gl2 ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ | stk2 gl2 ] .",
                "tactic_args": [
                    "c5_goal : iff (nlive (NMem stk1 gl1) b ofs) (nlive nm2 b ofs)",
                    "c3_nm2 : nmem"
                ],
                "tactic_res": [
                    "c8_goal : iff (nlive (NMem stk1 gl1) b ofs) (nlive NMemDead b ofs)",
                    "c8_H : eq false true",
                    "c9_goal : iff (nlive (NMem stk1 gl1) b ofs) (nlive (NMem stk2 gl2) b ofs)",
                    "c9_H : eq (andb (ISet.beq stk1 stk2) (PTree.beq ISet.beq gl1 gl2)) true",
                    "c9_gl2 : PTree.t ISet.t",
                    "c9_stk2 : ISet.t"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "c8_goal : iff (nlive (NMem stk1 gl1) b ofs) (nlive NMemDead b ofs)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c6_goal : iff (nlive NMemDead b ofs) (nlive NMemDead b ofs)"
                ],
                "tactic_res": [
                    "c10_goal : forall _ : nlive NMemDead b ofs, nlive NMemDead b ofs",
                    "c11_goal : forall _ : nlive NMemDead b ofs, nlive NMemDead b ofs"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros L .",
                "tactic_args": [
                    "c10_goal : forall _ : nlive NMemDead b ofs, nlive NMemDead b ofs"
                ],
                "tactic_res": [
                    "c12_goal : nlive NMemDead b ofs",
                    "c12_L : nlive NMemDead b ofs"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c12_goal : nlive NMemDead b ofs",
                    "c12_L : nlive NMemDead b ofs"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros L .",
                "tactic_args": [
                    "c11_goal : forall _ : nlive NMemDead b ofs, nlive NMemDead b ofs"
                ],
                "tactic_res": [
                    "c13_goal : nlive NMemDead b ofs",
                    "c13_L : nlive NMemDead b ofs"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c13_goal : nlive NMemDead b ofs",
                    "c13_L : nlive NMemDead b ofs"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ISet.beq_spec in _i .",
                "tactic_sig_no_out_arg": "rewrite ISet.beq_spec in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c9_H0 : eq (ISet.beq stk1 stk2) true"
                ],
                "tactic_res": [
                    "c9_H0 : forall x : Z, iff (ISet.In x stk1) (ISet.In x stk2)"
                ]
            },
            {
                "tactic_sig": "rewrite PTree.beq_correct in _i .",
                "tactic_sig_no_out_arg": "rewrite PTree.beq_correct in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c9_H1 : eq (PTree.beq ISet.beq gl1 gl2) true"
                ],
                "tactic_res": [
                    "c9_H1 : forall x : PTree.elt,\nmatch PTree.get x gl1 with\n| Some y1 =>\n    match PTree.get x gl2 with\n    | Some y2 => eq (ISet.beq y1 y2) true\n    | None => False\n    end\n| None =>\n    match PTree.get x gl2 with\n    | Some _ => False\n    | None => True\n    end\nend"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c9_goal : iff (nlive (NMem stk1 gl1) b ofs) (nlive (NMem stk2 gl2) b ofs)"
                ],
                "tactic_res": [
                    "c14_goal : forall _ : nlive (NMem stk1 gl1) b ofs, nlive (NMem stk2 gl2) b ofs",
                    "c15_goal : forall _ : nlive (NMem stk2 gl2) b ofs, nlive (NMem stk1 gl1) b ofs"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros L .",
                "tactic_args": [
                    "c14_goal : forall _ : nlive (NMem stk1 gl1) b ofs, nlive (NMem stk2 gl2) b ofs"
                ],
                "tactic_res": [
                    "c16_goal : nlive (NMem stk2 gl2) b ofs",
                    "c16_L : nlive (NMem stk1 gl1) b ofs"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c16_L : nlive (NMem stk1 gl1) b ofs"
                ],
                "tactic_res": [
                    "c16_GL : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl1) (Some iv)), not (ISet.In ofs iv)",
                    "c16_STK : forall _ : eq b sp, not (ISet.In ofs stk1)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c16_goal : nlive (NMem stk2 gl2) b ofs"
                ],
                "tactic_res": [
                    "c17_goal : forall _ : eq b sp, not (ISet.In ofs stk2)",
                    "c18_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl2) (Some iv)), not (ISet.In ofs iv)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c17_goal : forall _ : eq b sp, not (ISet.In ofs stk2)"
                ],
                "tactic_res": [
                    "c19_goal : not (ISet.In ofs stk2)",
                    "c19_H : eq b sp"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c18_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl2) (Some iv)), not (ISet.In ofs iv)"
                ],
                "tactic_res": [
                    "c20_goal : not (ISet.In ofs iv)",
                    "c20_id : ident",
                    "c20_iv : ISet.t",
                    "c20_H : eq (Genv.find_symbol ge id) (Some b)",
                    "c20_H2 : eq (PTree.get id gl2) (Some iv)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros L .",
                "tactic_args": [
                    "c15_goal : forall _ : nlive (NMem stk2 gl2) b ofs, nlive (NMem stk1 gl1) b ofs"
                ],
                "tactic_res": [
                    "c21_goal : nlive (NMem stk1 gl1) b ofs",
                    "c21_L : nlive (NMem stk2 gl2) b ofs"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c21_L : nlive (NMem stk2 gl2) b ofs"
                ],
                "tactic_res": [
                    "c21_GL : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl2) (Some iv)), not (ISet.In ofs iv)",
                    "c21_STK : forall _ : eq b sp, not (ISet.In ofs stk2)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "c21_goal : nlive (NMem stk1 gl1) b ofs"
                ],
                "tactic_res": [
                    "c22_goal : forall _ : eq b sp, not (ISet.In ofs stk1)",
                    "c23_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl1) (Some iv)), not (ISet.In ofs iv)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c22_goal : forall _ : eq b sp, not (ISet.In ofs stk1)"
                ],
                "tactic_res": [
                    "c24_goal : not (ISet.In ofs stk1)",
                    "c24_H : eq b sp"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c23_goal : forall (id : ident) (iv : ISet.t)\n  (_ : eq (Genv.find_symbol ge id) (Some b))\n  (_ : eq (PTree.get id gl1) (Some iv)), not (ISet.In ofs iv)"
                ],
                "tactic_res": [
                    "c25_goal : not (ISet.In ofs iv)",
                    "c25_id : ident",
                    "c25_iv : ISet.t",
                    "c25_H : eq (Genv.find_symbol ge id) (Some b)",
                    "c25_H2 : eq (PTree.get id gl1) (Some iv)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c19_goal : not (ISet.In ofs stk2)",
                    "_global_1 : Z",
                    "c9_H0 : eq (ISet.beq stk1 stk2) true"
                ],
                "tactic_res": [
                    "c26_goal : not (ISet.In ofs stk1)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c26_goal : not (ISet.In ofs stk1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "c9_H1 : eq (PTree.beq ISet.beq gl1 gl2) true",
                    "c20_id : ident"
                ],
                "tactic_res": [
                    "c20_H1 : match PTree.get id gl1 with\n| Some y1 =>\n    match PTree.get id gl2 with\n    | Some y2 => eq (ISet.beq y1 y2) true\n    | None => False\n    end\n| None =>\n    match PTree.get id gl2 with\n    | Some _ => False\n    | None => True\n    end\nend"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c20_H2 : eq (PTree.get id gl2) (Some iv)",
                    "c9_H1 : eq (PTree.beq ISet.beq gl1 gl2) true"
                ],
                "tactic_res": [
                    "c20_H1 : match PTree.get id gl1 with\n| Some y1 => eq (ISet.beq y1 iv) true\n| None => False\nend"
                ]
            },
            {
                "tactic_sig": "destruct gl1!id as [ iv1| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct gl1!id as [ iv1| ] eqn : NG .",
                "tactic_args": [
                    "c20_goal : not (ISet.In ofs iv)"
                ],
                "tactic_res": [
                    "c27_goal : not (ISet.In ofs iv)",
                    "c27_H1 : eq (ISet.beq iv1 iv) true",
                    "c27_NG : eq (PTree.get id gl1) (Some iv1)",
                    "c27_iv1 : ISet.t",
                    "c28_goal : not (ISet.In ofs iv)",
                    "c28_H1 : False",
                    "c28_NG : eq (PTree.get id gl1) None"
                ]
            },
            {
                "tactic_sig": "try contradiction .",
                "tactic_sig_no_out_arg": "try contradiction .",
                "tactic_args": [
                    "c28_goal : not (ISet.In ofs iv)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ISet.beq_spec in _i .",
                "tactic_sig_no_out_arg": "rewrite ISet.beq_spec in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c9_H1 : eq (PTree.beq ISet.beq gl1 gl2) true"
                ],
                "tactic_res": [
                    "c27_H1 : forall x : Z, iff (ISet.In x iv1) (ISet.In x iv)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "c27_goal : not (ISet.In ofs iv)",
                    "_global_1 : Z",
                    "c9_H1 : eq (PTree.beq ISet.beq gl1 gl2) true"
                ],
                "tactic_res": [
                    "c29_goal : not (ISet.In ofs iv1)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c29_goal : not (ISet.In ofs iv1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c24_goal : not (ISet.In ofs stk1)",
                    "_global_1 : Z",
                    "c9_H0 : eq (ISet.beq stk1 stk2) true"
                ],
                "tactic_res": [
                    "c30_goal : not (ISet.In ofs stk2)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c30_goal : not (ISet.In ofs stk2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "c9_H1 : eq (PTree.beq ISet.beq gl1 gl2) true",
                    "c25_id : ident"
                ],
                "tactic_res": [
                    "c25_H1 : match PTree.get id gl1 with\n| Some y1 =>\n    match PTree.get id gl2 with\n    | Some y2 => eq (ISet.beq y1 y2) true\n    | None => False\n    end\n| None =>\n    match PTree.get id gl2 with\n    | Some _ => False\n    | None => True\n    end\nend"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c25_H2 : eq (PTree.get id gl1) (Some iv)",
                    "c9_H1 : eq (PTree.beq ISet.beq gl1 gl2) true"
                ],
                "tactic_res": [
                    "c25_H1 : match PTree.get id gl2 with\n| Some y2 => eq (ISet.beq iv y2) true\n| None => False\nend"
                ]
            },
            {
                "tactic_sig": "destruct gl2!id as [ iv2| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct gl2!id as [ iv2| ] eqn : NG .",
                "tactic_args": [
                    "c25_goal : not (ISet.In ofs iv)"
                ],
                "tactic_res": [
                    "c31_goal : not (ISet.In ofs iv)",
                    "c31_H1 : eq (ISet.beq iv iv2) true",
                    "c31_NG : eq (PTree.get id gl2) (Some iv2)",
                    "c31_iv2 : ISet.t",
                    "c32_goal : not (ISet.In ofs iv)",
                    "c32_H1 : False",
                    "c32_NG : eq (PTree.get id gl2) None"
                ]
            },
            {
                "tactic_sig": "try contradiction .",
                "tactic_sig_no_out_arg": "try contradiction .",
                "tactic_args": [
                    "c32_goal : not (ISet.In ofs iv)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite ISet.beq_spec in _i .",
                "tactic_sig_no_out_arg": "rewrite ISet.beq_spec in _i .",
                "tactic_args": [
                    "_global_1 : Z",
                    "c9_H1 : eq (PTree.beq ISet.beq gl1 gl2) true"
                ],
                "tactic_res": [
                    "c31_H1 : forall x : Z, iff (ISet.In x iv) (ISet.In x iv2)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c31_goal : not (ISet.In ofs iv)",
                    "_global_1 : Z",
                    "c9_H1 : eq (PTree.beq ISet.beq gl1 gl2) true"
                ],
                "tactic_res": [
                    "c33_goal : not (ISet.In ofs iv2)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c33_goal : not (ISet.In ofs iv2)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eq_refl",
        "proof": [
            {
                "tactic_sig": "Lemma eq_refl : forall x , eq x x .",
                "tactic_sig_no_out_arg": "Lemma eq_refl : forall x , eq x x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t, eq x x"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall x : t, eq x x",
                    "_global_1 : Z",
                    "_global_eq : forall (_ : t) (_ : t), Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall x : t,\nLogic.and (NE.eq (fst x) (fst x))\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp (snd x) b ofs) (nlive ge sp (snd x) b ofs))"
                ]
            },
            {
                "tactic_sig": "destruct x as [  _o _o ] .",
                "tactic_sig_no_out_arg": "destruct x .",
                "tactic_args": [
                    "c2_goal : forall x : t,\nLogic.and (NE.eq (fst x) (fst x))\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp (snd x) b ofs) (nlive ge sp (snd x) b ofs))"
                ],
                "tactic_res": [
                    "c3_goal : Logic.and (NE.eq (fst (pair n n0)) (fst (pair n n0)))\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp (snd (pair n n0)) b ofs)\n     (nlive ge sp (snd (pair n n0)) b ofs))",
                    "c3_n0 : nmem",
                    "c3_n : nenv"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : Logic.and (NE.eq (fst (pair n n0)) (fst (pair n n0)))\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp (snd (pair n n0)) b ofs)\n     (nlive ge sp (snd (pair n n0)) b ofs))"
                ],
                "tactic_res": [
                    "c4_goal : Logic.and (NE.eq n n)\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp n0 b ofs) (nlive ge sp n0 b ofs))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c4_goal : Logic.and (NE.eq n n)\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp n0 b ofs) (nlive ge sp n0 b ofs))"
                ],
                "tactic_res": [
                    "c5_goal : NE.eq n n",
                    "c6_goal : forall (ge : genv) (sp b : block) (ofs : Z),\niff (nlive ge sp n0 b ofs) (nlive ge sp n0 b ofs)"
                ]
            },
            {
                "tactic_sig": "apply NE._i .",
                "tactic_sig_no_out_arg": "apply NE._i .",
                "tactic_args": [
                    "c5_goal : NE.eq n n",
                    "_global_1 : Z",
                    "_global_eq_refl : Logic.eq ?x ?x\nwhere\n?A : [n : nenv  n0 : nmem |- Type]\n?x : [n : nenv  n0 : nmem |- ?A]"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c6_goal : forall (ge : genv) (sp b : block) (ofs : Z),\niff (nlive ge sp n0 b ofs) (nlive ge sp n0 b ofs)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eq_sym",
        "proof": [
            {
                "tactic_sig": "Lemma eq_sym : forall x y , eq x y -> eq y x .",
                "tactic_sig_no_out_arg": "Lemma eq_sym : forall x y , eq x y -> eq y x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y : t) (_ : eq x y), eq y x"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (x y : t) (_ : eq x y), eq y x",
                    "_global_1 : Z",
                    "_global_eq : forall (_ : t) (_ : t), Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall (x y : t)\n  (_ : Logic.and (NE.eq (fst x) (fst y))\n         (forall (ge : genv) (sp b : block) (ofs : Z),\n          iff (nlive ge sp (snd x) b ofs) (nlive ge sp (snd y) b ofs))),\nLogic.and (NE.eq (fst y) (fst x))\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp (snd y) b ofs) (nlive ge sp (snd x) b ofs))"
                ]
            },
            {
                "tactic_sig": "destruct x , y as [  _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct x , y .",
                "tactic_args": [
                    "c2_goal : forall (x y : t)\n  (_ : Logic.and (NE.eq (fst x) (fst y))\n         (forall (ge : genv) (sp b : block) (ofs : Z),\n          iff (nlive ge sp (snd x) b ofs) (nlive ge sp (snd y) b ofs))),\nLogic.and (NE.eq (fst y) (fst x))\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp (snd y) b ofs) (nlive ge sp (snd x) b ofs))"
                ],
                "tactic_res": [
                    "c3_goal : forall\n  _ : Logic.and (NE.eq (fst (pair n n0)) (fst (pair n1 n2)))\n        (forall (ge : genv) (sp b : block) (ofs : Z),\n         iff (nlive ge sp (snd (pair n n0)) b ofs)\n           (nlive ge sp (snd (pair n1 n2)) b ofs)),\nLogic.and (NE.eq (fst (pair n1 n2)) (fst (pair n n0)))\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp (snd (pair n1 n2)) b ofs)\n     (nlive ge sp (snd (pair n n0)) b ofs))",
                    "c3_n2 : nmem",
                    "c3_n1 : nenv",
                    "c3_n0 : nmem",
                    "c3_n : nenv"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall\n  _ : Logic.and (NE.eq (fst (pair n n0)) (fst (pair n1 n2)))\n        (forall (ge : genv) (sp b : block) (ofs : Z),\n         iff (nlive ge sp (snd (pair n n0)) b ofs)\n           (nlive ge sp (snd (pair n1 n2)) b ofs)),\nLogic.and (NE.eq (fst (pair n1 n2)) (fst (pair n n0)))\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp (snd (pair n1 n2)) b ofs)\n     (nlive ge sp (snd (pair n n0)) b ofs))"
                ],
                "tactic_res": [
                    "c4_goal : forall\n  _ : Logic.and (NE.eq n n1)\n        (forall (ge : genv) (sp b : block) (ofs : Z),\n         iff (nlive ge sp n0 b ofs) (nlive ge sp n2 b ofs)),\nLogic.and (NE.eq n1 n)\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp n2 b ofs) (nlive ge sp n0 b ofs))"
                ]
            },
            {
                "tactic_sig": "intros [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ A B ] .",
                "tactic_args": [
                    "c4_goal : forall\n  _ : Logic.and (NE.eq n n1)\n        (forall (ge : genv) (sp b : block) (ofs : Z),\n         iff (nlive ge sp n0 b ofs) (nlive ge sp n2 b ofs)),\nLogic.and (NE.eq n1 n)\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp n2 b ofs) (nlive ge sp n0 b ofs))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.and (NE.eq n1 n)\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp n2 b ofs) (nlive ge sp n0 b ofs))",
                    "c5_A : NE.eq n n1",
                    "c5_B : forall (ge : genv) (sp b : block) (ofs : Z),\niff (nlive ge sp n0 b ofs) (nlive ge sp n2 b ofs)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c5_goal : Logic.and (NE.eq n1 n)\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp n2 b ofs) (nlive ge sp n0 b ofs))"
                ],
                "tactic_res": [
                    "c6_goal : NE.eq n1 n",
                    "c7_goal : forall (ge : genv) (sp b : block) (ofs : Z),\niff (nlive ge sp n2 b ofs) (nlive ge sp n0 b ofs)"
                ]
            },
            {
                "tactic_sig": "apply NE._i .",
                "tactic_sig_no_out_arg": "apply NE._i .",
                "tactic_args": [
                    "c6_goal : NE.eq n1 n",
                    "_global_1 : Z",
                    "_global_eq_sym : forall (A : Type) (x y : A) (_ : Logic.eq x y), Logic.eq y x"
                ],
                "tactic_res": [
                    "c8_goal : NE.eq n n1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : NE.eq n n1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall (ge : genv) (sp b : block) (ofs : Z),\niff (nlive ge sp n2 b ofs) (nlive ge sp n0 b ofs)"
                ],
                "tactic_res": [
                    "c9_goal : iff (nlive ge sp n2 b ofs) (nlive ge sp n0 b ofs)",
                    "c9_ge : genv",
                    "c9_sp : block",
                    "c9_b : block",
                    "c9_ofs : Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c9_goal : iff (nlive ge sp n2 b ofs) (nlive ge sp n0 b ofs)",
                    "_global_1 : Z",
                    "c5_B : forall (ge : genv) (sp b : block) (ofs : Z),\niff (nlive ge sp n0 b ofs) (nlive ge sp n2 b ofs)"
                ],
                "tactic_res": [
                    "c10_goal : iff (nlive ge sp n2 b ofs) (nlive ge sp n2 b ofs)"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "c10_goal : iff (nlive ge sp n2 b ofs) (nlive ge sp n2 b ofs)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eq_trans",
        "proof": [
            {
                "tactic_sig": "Lemma eq_trans : forall x y z , eq x y -> eq y z -> eq x z .",
                "tactic_sig_no_out_arg": "Lemma eq_trans : forall x y z , eq x y -> eq y z -> eq x z .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y z : t) (_ : eq x y) (_ : eq y z), eq x z"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (x y z : t) (_ : eq x y) (_ : eq y z), eq x z",
                    "_global_1 : Z",
                    "_global_eq : forall (_ : t) (_ : t), Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall (x y z : t)\n  (_ : Logic.and (NE.eq (fst x) (fst y))\n         (forall (ge : genv) (sp b : block) (ofs : Z),\n          iff (nlive ge sp (snd x) b ofs) (nlive ge sp (snd y) b ofs)))\n  (_ : Logic.and (NE.eq (fst y) (fst z))\n         (forall (ge : genv) (sp b : block) (ofs : Z),\n          iff (nlive ge sp (snd y) b ofs) (nlive ge sp (snd z) b ofs))),\nLogic.and (NE.eq (fst x) (fst z))\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp (snd x) b ofs) (nlive ge sp (snd z) b ofs))"
                ]
            },
            {
                "tactic_sig": "destruct x , y , z as [  _o _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct x , y , z .",
                "tactic_args": [
                    "c2_goal : forall (x y z : t)\n  (_ : Logic.and (NE.eq (fst x) (fst y))\n         (forall (ge : genv) (sp b : block) (ofs : Z),\n          iff (nlive ge sp (snd x) b ofs) (nlive ge sp (snd y) b ofs)))\n  (_ : Logic.and (NE.eq (fst y) (fst z))\n         (forall (ge : genv) (sp b : block) (ofs : Z),\n          iff (nlive ge sp (snd y) b ofs) (nlive ge sp (snd z) b ofs))),\nLogic.and (NE.eq (fst x) (fst z))\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp (snd x) b ofs) (nlive ge sp (snd z) b ofs))"
                ],
                "tactic_res": [
                    "c3_goal : forall\n  (_ : Logic.and (NE.eq (fst (pair n n0)) (fst (pair n1 n2)))\n         (forall (ge : genv) (sp b : block) (ofs : Z),\n          iff (nlive ge sp (snd (pair n n0)) b ofs)\n            (nlive ge sp (snd (pair n1 n2)) b ofs)))\n  (_ : Logic.and (NE.eq (fst (pair n1 n2)) (fst (pair n3 n4)))\n         (forall (ge : genv) (sp b : block) (ofs : Z),\n          iff (nlive ge sp (snd (pair n1 n2)) b ofs)\n            (nlive ge sp (snd (pair n3 n4)) b ofs))),\nLogic.and (NE.eq (fst (pair n n0)) (fst (pair n3 n4)))\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp (snd (pair n n0)) b ofs)\n     (nlive ge sp (snd (pair n3 n4)) b ofs))",
                    "c3_n4 : nmem",
                    "c3_n3 : nenv",
                    "c3_n2 : nmem",
                    "c3_n1 : nenv",
                    "c3_n0 : nmem",
                    "c3_n : nenv"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall\n  (_ : Logic.and (NE.eq (fst (pair n n0)) (fst (pair n1 n2)))\n         (forall (ge : genv) (sp b : block) (ofs : Z),\n          iff (nlive ge sp (snd (pair n n0)) b ofs)\n            (nlive ge sp (snd (pair n1 n2)) b ofs)))\n  (_ : Logic.and (NE.eq (fst (pair n1 n2)) (fst (pair n3 n4)))\n         (forall (ge : genv) (sp b : block) (ofs : Z),\n          iff (nlive ge sp (snd (pair n1 n2)) b ofs)\n            (nlive ge sp (snd (pair n3 n4)) b ofs))),\nLogic.and (NE.eq (fst (pair n n0)) (fst (pair n3 n4)))\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp (snd (pair n n0)) b ofs)\n     (nlive ge sp (snd (pair n3 n4)) b ofs))"
                ],
                "tactic_res": [
                    "c4_goal : forall\n  (_ : Logic.and (NE.eq n n1)\n         (forall (ge : genv) (sp b : block) (ofs : Z),\n          iff (nlive ge sp n0 b ofs) (nlive ge sp n2 b ofs)))\n  (_ : Logic.and (NE.eq n1 n3)\n         (forall (ge : genv) (sp b : block) (ofs : Z),\n          iff (nlive ge sp n2 b ofs) (nlive ge sp n4 b ofs))),\nLogic.and (NE.eq n n3)\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp n0 b ofs) (nlive ge sp n4 b ofs))"
                ]
            },
            {
                "tactic_sig": "intros [ _o _o ] [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ A B ] [ C D ] .",
                "tactic_args": [
                    "c4_goal : forall\n  (_ : Logic.and (NE.eq n n1)\n         (forall (ge : genv) (sp b : block) (ofs : Z),\n          iff (nlive ge sp n0 b ofs) (nlive ge sp n2 b ofs)))\n  (_ : Logic.and (NE.eq n1 n3)\n         (forall (ge : genv) (sp b : block) (ofs : Z),\n          iff (nlive ge sp n2 b ofs) (nlive ge sp n4 b ofs))),\nLogic.and (NE.eq n n3)\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp n0 b ofs) (nlive ge sp n4 b ofs))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.and (NE.eq n n3)\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp n0 b ofs) (nlive ge sp n4 b ofs))",
                    "c5_A : NE.eq n n1",
                    "c5_B : forall (ge : genv) (sp b : block) (ofs : Z),\niff (nlive ge sp n0 b ofs) (nlive ge sp n2 b ofs)",
                    "c5_C : NE.eq n1 n3",
                    "c5_D : forall (ge : genv) (sp b : block) (ofs : Z),\niff (nlive ge sp n2 b ofs) (nlive ge sp n4 b ofs)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c5_goal : Logic.and (NE.eq n n3)\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp n0 b ofs) (nlive ge sp n4 b ofs))"
                ],
                "tactic_res": [
                    "c6_goal : NE.eq n n3",
                    "c7_goal : forall (ge : genv) (sp b : block) (ofs : Z),\niff (nlive ge sp n0 b ofs) (nlive ge sp n4 b ofs)"
                ]
            },
            {
                "tactic_sig": "eapply NE._i .",
                "tactic_sig_no_out_arg": "eapply NE._i .",
                "tactic_args": [
                    "c6_goal : NE.eq n n3",
                    "_global_1 : Z",
                    "_global_eq_trans : forall (A : Type) (x y z : A) (_ : Logic.eq x y) (_ : Logic.eq y z),\n       Logic.eq x z"
                ],
                "tactic_res": [
                    "c8_goal : NE.eq n ?y",
                    "c9_goal : NE.eq ?y n3"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c8_goal : NE.eq n ?y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c9_goal : NE.eq n1 n3"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall (ge : genv) (sp b : block) (ofs : Z),\niff (nlive ge sp n0 b ofs) (nlive ge sp n4 b ofs)"
                ],
                "tactic_res": [
                    "c10_goal : iff (nlive ge sp n0 b ofs) (nlive ge sp n4 b ofs)",
                    "c10_ge : genv",
                    "c10_sp : block",
                    "c10_b : block",
                    "c10_ofs : Z"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "c10_goal : iff (nlive ge sp n0 b ofs) (nlive ge sp n4 b ofs)",
                    "_global_1 : Z",
                    "c5_B : forall (ge : genv) (sp b : block) (ofs : Z),\niff (nlive ge sp n0 b ofs) (nlive ge sp n2 b ofs)"
                ],
                "tactic_res": [
                    "c11_goal : iff (nlive ge sp n2 b ofs) (nlive ge sp n4 b ofs)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c11_goal : iff (nlive ge sp n2 b ofs) (nlive ge sp n4 b ofs)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "beq_correct",
        "proof": [
            {
                "tactic_sig": "Lemma beq_correct : forall x y , beq x y = true -> eq x y .",
                "tactic_sig_no_out_arg": "Lemma beq_correct : forall x y , beq x y = true -> eq x y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y : t) (_ : Logic.eq (beq x y) true), eq x y"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c1_goal : forall (x y : t) (_ : Logic.eq (beq x y) true), eq x y",
                    "_global_1 : Z",
                    "_global_beq : forall (_ : t) (_ : t), bool",
                    "_global_eq : forall (_ : t) (_ : t), Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall (x y : t)\n  (_ : Logic.eq\n         (andb (NE.beq (fst x) (fst y)) (nmem_beq (snd x) (snd y)))\n         true),\nLogic.and (NE.eq (fst x) (fst y))\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp (snd x) b ofs) (nlive ge sp (snd y) b ofs))"
                ]
            },
            {
                "tactic_sig": "destruct x , y as [  _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct x , y .",
                "tactic_args": [
                    "c2_goal : forall (x y : t)\n  (_ : Logic.eq\n         (andb (NE.beq (fst x) (fst y)) (nmem_beq (snd x) (snd y)))\n         true),\nLogic.and (NE.eq (fst x) (fst y))\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp (snd x) b ofs) (nlive ge sp (snd y) b ofs))"
                ],
                "tactic_res": [
                    "c3_goal : forall\n  _ : Logic.eq\n        (andb (NE.beq (fst (pair n n0)) (fst (pair n1 n2)))\n           (nmem_beq (snd (pair n n0)) (snd (pair n1 n2)))) true,\nLogic.and (NE.eq (fst (pair n n0)) (fst (pair n1 n2)))\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp (snd (pair n n0)) b ofs)\n     (nlive ge sp (snd (pair n1 n2)) b ofs))",
                    "c3_n2 : nmem",
                    "c3_n1 : nenv",
                    "c3_n0 : nmem",
                    "c3_n : nenv"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall\n  _ : Logic.eq\n        (andb (NE.beq (fst (pair n n0)) (fst (pair n1 n2)))\n           (nmem_beq (snd (pair n n0)) (snd (pair n1 n2)))) true,\nLogic.and (NE.eq (fst (pair n n0)) (fst (pair n1 n2)))\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp (snd (pair n n0)) b ofs)\n     (nlive ge sp (snd (pair n1 n2)) b ofs))"
                ],
                "tactic_res": [
                    "c4_goal : forall _ : Logic.eq (andb (NE.beq n n1) (nmem_beq n0 n2)) true,\nLogic.and (NE.eq n n1)\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp n0 b ofs) (nlive ge sp n2 b ofs))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c4_goal : forall _ : Logic.eq (andb (NE.beq n n1) (nmem_beq n0 n2)) true,\nLogic.and (NE.eq n n1)\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp n0 b ofs) (nlive ge sp n2 b ofs))"
                ],
                "tactic_res": [
                    "c5_goal : Logic.and (NE.eq n n1)\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp n0 b ofs) (nlive ge sp n2 b ofs))",
                    "c5_H : Logic.eq (andb (NE.beq n n1) (nmem_beq n0 n2)) true"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c5_goal : Logic.and (NE.eq n n1)\n  (forall (ge : genv) (sp b : block) (ofs : Z),\n   iff (nlive ge sp n0 b ofs) (nlive ge sp n2 b ofs))"
                ],
                "tactic_res": [
                    "c6_goal : NE.eq n n1",
                    "c7_goal : forall (ge : genv) (sp b : block) (ofs : Z),\niff (nlive ge sp n0 b ofs) (nlive ge sp n2 b ofs)"
                ]
            },
            {
                "tactic_sig": "apply NE.beq_correct .",
                "tactic_sig_no_out_arg": "apply NE.beq_correct .",
                "tactic_args": [
                    "c6_goal : NE.eq n n1",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c8_goal : Logic.eq (NE.beq n n1) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : Logic.eq (NE.beq n n1) true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall (ge : genv) (sp b : block) (ofs : Z),\niff (nlive ge sp n0 b ofs) (nlive ge sp n2 b ofs)"
                ],
                "tactic_res": [
                    "c9_goal : iff (nlive ge sp n0 b ofs) (nlive ge sp n2 b ofs)",
                    "c9_ge : genv",
                    "c9_sp : block",
                    "c9_b : block",
                    "c9_ofs : Z"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : iff (nlive ge sp n0 b ofs) (nlive ge sp n2 b ofs)",
                    "_global_1 : Z",
                    "_global_nmem_beq_sound : forall (ge : genv) (sp : block) (nm1 nm2 : nmem) \n         (b : block) (ofs : Z) (_ : Logic.eq (nmem_beq nm1 nm2) true),\n       iff (nlive ge sp nm1 b ofs) (nlive ge sp nm2 b ofs)"
                ],
                "tactic_res": [
                    "c10_goal : Logic.eq (nmem_beq n0 n2) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : Logic.eq (nmem_beq n0 n2) true"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "ge_refl",
        "proof": [
            {
                "tactic_sig": "Lemma ge_refl : forall x y , eq x y -> ge x y .",
                "tactic_sig_no_out_arg": "Lemma ge_refl : forall x y , eq x y -> ge x y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y : t) (_ : eq x y), ge x y"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c1_goal : forall (x y : t) (_ : eq x y), ge x y",
                    "_global_1 : Z",
                    "_global_eq : forall (_ : t) (_ : t), Prop",
                    "_global_ge : forall (_ : t) (_ : t), Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall (x y : t)\n  (_ : Logic.and (NE.eq (fst x) (fst y))\n         (forall (ge : genv) (sp b : block) (ofs : Z),\n          iff (nlive ge sp (snd x) b ofs) (nlive ge sp (snd y) b ofs))),\nLogic.and (NE.ge (fst x) (fst y))\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp (snd y) b ofs), nlive ge sp (snd x) b ofs)"
                ]
            },
            {
                "tactic_sig": "destruct x , y as [  _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct x , y .",
                "tactic_args": [
                    "c2_goal : forall (x y : t)\n  (_ : Logic.and (NE.eq (fst x) (fst y))\n         (forall (ge : genv) (sp b : block) (ofs : Z),\n          iff (nlive ge sp (snd x) b ofs) (nlive ge sp (snd y) b ofs))),\nLogic.and (NE.ge (fst x) (fst y))\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp (snd y) b ofs), nlive ge sp (snd x) b ofs)"
                ],
                "tactic_res": [
                    "c3_goal : forall\n  _ : Logic.and (NE.eq (fst (pair n n0)) (fst (pair n1 n2)))\n        (forall (ge : genv) (sp b : block) (ofs : Z),\n         iff (nlive ge sp (snd (pair n n0)) b ofs)\n           (nlive ge sp (snd (pair n1 n2)) b ofs)),\nLogic.and (NE.ge (fst (pair n n0)) (fst (pair n1 n2)))\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp (snd (pair n1 n2)) b ofs),\n   nlive ge sp (snd (pair n n0)) b ofs)",
                    "c3_n2 : nmem",
                    "c3_n1 : nenv",
                    "c3_n0 : nmem",
                    "c3_n : nenv"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall\n  _ : Logic.and (NE.eq (fst (pair n n0)) (fst (pair n1 n2)))\n        (forall (ge : genv) (sp b : block) (ofs : Z),\n         iff (nlive ge sp (snd (pair n n0)) b ofs)\n           (nlive ge sp (snd (pair n1 n2)) b ofs)),\nLogic.and (NE.ge (fst (pair n n0)) (fst (pair n1 n2)))\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp (snd (pair n1 n2)) b ofs),\n   nlive ge sp (snd (pair n n0)) b ofs)"
                ],
                "tactic_res": [
                    "c4_goal : forall\n  _ : Logic.and (NE.eq n n1)\n        (forall (ge : genv) (sp b : block) (ofs : Z),\n         iff (nlive ge sp n0 b ofs) (nlive ge sp n2 b ofs)),\nLogic.and (NE.ge n n1)\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp n2 b ofs), nlive ge sp n0 b ofs)"
                ]
            },
            {
                "tactic_sig": "intros [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ A B ] .",
                "tactic_args": [
                    "c4_goal : forall\n  _ : Logic.and (NE.eq n n1)\n        (forall (ge : genv) (sp b : block) (ofs : Z),\n         iff (nlive ge sp n0 b ofs) (nlive ge sp n2 b ofs)),\nLogic.and (NE.ge n n1)\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp n2 b ofs), nlive ge sp n0 b ofs)"
                ],
                "tactic_res": [
                    "c5_goal : Logic.and (NE.ge n n1)\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp n2 b ofs), nlive ge sp n0 b ofs)",
                    "c5_A : NE.eq n n1",
                    "c5_B : forall (ge : genv) (sp b : block) (ofs : Z),\niff (nlive ge sp n0 b ofs) (nlive ge sp n2 b ofs)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c5_goal : Logic.and (NE.ge n n1)\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp n2 b ofs), nlive ge sp n0 b ofs)"
                ],
                "tactic_res": [
                    "c6_goal : NE.ge n n1",
                    "c7_goal : forall (ge : genv) (sp b : block) (ofs : Z) (_ : nlive ge sp n2 b ofs),\nnlive ge sp n0 b ofs"
                ]
            },
            {
                "tactic_sig": "apply NE.ge_refl .",
                "tactic_sig_no_out_arg": "apply NE.ge_refl .",
                "tactic_args": [
                    "c6_goal : NE.ge n n1",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c8_goal : NE.eq n n1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : NE.eq n n1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c7_goal : forall (ge : genv) (sp b : block) (ofs : Z) (_ : nlive ge sp n2 b ofs),\nnlive ge sp n0 b ofs"
                ],
                "tactic_res": [
                    "c9_goal : nlive ge0 sp n0 b ofs",
                    "c9_ge0 : genv",
                    "c9_sp : block",
                    "c9_b : block",
                    "c9_ofs : Z",
                    "c9_H : nlive ge0 sp n2 b ofs"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c9_goal : nlive ge0 sp n0 b ofs",
                    "_global_1 : Z",
                    "c5_B : forall (ge : genv) (sp b : block) (ofs : Z),\niff (nlive ge sp n0 b ofs) (nlive ge sp n2 b ofs)"
                ],
                "tactic_res": [
                    "c10_goal : nlive ge0 sp n2 b ofs"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c10_goal : nlive ge0 sp n2 b ofs"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "ge_trans",
        "proof": [
            {
                "tactic_sig": "Lemma ge_trans : forall x y z , ge x y -> ge y z -> ge x z .",
                "tactic_sig_no_out_arg": "Lemma ge_trans : forall x y z , ge x y -> ge y z -> ge x z .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall (x y z : t) (_ : ge x y) (_ : ge y z), ge x z"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall (x y z : t) (_ : ge x y) (_ : ge y z), ge x z",
                    "_global_1 : Z",
                    "_global_ge : forall (_ : t) (_ : t), Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall (x y z : t)\n  (_ : Logic.and (NE.ge (fst x) (fst y))\n         (forall (ge : genv) (sp b : block) (ofs : Z)\n            (_ : nlive ge sp (snd y) b ofs), nlive ge sp (snd x) b ofs))\n  (_ : Logic.and (NE.ge (fst y) (fst z))\n         (forall (ge : genv) (sp b : block) (ofs : Z)\n            (_ : nlive ge sp (snd z) b ofs), nlive ge sp (snd y) b ofs)),\nLogic.and (NE.ge (fst x) (fst z))\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp (snd z) b ofs), nlive ge sp (snd x) b ofs)"
                ]
            },
            {
                "tactic_sig": "destruct x , y , z as [  _o _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct x , y , z .",
                "tactic_args": [
                    "c2_goal : forall (x y z : t)\n  (_ : Logic.and (NE.ge (fst x) (fst y))\n         (forall (ge : genv) (sp b : block) (ofs : Z)\n            (_ : nlive ge sp (snd y) b ofs), nlive ge sp (snd x) b ofs))\n  (_ : Logic.and (NE.ge (fst y) (fst z))\n         (forall (ge : genv) (sp b : block) (ofs : Z)\n            (_ : nlive ge sp (snd z) b ofs), nlive ge sp (snd y) b ofs)),\nLogic.and (NE.ge (fst x) (fst z))\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp (snd z) b ofs), nlive ge sp (snd x) b ofs)"
                ],
                "tactic_res": [
                    "c3_goal : forall\n  (_ : Logic.and (NE.ge (fst (pair n n0)) (fst (pair n1 n2)))\n         (forall (ge : genv) (sp b : block) (ofs : Z)\n            (_ : nlive ge sp (snd (pair n1 n2)) b ofs),\n          nlive ge sp (snd (pair n n0)) b ofs))\n  (_ : Logic.and (NE.ge (fst (pair n1 n2)) (fst (pair n3 n4)))\n         (forall (ge : genv) (sp b : block) (ofs : Z)\n            (_ : nlive ge sp (snd (pair n3 n4)) b ofs),\n          nlive ge sp (snd (pair n1 n2)) b ofs)),\nLogic.and (NE.ge (fst (pair n n0)) (fst (pair n3 n4)))\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp (snd (pair n3 n4)) b ofs),\n   nlive ge sp (snd (pair n n0)) b ofs)",
                    "c3_n4 : nmem",
                    "c3_n3 : nenv",
                    "c3_n2 : nmem",
                    "c3_n1 : nenv",
                    "c3_n0 : nmem",
                    "c3_n : nenv"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : forall\n  (_ : Logic.and (NE.ge (fst (pair n n0)) (fst (pair n1 n2)))\n         (forall (ge : genv) (sp b : block) (ofs : Z)\n            (_ : nlive ge sp (snd (pair n1 n2)) b ofs),\n          nlive ge sp (snd (pair n n0)) b ofs))\n  (_ : Logic.and (NE.ge (fst (pair n1 n2)) (fst (pair n3 n4)))\n         (forall (ge : genv) (sp b : block) (ofs : Z)\n            (_ : nlive ge sp (snd (pair n3 n4)) b ofs),\n          nlive ge sp (snd (pair n1 n2)) b ofs)),\nLogic.and (NE.ge (fst (pair n n0)) (fst (pair n3 n4)))\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp (snd (pair n3 n4)) b ofs),\n   nlive ge sp (snd (pair n n0)) b ofs)"
                ],
                "tactic_res": [
                    "c4_goal : forall\n  (_ : Logic.and (NE.ge n n1)\n         (forall (ge : genv) (sp b : block) (ofs : Z)\n            (_ : nlive ge sp n2 b ofs), nlive ge sp n0 b ofs))\n  (_ : Logic.and (NE.ge n1 n3)\n         (forall (ge : genv) (sp b : block) (ofs : Z)\n            (_ : nlive ge sp n4 b ofs), nlive ge sp n2 b ofs)),\nLogic.and (NE.ge n n3)\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp n4 b ofs), nlive ge sp n0 b ofs)"
                ]
            },
            {
                "tactic_sig": "intros [ _o _o ] [ _o _o ] .",
                "tactic_sig_no_out_arg": "intros [ A B ] [ C D ] .",
                "tactic_args": [
                    "c4_goal : forall\n  (_ : Logic.and (NE.ge n n1)\n         (forall (ge : genv) (sp b : block) (ofs : Z)\n            (_ : nlive ge sp n2 b ofs), nlive ge sp n0 b ofs))\n  (_ : Logic.and (NE.ge n1 n3)\n         (forall (ge : genv) (sp b : block) (ofs : Z)\n            (_ : nlive ge sp n4 b ofs), nlive ge sp n2 b ofs)),\nLogic.and (NE.ge n n3)\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp n4 b ofs), nlive ge sp n0 b ofs)"
                ],
                "tactic_res": [
                    "c5_goal : Logic.and (NE.ge n n3)\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp n4 b ofs), nlive ge sp n0 b ofs)",
                    "c5_A : NE.ge n n1",
                    "c5_B : forall (ge : genv) (sp b : block) (ofs : Z) (_ : nlive ge sp n2 b ofs),\nnlive ge sp n0 b ofs",
                    "c5_C : NE.ge n1 n3",
                    "c5_D : forall (ge : genv) (sp b : block) (ofs : Z) (_ : nlive ge sp n4 b ofs),\nnlive ge sp n2 b ofs"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c5_goal : Logic.and (NE.ge n n3)\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp n4 b ofs), nlive ge sp n0 b ofs)"
                ],
                "tactic_res": [
                    "c6_goal : NE.ge n n3",
                    "c7_goal : forall (ge : genv) (sp b : block) (ofs : Z) (_ : nlive ge sp n4 b ofs),\nnlive ge sp n0 b ofs"
                ]
            },
            {
                "tactic_sig": "eapply NE.ge_trans .",
                "tactic_sig_no_out_arg": "eapply NE.ge_trans .",
                "tactic_args": [
                    "c6_goal : NE.ge n n3",
                    "_global_1 : Z"
                ],
                "tactic_res": [
                    "c8_goal : NE.ge n ?y",
                    "c9_goal : NE.ge ?y n3"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c8_goal : NE.ge n ?y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "c9_goal : NE.ge n1 n3"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c7_goal : forall (ge : genv) (sp b : block) (ofs : Z) (_ : nlive ge sp n4 b ofs),\nnlive ge sp n0 b ofs"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "ge_bot",
        "proof": [
            {
                "tactic_sig": "Lemma ge_bot : forall x , ge x bot .",
                "tactic_sig_no_out_arg": "Lemma ge_bot : forall x , ge x bot .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x : t, ge x bot"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i .",
                "tactic_sig_no_out_arg": "unfold _i , _i .",
                "tactic_args": [
                    "c1_goal : forall x : t, ge x bot",
                    "_global_1 : Z",
                    "_global_ge : forall (_ : t) (_ : t), Prop",
                    "_global_bot : t"
                ],
                "tactic_res": [
                    "c2_goal : forall x : t,\nLogic.and (NE.ge (fst x) (fst (pair NE.bot NMemDead)))\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp (snd (pair NE.bot NMemDead)) b ofs),\n   nlive ge sp (snd x) b ofs)"
                ]
            },
            {
                "tactic_sig": "destruct x as [  _o _o ] .",
                "tactic_sig_no_out_arg": "destruct x .",
                "tactic_args": [
                    "c2_goal : forall x : t,\nLogic.and (NE.ge (fst x) (fst (pair NE.bot NMemDead)))\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp (snd (pair NE.bot NMemDead)) b ofs),\n   nlive ge sp (snd x) b ofs)"
                ],
                "tactic_res": [
                    "c3_goal : Logic.and (NE.ge (fst (pair n n0)) (fst (pair NE.bot NMemDead)))\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp (snd (pair NE.bot NMemDead)) b ofs),\n   nlive ge sp (snd (pair n n0)) b ofs)",
                    "c3_n0 : nmem",
                    "c3_n : nenv"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : Logic.and (NE.ge (fst (pair n n0)) (fst (pair NE.bot NMemDead)))\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp (snd (pair NE.bot NMemDead)) b ofs),\n   nlive ge sp (snd (pair n n0)) b ofs)"
                ],
                "tactic_res": [
                    "c4_goal : Logic.and (NE.ge n NE.bot)\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp NMemDead b ofs), nlive ge sp n0 b ofs)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c4_goal : Logic.and (NE.ge n NE.bot)\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp NMemDead b ofs), nlive ge sp n0 b ofs)"
                ],
                "tactic_res": [
                    "c5_goal : NE.ge n NE.bot",
                    "c6_goal : forall (ge : genv) (sp b : block) (ofs : Z)\n  (_ : nlive ge sp NMemDead b ofs), nlive ge sp n0 b ofs"
                ]
            },
            {
                "tactic_sig": "apply NE.ge_bot .",
                "tactic_sig_no_out_arg": "apply NE.ge_bot .",
                "tactic_args": [
                    "c5_goal : NE.ge n NE.bot",
                    "_global_1 : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall (ge : genv) (sp b : block) (ofs : Z)\n  (_ : nlive ge sp NMemDead b ofs), nlive ge sp n0 b ofs"
                ],
                "tactic_res": [
                    "c7_goal : nlive ge0 sp n0 b ofs",
                    "c7_ge0 : genv",
                    "c7_sp : block",
                    "c7_b : block",
                    "c7_ofs : Z",
                    "c7_H : nlive ge0 sp NMemDead b ofs"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "c7_goal : nlive ge0 sp n0 b ofs",
                    "c7_H : nlive ge0 sp NMemDead b ofs"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "ge_lub_left",
        "proof": [
            {
                "tactic_sig": "Lemma ge_lub_left : forall x y , ge ( lub x y ) x .",
                "tactic_sig_no_out_arg": "Lemma ge_lub_left : forall x y , ge ( lub x y ) x .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t, ge (lub x y) x"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall x y : t, ge (lub x y) x",
                    "_global_1 : Z",
                    "_global_ge : forall (_ : t) (_ : t), Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall x y : t,\nLogic.and (NE.ge (fst (lub x y)) (fst x))\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp (snd x) b ofs), nlive ge sp (snd (lub x y)) b ofs)"
                ]
            },
            {
                "tactic_sig": "destruct x , y as [  _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct x , y .",
                "tactic_args": [
                    "c2_goal : forall x y : t,\nLogic.and (NE.ge (fst (lub x y)) (fst x))\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp (snd x) b ofs), nlive ge sp (snd (lub x y)) b ofs)"
                ],
                "tactic_res": [
                    "c3_goal : Logic.and\n  (NE.ge (fst (lub (pair n n0) (pair n1 n2))) (fst (pair n n0)))\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp (snd (pair n n0)) b ofs),\n   nlive ge sp (snd (lub (pair n n0) (pair n1 n2))) b ofs)",
                    "c3_n2 : nmem",
                    "c3_n1 : nenv",
                    "c3_n0 : nmem",
                    "c3_n : nenv"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : Logic.and\n  (NE.ge (fst (lub (pair n n0) (pair n1 n2))) (fst (pair n n0)))\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp (snd (pair n n0)) b ofs),\n   nlive ge sp (snd (lub (pair n n0) (pair n1 n2))) b ofs)"
                ],
                "tactic_res": [
                    "c4_goal : Logic.and (NE.ge (NE.lub n n1) n)\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp n0 b ofs), nlive ge sp (nmem_lub n0 n2) b ofs)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c4_goal : Logic.and (NE.ge (NE.lub n n1) n)\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp n0 b ofs), nlive ge sp (nmem_lub n0 n2) b ofs)"
                ],
                "tactic_res": [
                    "c5_goal : NE.ge (NE.lub n n1) n",
                    "c6_goal : forall (ge : genv) (sp b : block) (ofs : Z) (_ : nlive ge sp n0 b ofs),\nnlive ge sp (nmem_lub n0 n2) b ofs"
                ]
            },
            {
                "tactic_sig": "apply NE.ge_lub_left .",
                "tactic_sig_no_out_arg": "apply NE.ge_lub_left .",
                "tactic_args": [
                    "c5_goal : NE.ge (NE.lub n n1) n",
                    "_global_1 : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall (ge : genv) (sp b : block) (ofs : Z) (_ : nlive ge sp n0 b ofs),\nnlive ge sp (nmem_lub n0 n2) b ofs"
                ],
                "tactic_res": [
                    "c7_goal : nlive ge0 sp (nmem_lub n0 n2) b ofs",
                    "c7_ge0 : genv",
                    "c7_sp : block",
                    "c7_b : block",
                    "c7_ofs : Z",
                    "c7_H : nlive ge0 sp n0 b ofs"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : nlive ge0 sp (nmem_lub n0 n2) b ofs",
                    "_global_1 : Z",
                    "_global_nlive_lub_l : forall (ge : genv) (sp : block) (nm1 nm2 : nmem) \n         (b : block) (i : Z) (_ : nlive ge sp nm1 b i),\n       nlive ge sp (nmem_lub nm1 nm2) b i"
                ],
                "tactic_res": [
                    "c8_goal : nlive ge0 sp n0 b ofs"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : nlive ge0 sp n0 b ofs"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "ge_lub_right",
        "proof": [
            {
                "tactic_sig": "Lemma ge_lub_right : forall x y , ge ( lub x y ) y .",
                "tactic_sig_no_out_arg": "Lemma ge_lub_right : forall x y , ge ( lub x y ) y .",
                "tactic_args": [
                    "c0_goal : "
                ],
                "tactic_res": [
                    "c1_goal : forall x y : t, ge (lub x y) y"
                ]
            },
            {
                "tactic_sig": "unfold _i .",
                "tactic_sig_no_out_arg": "unfold _i .",
                "tactic_args": [
                    "c1_goal : forall x y : t, ge (lub x y) y",
                    "_global_1 : Z",
                    "_global_ge : forall (_ : t) (_ : t), Prop"
                ],
                "tactic_res": [
                    "c2_goal : forall x y : t,\nLogic.and (NE.ge (fst (lub x y)) (fst y))\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp (snd y) b ofs), nlive ge sp (snd (lub x y)) b ofs)"
                ]
            },
            {
                "tactic_sig": "destruct x , y as [  _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct x , y .",
                "tactic_args": [
                    "c2_goal : forall x y : t,\nLogic.and (NE.ge (fst (lub x y)) (fst y))\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp (snd y) b ofs), nlive ge sp (snd (lub x y)) b ofs)"
                ],
                "tactic_res": [
                    "c3_goal : Logic.and\n  (NE.ge (fst (lub (pair n n0) (pair n1 n2))) (fst (pair n1 n2)))\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp (snd (pair n1 n2)) b ofs),\n   nlive ge sp (snd (lub (pair n n0) (pair n1 n2))) b ofs)",
                    "c3_n2 : nmem",
                    "c3_n1 : nenv",
                    "c3_n0 : nmem",
                    "c3_n : nenv"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "c3_goal : Logic.and\n  (NE.ge (fst (lub (pair n n0) (pair n1 n2))) (fst (pair n1 n2)))\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp (snd (pair n1 n2)) b ofs),\n   nlive ge sp (snd (lub (pair n n0) (pair n1 n2))) b ofs)"
                ],
                "tactic_res": [
                    "c4_goal : Logic.and (NE.ge (NE.lub n n1) n1)\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp n2 b ofs), nlive ge sp (nmem_lub n0 n2) b ofs)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "c4_goal : Logic.and (NE.ge (NE.lub n n1) n1)\n  (forall (ge : genv) (sp b : block) (ofs : Z)\n     (_ : nlive ge sp n2 b ofs), nlive ge sp (nmem_lub n0 n2) b ofs)"
                ],
                "tactic_res": [
                    "c5_goal : NE.ge (NE.lub n n1) n1",
                    "c6_goal : forall (ge : genv) (sp b : block) (ofs : Z) (_ : nlive ge sp n2 b ofs),\nnlive ge sp (nmem_lub n0 n2) b ofs"
                ]
            },
            {
                "tactic_sig": "apply NE.ge_lub_right .",
                "tactic_sig_no_out_arg": "apply NE.ge_lub_right .",
                "tactic_args": [
                    "c5_goal : NE.ge (NE.lub n n1) n1",
                    "_global_1 : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "c6_goal : forall (ge : genv) (sp b : block) (ofs : Z) (_ : nlive ge sp n2 b ofs),\nnlive ge sp (nmem_lub n0 n2) b ofs"
                ],
                "tactic_res": [
                    "c7_goal : nlive ge0 sp (nmem_lub n0 n2) b ofs",
                    "c7_ge0 : genv",
                    "c7_sp : block",
                    "c7_b : block",
                    "c7_ofs : Z",
                    "c7_H : nlive ge0 sp n2 b ofs"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "c7_goal : nlive ge0 sp (nmem_lub n0 n2) b ofs",
                    "_global_1 : Z",
                    "_global_nlive_lub_r : forall (ge : genv) (sp : block) (nm1 nm2 : nmem) \n         (b : block) (i : Z) (_ : nlive ge sp nm2 b i),\n       nlive ge sp (nmem_lub nm1 nm2) b i"
                ],
                "tactic_res": [
                    "c8_goal : nlive ge0 sp n2 b ofs"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "c8_goal : nlive ge0 sp n2 b ofs"
                ],
                "tactic_res": []
            }
        ]
    }
]