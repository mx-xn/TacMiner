{
  "theorem_file": {
    "vagree_same": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "vagree_lessdef": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "lessdef_vagree": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "lessdef_vagree_list": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "vagree_lessdef_list": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "nge_refl": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "nge_trans": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "nge_agree": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "nge_lub_l": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "nge_lub_r": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "iagree_refl": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "eq_same_bits": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "iagree_and_eq": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "iagree_mone": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "iagree_zero": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "iagree_and": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "iagree_not": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "iagree_or": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "iagree_bitwise_binop": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "iagree_shl": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "iagree_shru": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "iagree_shr_1": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "iagree_shr": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "iagree_rol": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "iagree_ror": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "eqmod_iagree": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "iagree_eqmod": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "complete_mask_idem": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "andimm_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "orimm_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "bitwise_idem": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "vagree_bitwise_binop": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "and_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "or_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "xor_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "notint_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "shlimm_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "shruimm_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "rol_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "ror_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "rolm_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "add_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "sub_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "modarith_idem": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "mul_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "neg_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "zero_ext_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "sign_ext_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "store_argument_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "store_argument_load_result": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "maskzero_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "normalize_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "select_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "default_needs_of_condition_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "default_needs_of_operation_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "andimm_redundant_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "orimm_redundant_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "rolm_redundant_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "zero_ext_redundant_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "sign_ext_redundant_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "beq_correct": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "ge_refl": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "ge_trans": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "ge_bot": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "ge_lub_left": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "ge_lub_right": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "nreg_agree": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "eagree_ge": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "eagree_bot": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "eagree_same": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "eagree_update_1": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "eagree_update": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "eagree_update_dead": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "nlive_all": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "nlive_add": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "incl_nmem_add": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "nlive_remove": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "nlive_contains": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "nlive_dead_stack": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "nlive_lub_l": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "nlive_lub_r": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "nmem_beq_sound": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "eq_refl": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "eq_sym": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "eq_trans": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "beq_correct2": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "ge_refl2": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "ge_trans2": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "ge_bot2": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "ge_lub_left2": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v",
    "ge_lub_right2": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v"
  },
  "custom_tactics": {
    "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/CompCert/backend/NeedDomain_comp.v": {
      "vagree_same": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": [
          "custom1",
          "custom4"
        ]
      },
      "vagree_lessdef": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "lessdef_vagree": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "lessdef_vagree_list": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "vagree_lessdef_list": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "nge_refl": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "nge_trans": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "nge_agree": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "nge_lub_l": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "nge_lub_r": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "iagree_refl": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "eq_same_bits": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "iagree_and_eq": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "iagree_mone": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "iagree_zero": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "iagree_and": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "iagree_not": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ]
        },
        "used_tactics": []
      },
      "iagree_or": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ]
        },
        "used_tactics": [
          "custom37",
          "custom40",
          "custom21"
        ]
      },
      "iagree_bitwise_binop": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ]
        },
        "used_tactics": [
          "custom33"
        ]
      },
      "iagree_shl": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ]
        },
        "used_tactics": []
      },
      "iagree_shru": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ]
        },
        "used_tactics": []
      },
      "iagree_shr_1": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ]
        },
        "used_tactics": []
      },
      "iagree_shr": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ]
        },
        "used_tactics": []
      },
      "iagree_rol": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ]
        },
        "used_tactics": []
      },
      "iagree_ror": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ]
        },
        "used_tactics": []
      },
      "eqmod_iagree": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ]
        },
        "used_tactics": []
      },
      "iagree_eqmod": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ]
        },
        "used_tactics": []
      },
      "complete_mask_idem": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ]
        },
        "used_tactics": []
      },
      "andimm_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ]
        },
        "used_tactics": [
          "InvAgree"
        ]
      },
      "orimm_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ]
        },
        "used_tactics": [
          "InvAgree"
        ]
      },
      "bitwise_idem": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ]
        },
        "used_tactics": []
      },
      "vagree_bitwise_binop": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ]
        },
        "used_tactics": [
          "custom60",
          "InvAgree"
        ]
      },
      "and_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ]
        },
        "used_tactics": []
      },
      "or_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ]
        },
        "used_tactics": []
      },
      "xor_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ]
        },
        "used_tactics": []
      },
      "notint_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ]
        },
        "used_tactics": []
      },
      "shlimm_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ]
        },
        "used_tactics": [
          "InvAgree"
        ]
      },
      "shruimm_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ]
        },
        "used_tactics": [
          "InvAgree"
        ]
      },
      "rol_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ]
        },
        "used_tactics": [
          "InvAgree"
        ]
      },
      "ror_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ]
        },
        "used_tactics": [
          "InvAgree"
        ]
      },
      "rolm_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ]
        },
        "used_tactics": []
      },
      "add_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ]
        },
        "used_tactics": [
          "InvAgree"
        ]
      },
      "sub_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ]
        },
        "used_tactics": [
          "custom21",
          "custom60",
          "custom65"
        ]
      },
      "modarith_idem": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": [
          "custom61",
          "custom4"
        ]
      },
      "mul_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": [
          "InvAgree"
        ]
      },
      "neg_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": [
          "InvAgree"
        ]
      },
      "zero_ext_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": [
          "InvAgree"
        ]
      },
      "sign_ext_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": [
          "InvAgree"
        ]
      },
      "store_argument_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": [
          "InvAgree"
        ]
      },
      "store_argument_load_result": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": [
          "InvAgree"
        ]
      },
      "maskzero_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": [
          "InvAgree"
        ]
      },
      "normalize_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "select_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "default_needs_of_condition_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "default_needs_of_operation_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "andimm_redundant_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": [
          "InvAgree"
        ]
      },
      "orimm_redundant_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": [
          "InvAgree"
        ]
      },
      "rolm_redundant_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "zero_ext_redundant_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": [
          "InvAgree"
        ]
      },
      "sign_ext_redundant_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": [
          "InvAgree"
        ]
      },
      "beq_correct": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "ge_refl": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "ge_trans": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "ge_bot": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "ge_lub_left": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "ge_lub_right": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "nreg_agree": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "eagree_ge": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "eagree_bot": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "eagree_same": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "eagree_update_1": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "eagree_update": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "eagree_update_dead": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "nlive_all": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "nlive_add": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "incl_nmem_add": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "nlive_remove": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "nlive_contains": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "nlive_dead_stack": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "nlive_lub_l": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "nlive_lub_r": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "nmem_beq_sound": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "eq_refl": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "eq_sym": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "eq_trans": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "beq_correct2": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "ge_refl2": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "ge_trans2": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "ge_bot2": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "ge_lub_left2": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      },
      "ge_lub_right2": {
        "available_tactics": [
          {
            "name": "custom1",
            "definition": "Ltac custom1 := red; auto.\n"
          },
          {
            "name": "custom4",
            "definition": "Ltac custom4 := simpl; auto.\n"
          },
          {
            "name": "custom14",
            "definition": "Ltac custom14 := autorewrite with ints; auto.\n"
          },
          {
            "name": "custom33",
            "definition": "Ltac custom33 := intros; red; intros.\n"
          },
          {
            "name": "custom21",
            "definition": "Ltac custom21 H0 := apply H0; auto.\n"
          },
          {
            "name": "custom37",
            "definition": "Ltac custom37 H0 := intros; apply H0.\n"
          },
          {
            "name": "custom40",
            "definition": "Ltac custom40 H0 H1 := rewrite ! H0; apply H1.\n"
          },
          {
            "name": "InvAgree",
            "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
          },
          {
            "name": "custom60",
            "definition": "Ltac custom60 H0 := unfold H0; intros.\n"
          },
          {
            "name": "custom65",
            "definition": "Ltac custom65 H0 := InvAgree; apply H0.\n"
          },
          {
            "name": "custom61",
            "definition": "Ltac custom61 H0 := f_equal; apply H0.\n"
          }
        ],
        "examples": {
          "custom1": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom1 .",
              "tactic_args": [
                "c8_goal : iagree i i m"
              ],
              "tactic_res": []
            }
          ],
          "custom4": [
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : vagree v v Nothing"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : vagree v v (I m)"
              ],
              "tactic_res": [
                "c6_goal : match v with\n| Vint p => match v with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ]
            },
            {
              "lemma_name": "vagree_same",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : vagree v v All"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c3_goal : eq (modarith (modarith Nothing)) (modarith Nothing)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c4_goal : eq (modarith (modarith (I m))) (modarith (I m))"
              ],
              "tactic_res": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ]
            },
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom4 .",
              "tactic_args": [
                "c5_goal : eq (modarith (modarith All)) (modarith All)"
              ],
              "tactic_res": []
            }
          ],
          "custom14": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom14 .",
              "tactic_args": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)"
              ],
              "tactic_res": [
                "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
              ]
            }
          ],
          "custom33": [
            {
              "lemma_name": "iagree_not",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (x y m : Int.int) (_ : iagree x y m),\niagree (Int.not x) (Int.not y) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (Int.not x) i) (Int.testbit (Int.not y) i)",
                "c2_H1 : eq (Int.testbit m i) true",
                "c2_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H : iagree x y m",
                "c2_m : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "iagree_bitwise_binop",
              "tactic_sig": "custom33 .",
              "tactic_args": [
                "c1_goal : forall (sem : forall (_ : bool) (_ : bool), bool)\n  (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\n       eq (Int.testbit (f x y) i)\n         (sem (Int.testbit x i) (Int.testbit y i)))\n  (x1 x2 y1 y2 m : Int.int) (_ : iagree x1 y1 m) (_ : iagree x2 y2 m),\niagree (f x1 x2) (f y1 y2) m"
              ],
              "tactic_res": [
                "c2_goal : eq (Int.testbit (f x1 x2) i) (Int.testbit (f y1 y2) i)",
                "c2_H3 : eq (Int.testbit m i) true",
                "c2_H2 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                "c2_i : Z",
                "c2_H1 : iagree x2 y2 m",
                "c2_H0 : iagree x1 y1 m",
                "c2_m : Int.int",
                "c2_y2 : Int.int",
                "c2_y1 : Int.int",
                "c2_x2 : Int.int",
                "c2_x1 : Int.int",
                "c2_H : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit (f x y) i) (sem (Int.testbit x i) (Int.testbit y i))",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int",
                "c2_sem : forall (_ : bool) (_ : bool), bool"
              ]
            }
          ],
          "custom21": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom21 iagree_not .",
              "tactic_args": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c12_goal : eqmod (two_p (Int.size m)) (Int.unsigned i1) (Int.unsigned i2)"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom21 iagree_eqmod .",
              "tactic_args": [
                "c13_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
              ],
              "tactic_res": []
            }
          ],
          "custom37": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom37 iagree_not' .",
              "tactic_args": [
                "c1_goal : forall (x y n m : Int.int) (_ : iagree x y (Int.and m (Int.not n))),\niagree (Int.or x n) (Int.or y n) m"
              ],
              "tactic_res": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m",
                "c2_H : iagree x y (Int.and m (Int.not n))",
                "c2_m : Int.int",
                "c2_n : Int.int",
                "c2_y : Int.int",
                "c2_x : Int.int"
              ]
            },
            {
              "lemma_name": "nreg_agree",
              "tactic_sig": "custom37 H .",
              "tactic_args": [
                "c1_goal : forall (rs1 rs2 : regset) (ne : nenv) (r : positive)\n  (_ : eagree rs1 rs2 ne),\nvagree (Regmap.get val r rs1) (Regmap.get val r rs2) (nreg ne r)"
              ],
              "tactic_res": []
            }
          ],
          "custom40": [
            {
              "lemma_name": "iagree_or",
              "tactic_sig": "custom40 Int.not_or_and_not iagree_and .",
              "tactic_args": [
                "c2_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
              ],
              "tactic_res": [
                "c3_goal : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n))"
              ]
            }
          ],
          "InvAgree": [
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c12_goal : iagree (Int.and i n) (Int.and i0 n) m",
                "c12_H : iagree i i0 (Int.and m n)",
                "c12_i0 : Int.int",
                "c12_i : Int.int"
              ]
            },
            {
              "lemma_name": "andimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c14_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                "c14_H : iagree i i0 n",
                "c14_i0 : Int.int",
                "c14_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.or n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.or i n) (Int.or i0 n) m",
                "c11_H : iagree i i0 (Int.and m (Int.not n))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
              ],
              "tactic_res": [
                "c13_goal : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n))",
                "c13_H : iagree i i0 (Int.not n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": []
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                "c13_H : iagree i i0 (Int.shru m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shlimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                "c15_H : iagree i i0 (Int.shru Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                "c13_H : iagree i i0 (Int.shl m n)",
                "c13_i0 : Int.int",
                "c13_i : Int.int"
              ]
            },
            {
              "lemma_name": "shruimm_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                "c15_H : iagree i i0 (Int.shl Int.mone n)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "rol_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                "c10_H : iagree i i0 (Int.ror m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "ror_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                "c10_H : iagree i i0 (Int.rol m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "add_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "mul_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                "c10_H0 : iagree i i0 (complete_mask m)",
                "c10_H : iagree i1 i2 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int",
                "c10_i2 : Int.int",
                "c10_i1 : Int.int"
              ]
            },
            {
              "lemma_name": "neg_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                "c10_H : iagree i i0 (complete_mask m)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                "c11_H : iagree i i0 (Int.zero_ext n m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c11_i0 : Int.int",
                "c11_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
              ],
              "tactic_res": [
                "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                "c43_i0 : Int.int",
                "c43_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
              ],
              "tactic_res": [
                "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                "c26_H : iagree i i0 (Int.repr 255)",
                "c26_i0 : Int.int",
                "c26_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
              ],
              "tactic_res": [
                "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                "c33_H : iagree i i0 (Int.repr 255)",
                "c33_i0 : Int.int",
                "c33_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
              ],
              "tactic_res": [
                "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                "c40_H : iagree i i0 (Int.repr 255)",
                "c40_i0 : Int.int",
                "c40_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
              ],
              "tactic_res": [
                "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                "c47_H : iagree i i0 (Int.repr 65535)",
                "c47_i0 : Int.int",
                "c47_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
              ],
              "tactic_res": [
                "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                "c54_H : iagree i i0 (Int.repr 65535)",
                "c54_i0 : Int.int",
                "c54_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
              ],
              "tactic_res": [
                "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                "c15_H : iagree i i0 (Int.repr 255)",
                "c15_i0 : Int.int",
                "c15_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
              ],
              "tactic_res": [
                "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                "c17_H : iagree i i0 (Int.repr 255)",
                "c17_i0 : Int.int",
                "c17_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
              ],
              "tactic_res": [
                "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                "c19_H : iagree i i0 (Int.repr 255)",
                "c19_i0 : Int.int",
                "c19_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
              ],
              "tactic_res": [
                "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                "c21_H : iagree i i0 (Int.repr 65535)",
                "c21_i0 : Int.int",
                "c21_i : Int.int"
              ]
            },
            {
              "lemma_name": "store_argument_load_result",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
              ],
              "tactic_res": [
                "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                "c23_H : iagree i i0 (Int.repr 65535)",
                "c23_i0 : Int.int",
                "c23_i : Int.int"
              ]
            },
            {
              "lemma_name": "maskzero_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
              ],
              "tactic_res": [
                "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                "c5_H : True",
                "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                "c6_H : iagree i i0 n",
                "c6_i0 : Int.int",
                "c6_i : Int.int",
                "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                "c7_H : True",
                "c7_i : Int64.int",
                "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                "c8_H : True",
                "c8_f : float",
                "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                "c9_H : True",
                "c9_f : float32",
                "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                "c10_H : True",
                "c10_i : Ptrofs.int",
                "c10_b0 : block"
              ]
            },
            {
              "lemma_name": "andimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c10_goal : iagree (Int.and i n) i0 m",
                "c10_H0 : iagree i i0 (Int.and m n)",
                "c10_i0 : Int.int",
                "c10_i : Int.int"
              ]
            },
            {
              "lemma_name": "orimm_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c9_goal : iagree (Int.or i n) i0 m",
                "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                "c9_i0 : Int.int",
                "c9_i : Int.int"
              ]
            },
            {
              "lemma_name": "zero_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            },
            {
              "lemma_name": "sign_ext_redundant_sound",
              "tactic_sig": "InvAgree .",
              "tactic_args": [
                "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                "c8_i0 : Int.int",
                "c8_i : Int.int"
              ]
            }
          ],
          "custom60": [
            {
              "lemma_name": "vagree_bitwise_binop",
              "tactic_sig": "custom60 bitwise .",
              "tactic_args": [
                "c1_goal : forall (f : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (_ : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n         (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m)\n  (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (bitwise x))\n  (_ : vagree v2 w2 (bitwise x)),\nvagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x"
              ],
              "tactic_res": [
                "c2_goal : vagree\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 =>\n      match w2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x",
                "c2_H1 : vagree v2 w2 x",
                "c2_H0 : vagree v1 w1 x",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val",
                "c2_H : forall (p1 p2 q1 q2 m : Int.int) (_ : iagree p1 q1 m)\n  (_ : iagree p2 q2 m), iagree (f p1 p2) (f q1 q2) m",
                "c2_f : forall (_ : Int.int) (_ : Int.int), Int.int"
              ]
            },
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom60 modarith .",
              "tactic_args": [
                "c1_goal : forall (v1 w1 v2 w2 : val) (x : nval) (_ : vagree v1 w1 (modarith x))\n  (_ : vagree v2 w2 (modarith x)) (_ : eq Archi.ptr64 true),\nvagree (Val.sub v1 v2) (Val.sub w1 w2) x"
              ],
              "tactic_res": [
                "c2_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                "c2_H1 : eq Archi.ptr64 true",
                "c2_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                "c2_x : nval",
                "c2_w2 : val",
                "c2_v2 : val",
                "c2_w1 : val",
                "c2_v1 : val"
              ]
            }
          ],
          "custom65": [
            {
              "lemma_name": "sub_sound",
              "tactic_sig": "custom65 eqmod_iagree .",
              "tactic_args": [
                "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
              ],
              "tactic_res": [
                "c11_goal : eqmod (two_p (Int.size m)) (Z.sub (Int.unsigned i1) (Int.unsigned i))\n  (Z.sub (Int.unsigned i2) (Int.unsigned i0))",
                "c11_H0 : iagree i i0 (complete_mask m)",
                "c11_H : iagree i1 i2 (complete_mask m)",
                "c11_i0 : Int.int",
                "c11_i : Int.int",
                "c11_i2 : Int.int",
                "c11_i1 : Int.int"
              ]
            }
          ],
          "custom61": [
            {
              "lemma_name": "modarith_idem",
              "tactic_sig": "custom61 complete_mask_idem .",
              "tactic_args": [
                "c6_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
              ],
              "tactic_res": []
            }
          ]
        },
        "used_tactics": []
      }
    }
  }
}