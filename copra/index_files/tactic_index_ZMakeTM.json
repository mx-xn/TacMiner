{
    "theorem_file": {
      "spec_of_Z": "ZMake.v",
      "spec_0": "ZMake.v",
      "spec_1": "ZMake.v",
      "spec_2": "ZMake.v",
      "spec_m1": "ZMake.v",
      "spec_compare": "ZMake.v",
      "spec_eqb": "ZMake.v",
      "spec_ltb": "ZMake.v",
      "spec_leb": "ZMake.v",
      "spec_min": "ZMake.v",
      "spec_max": "ZMake.v",
      "spec_abs": "ZMake.v",
      "spec_opp": "ZMake.v",
      "spec_succ": "ZMake.v",
      "spec_add": "ZMake.v",
      "spec_pred": "ZMake.v",
      "spec_sub": "ZMake.v",
      "spec_mul": "ZMake.v",
      "spec_square": "ZMake.v",
      "spec_pow_pos": "ZMake.v",
      "spec_pow_N": "ZMake.v",
      "spec_pow": "ZMake.v",
      "spec_log2": "ZMake.v",
      "spec_sqrt": "ZMake.v",
      "spec_div_eucl": "ZMake.v",
      "spec_modulo": "ZMake.v",
      "spec_quot": "ZMake.v",
      "spec_rem": "ZMake.v",
      "spec_gcd": "ZMake.v",
      "spec_sgn": "ZMake.v",
      "spec_even": "ZMake.v",
      "spec_odd": "ZMake.v",
      "Zlnot_alt1": "ZMake.v",
      "Zlnot_alt2": "ZMake.v",
      "Zlnot_alt3": "ZMake.v",
      "spec_norm_pos": "ZMake.v",
      "spec_norm_pos_pos": "ZMake.v",
      "spec_testbit": "ZMake.v",
      "spec_shiftl": "ZMake.v",
      "spec_shiftr": "ZMake.v",
      "spec_land": "ZMake.v",
      "spec_lor": "ZMake.v",
      "spec_ldiff": "ZMake.v",
      "spec_lxor": "ZMake.v",
      "spec_div2": "ZMake.v",
      "N_to_Z_pos": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "strong_spec_of_Q": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_of_Q": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_eq_bool": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "strong_spec_check_int": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_norm": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "strong_spec_norm": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_red": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "strong_spec_red": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_add_norm": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "strong_spec_opp": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_sub_norm": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_norm_denum": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_irred": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_irred_zero": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "strong_spec_irred": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_mul_norm_Qz_Qq": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_mul_norm": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_inv": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_inv_norm": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_div": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_div_norm": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_power_pos": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_power": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_power_norm": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "strong_spec_of_Qc": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_of_Qc": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_oppc": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_oppc_bis": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_comparec": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_addc": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_add_normc": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_add_normc_bis": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_subc": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_sub_normc": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_sub_normc_bis": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_mulc": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_mul_normc": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_mul_normc_bis": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_invc": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_inv_normc": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_inv_normc_bis": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_divc": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_div_normc": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_div_normc_bis": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_squarec": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v",
      "spec_power_posc": "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v"
    },
    "custom_tactics": {
      "ZMake.v": {
        "spec_of_Z": {
          "available_tactics": [],
          "examples": {},
          "used_tactics": []
        },
        "spec_0": {
          "available_tactics": [],
          "examples": {},
          "used_tactics": []
        },
        "spec_1": {
          "available_tactics": [],
          "examples": {},
          "used_tactics": []
        },
        "spec_2": {
          "available_tactics": [],
          "examples": {},
          "used_tactics": []
        },
        "spec_m1": {
          "available_tactics": [],
          "examples": {},
          "used_tactics": []
        },
        "spec_compare": {
          "available_tactics": [],
          "examples": {},
          "used_tactics": []
        },
        "spec_eqb": {
          "available_tactics": [],
          "examples": {},
          "used_tactics": []
        },
        "spec_ltb": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": [
            "custom41",
            "custom31"
          ]
        },
        "spec_leb": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              },
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": [
            "custom31"
          ]
        },
        "spec_min": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "spec_max": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "spec_abs": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "spec_opp": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": [
            "custom60",
            "custom26"
          ]
        },
        "spec_succ": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_add": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_pred": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_sub": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_mul": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_square": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_pow_pos": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_pow_N": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_pow": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_log2": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_sqrt": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_div_eucl": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_modulo": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_quot": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_rem": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_gcd": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_sgn": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_even": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_odd": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "Zlnot_alt1": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "Zlnot_alt2": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "Zlnot_alt3": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_norm_pos": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            },
            {
              "name": "custom48",
              "definition": "Ltac custom48 H0 H1 :=  rewrite H0, H1; [case Z.eqb_spec | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ],
            "custom48": [
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom48 NN.spec_eqb NN.spec_0 .",
                "tactic_args": [
                  "c5_goal : Logic.eq (to_Z (if NN.eqb x NN.zero then Pos x else Neg x))\n  (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))",
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ]
              },
              {
                "lemma_name": "spec_norm_pos_pos",
                "tactic_sig": "custom48 NN.spec_eqb NN.spec_0 .",
                "tactic_args": [
                  "c5_goal : forall _ : Logic.eq (if NN.eqb x NN.zero then Pos x else Neg x) (Neg y),\nZ.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": [
                  "c6_goal : forall (_ : Logic.eq (NN.to_Z x) 0) (_ : Logic.eq (Pos x) (Neg y)),\nZ.lt 0 (NN.to_Z y)",
                  "c7_goal : forall (_ : not (Logic.eq (NN.to_Z x) 0))\n  (_ : Logic.eq (Neg x) (Neg y)), Z.lt 0 (NN.to_Z y)"
                ]
              }
            ]
          },
          "used_tactics": [
            "custom48",
            "custom26"
          ]
        },
        "spec_norm_pos_pos": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            },
            {
              "name": "custom48",
              "definition": "Ltac custom48 H0 H1 :=  rewrite H0, H1; [case Z.eqb_spec | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 :=  generalize ( NN.spec_pos H0 ); [auto with zarith | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ],
            "custom48": [
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom48 NN.spec_eqb NN.spec_0 .",
                "tactic_args": [
                  "c5_goal : Logic.eq (to_Z (if NN.eqb x NN.zero then Pos x else Neg x))\n  (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))",
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ]
              },
              {
                "lemma_name": "spec_norm_pos_pos",
                "tactic_sig": "custom48 NN.spec_eqb NN.spec_0 .",
                "tactic_args": [
                  "c5_goal : forall _ : Logic.eq (if NN.eqb x NN.zero then Pos x else Neg x) (Neg y),\nZ.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": [
                  "c6_goal : forall (_ : Logic.eq (NN.to_Z x) 0) (_ : Logic.eq (Pos x) (Neg y)),\nZ.lt 0 (NN.to_Z y)",
                  "c7_goal : forall (_ : not (Logic.eq (NN.to_Z x) 0))\n  (_ : Logic.eq (Neg x) (Neg y)), Z.lt 0 (NN.to_Z y)"
                ]
              }
            ],
            "custom51": [
              {
                "lemma_name": "spec_norm_pos_pos",
                "tactic_sig": "custom51 _i .",
                "tactic_args": [
                  "c8_goal : Z.lt 0 (NN.to_Z y)",
                  "c3_y : NN.t"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": [
            "custom48",
            "custom51"
          ]
        },
        "spec_testbit": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            },
            {
              "name": "custom48",
              "definition": "Ltac custom48 H0 H1 :=  rewrite H0, H1; [case Z.eqb_spec | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 :=  generalize ( NN.spec_pos H0 ); [auto with zarith | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ],
            "custom48": [
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom48 NN.spec_eqb NN.spec_0 .",
                "tactic_args": [
                  "c5_goal : Logic.eq (to_Z (if NN.eqb x NN.zero then Pos x else Neg x))\n  (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))",
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ]
              },
              {
                "lemma_name": "spec_norm_pos_pos",
                "tactic_sig": "custom48 NN.spec_eqb NN.spec_0 .",
                "tactic_args": [
                  "c5_goal : forall _ : Logic.eq (if NN.eqb x NN.zero then Pos x else Neg x) (Neg y),\nZ.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": [
                  "c6_goal : forall (_ : Logic.eq (NN.to_Z x) 0) (_ : Logic.eq (Pos x) (Neg y)),\nZ.lt 0 (NN.to_Z y)",
                  "c7_goal : forall (_ : not (Logic.eq (NN.to_Z x) 0))\n  (_ : Logic.eq (Neg x) (Neg y)), Z.lt 0 (NN.to_Z y)"
                ]
              }
            ],
            "custom51": [
              {
                "lemma_name": "spec_norm_pos_pos",
                "tactic_sig": "custom51 _i .",
                "tactic_args": [
                  "c8_goal : Z.lt 0 (NN.to_Z y)",
                  "c3_y : NN.t"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "spec_shiftl": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            },
            {
              "name": "custom48",
              "definition": "Ltac custom48 H0 H1 :=  rewrite H0, H1; [case Z.eqb_spec | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 :=  generalize ( NN.spec_pos H0 ); [auto with zarith | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ],
            "custom48": [
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom48 NN.spec_eqb NN.spec_0 .",
                "tactic_args": [
                  "c5_goal : Logic.eq (to_Z (if NN.eqb x NN.zero then Pos x else Neg x))\n  (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))",
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ]
              },
              {
                "lemma_name": "spec_norm_pos_pos",
                "tactic_sig": "custom48 NN.spec_eqb NN.spec_0 .",
                "tactic_args": [
                  "c5_goal : forall _ : Logic.eq (if NN.eqb x NN.zero then Pos x else Neg x) (Neg y),\nZ.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": [
                  "c6_goal : forall (_ : Logic.eq (NN.to_Z x) 0) (_ : Logic.eq (Pos x) (Neg y)),\nZ.lt 0 (NN.to_Z y)",
                  "c7_goal : forall (_ : not (Logic.eq (NN.to_Z x) 0))\n  (_ : Logic.eq (Neg x) (Neg y)), Z.lt 0 (NN.to_Z y)"
                ]
              }
            ],
            "custom51": [
              {
                "lemma_name": "spec_norm_pos_pos",
                "tactic_sig": "custom51 _i .",
                "tactic_args": [
                  "c8_goal : Z.lt 0 (NN.to_Z y)",
                  "c3_y : NN.t"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "spec_shiftr": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            },
            {
              "name": "custom48",
              "definition": "Ltac custom48 H0 H1 :=  rewrite H0, H1; [case Z.eqb_spec | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 :=  generalize ( NN.spec_pos H0 ); [auto with zarith | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ],
            "custom48": [
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom48 NN.spec_eqb NN.spec_0 .",
                "tactic_args": [
                  "c5_goal : Logic.eq (to_Z (if NN.eqb x NN.zero then Pos x else Neg x))\n  (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))",
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ]
              },
              {
                "lemma_name": "spec_norm_pos_pos",
                "tactic_sig": "custom48 NN.spec_eqb NN.spec_0 .",
                "tactic_args": [
                  "c5_goal : forall _ : Logic.eq (if NN.eqb x NN.zero then Pos x else Neg x) (Neg y),\nZ.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": [
                  "c6_goal : forall (_ : Logic.eq (NN.to_Z x) 0) (_ : Logic.eq (Pos x) (Neg y)),\nZ.lt 0 (NN.to_Z y)",
                  "c7_goal : forall (_ : not (Logic.eq (NN.to_Z x) 0))\n  (_ : Logic.eq (Neg x) (Neg y)), Z.lt 0 (NN.to_Z y)"
                ]
              }
            ],
            "custom51": [
              {
                "lemma_name": "spec_norm_pos_pos",
                "tactic_sig": "custom51 _i .",
                "tactic_args": [
                  "c8_goal : Z.lt 0 (NN.to_Z y)",
                  "c3_y : NN.t"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "spec_land": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            },
            {
              "name": "custom48",
              "definition": "Ltac custom48 H0 H1 :=  rewrite H0, H1; [case Z.eqb_spec | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 :=  generalize ( NN.spec_pos H0 ); [auto with zarith | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ],
            "custom48": [
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom48 NN.spec_eqb NN.spec_0 .",
                "tactic_args": [
                  "c5_goal : Logic.eq (to_Z (if NN.eqb x NN.zero then Pos x else Neg x))\n  (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))",
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ]
              },
              {
                "lemma_name": "spec_norm_pos_pos",
                "tactic_sig": "custom48 NN.spec_eqb NN.spec_0 .",
                "tactic_args": [
                  "c5_goal : forall _ : Logic.eq (if NN.eqb x NN.zero then Pos x else Neg x) (Neg y),\nZ.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": [
                  "c6_goal : forall (_ : Logic.eq (NN.to_Z x) 0) (_ : Logic.eq (Pos x) (Neg y)),\nZ.lt 0 (NN.to_Z y)",
                  "c7_goal : forall (_ : not (Logic.eq (NN.to_Z x) 0))\n  (_ : Logic.eq (Neg x) (Neg y)), Z.lt 0 (NN.to_Z y)"
                ]
              }
            ],
            "custom51": [
              {
                "lemma_name": "spec_norm_pos_pos",
                "tactic_sig": "custom51 _i .",
                "tactic_args": [
                  "c8_goal : Z.lt 0 (NN.to_Z y)",
                  "c3_y : NN.t"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "spec_lor": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            },
            {
              "name": "custom48",
              "definition": "Ltac custom48 H0 H1 :=  rewrite H0, H1; [case Z.eqb_spec | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 :=  generalize ( NN.spec_pos H0 ); [auto with zarith | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ],
            "custom48": [
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom48 NN.spec_eqb NN.spec_0 .",
                "tactic_args": [
                  "c5_goal : Logic.eq (to_Z (if NN.eqb x NN.zero then Pos x else Neg x))\n  (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))",
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ]
              },
              {
                "lemma_name": "spec_norm_pos_pos",
                "tactic_sig": "custom48 NN.spec_eqb NN.spec_0 .",
                "tactic_args": [
                  "c5_goal : forall _ : Logic.eq (if NN.eqb x NN.zero then Pos x else Neg x) (Neg y),\nZ.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": [
                  "c6_goal : forall (_ : Logic.eq (NN.to_Z x) 0) (_ : Logic.eq (Pos x) (Neg y)),\nZ.lt 0 (NN.to_Z y)",
                  "c7_goal : forall (_ : not (Logic.eq (NN.to_Z x) 0))\n  (_ : Logic.eq (Neg x) (Neg y)), Z.lt 0 (NN.to_Z y)"
                ]
              }
            ],
            "custom51": [
              {
                "lemma_name": "spec_norm_pos_pos",
                "tactic_sig": "custom51 _i .",
                "tactic_args": [
                  "c8_goal : Z.lt 0 (NN.to_Z y)",
                  "c3_y : NN.t"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "spec_ldiff": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            },
            {
              "name": "custom48",
              "definition": "Ltac custom48 H0 H1 :=  rewrite H0, H1; [case Z.eqb_spec | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 :=  generalize ( NN.spec_pos H0 ); [auto with zarith | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ],
            "custom48": [
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom48 NN.spec_eqb NN.spec_0 .",
                "tactic_args": [
                  "c5_goal : Logic.eq (to_Z (if NN.eqb x NN.zero then Pos x else Neg x))\n  (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))",
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ]
              },
              {
                "lemma_name": "spec_norm_pos_pos",
                "tactic_sig": "custom48 NN.spec_eqb NN.spec_0 .",
                "tactic_args": [
                  "c5_goal : forall _ : Logic.eq (if NN.eqb x NN.zero then Pos x else Neg x) (Neg y),\nZ.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": [
                  "c6_goal : forall (_ : Logic.eq (NN.to_Z x) 0) (_ : Logic.eq (Pos x) (Neg y)),\nZ.lt 0 (NN.to_Z y)",
                  "c7_goal : forall (_ : not (Logic.eq (NN.to_Z x) 0))\n  (_ : Logic.eq (Neg x) (Neg y)), Z.lt 0 (NN.to_Z y)"
                ]
              }
            ],
            "custom51": [
              {
                "lemma_name": "spec_norm_pos_pos",
                "tactic_sig": "custom51 _i .",
                "tactic_args": [
                  "c8_goal : Z.lt 0 (NN.to_Z y)",
                  "c3_y : NN.t"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "spec_lxor": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            },
            {
              "name": "custom48",
              "definition": "Ltac custom48 H0 H1 :=  rewrite H0, H1; [case Z.eqb_spec | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 :=  generalize ( NN.spec_pos H0 ); [auto with zarith | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ],
            "custom48": [
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom48 NN.spec_eqb NN.spec_0 .",
                "tactic_args": [
                  "c5_goal : Logic.eq (to_Z (if NN.eqb x NN.zero then Pos x else Neg x))\n  (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))",
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ]
              },
              {
                "lemma_name": "spec_norm_pos_pos",
                "tactic_sig": "custom48 NN.spec_eqb NN.spec_0 .",
                "tactic_args": [
                  "c5_goal : forall _ : Logic.eq (if NN.eqb x NN.zero then Pos x else Neg x) (Neg y),\nZ.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": [
                  "c6_goal : forall (_ : Logic.eq (NN.to_Z x) 0) (_ : Logic.eq (Pos x) (Neg y)),\nZ.lt 0 (NN.to_Z y)",
                  "c7_goal : forall (_ : not (Logic.eq (NN.to_Z x) 0))\n  (_ : Logic.eq (Neg x) (Neg y)), Z.lt 0 (NN.to_Z y)"
                ]
              }
            ],
            "custom51": [
              {
                "lemma_name": "spec_norm_pos_pos",
                "tactic_sig": "custom51 _i .",
                "tactic_args": [
                  "c8_goal : Z.lt 0 (NN.to_Z y)",
                  "c3_y : NN.t"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "spec_div2": {
          "available_tactics": [
            {
              "name": "custom31",
              "definition": "Ltac custom31 H0 H1 H2 H3 H4 :=  apply H0; [rewrite H1; [unfold H2, H3; [rewrite H4 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom41",
              "definition": "Ltac custom41  :=  split; [now destruct Z.compare | now intros -> | .. ].\n"
            },
            {
              "name": "custom26",
              "definition": "Ltac custom26  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom60",
              "definition": "Ltac custom60 H0 :=  intros H0; [case H0; [ | .. ] | .. ].\n"
            },
            {
              "name": "custom48",
              "definition": "Ltac custom48 H0 H1 :=  rewrite H0, H1; [case Z.eqb_spec | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 :=  generalize ( NN.spec_pos H0 ); [auto with zarith | .. ].\n"
            }
          ],
          "examples": {
            "custom31": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.ltb_lt Z.lt ltb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (ltb x y) (Z.ltb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ]
              },
              {
                "lemma_name": "spec_leb",
                "tactic_sig": "custom31 Bool.eq_iff_eq_true Z.leb_le Z.le leb spec_compare .",
                "tactic_args": [
                  "c1_goal : Logic.eq (leb x y) (Z.leb (to_Z x) (to_Z y))"
                ],
                "tactic_res": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Gt => false\n     | _ => true\n     end true) (not (Logic.eq (Z.compare (to_Z x) (to_Z y)) Gt))"
                ]
              }
            ],
            "custom41": [
              {
                "lemma_name": "spec_ltb",
                "tactic_sig": "custom41 .",
                "tactic_args": [
                  "c2_goal : iff\n  (Logic.eq\n     match Z.compare (to_Z x) (to_Z y) with\n     | Lt => true\n     | _ => false\n     end true) (Logic.eq (Z.compare (to_Z x) (to_Z y)) Lt)"
                ],
                "tactic_res": []
              }
            ],
            "custom26": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom26 .",
                "tactic_args": [
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": []
              }
            ],
            "custom60": [
              {
                "lemma_name": "spec_opp",
                "tactic_sig": "custom60 x .",
                "tactic_args": [
                  "c1_goal : forall x : t_, Logic.eq (to_Z (opp x)) (Z.opp (to_Z x))"
                ],
                "tactic_res": [
                  "c2_goal : forall t : NN.t, Logic.eq (to_Z (opp (Pos t))) (Z.opp (to_Z (Pos t)))",
                  "c2_x : t_",
                  "c3_goal : forall t : NN.t, Logic.eq (to_Z (opp (Neg t))) (Z.opp (to_Z (Neg t)))",
                  "c3_x : t_"
                ]
              }
            ],
            "custom48": [
              {
                "lemma_name": "spec_norm_pos",
                "tactic_sig": "custom48 NN.spec_eqb NN.spec_0 .",
                "tactic_args": [
                  "c5_goal : Logic.eq (to_Z (if NN.eqb x NN.zero then Pos x else Neg x))\n  (Z.opp (NN.to_Z x))"
                ],
                "tactic_res": [
                  "c6_goal : forall _ : Logic.eq (NN.to_Z x) 0,\nLogic.eq (to_Z (Pos x)) (Z.opp (NN.to_Z x))",
                  "c7_goal : forall _ : not (Logic.eq (NN.to_Z x) 0),\nLogic.eq (to_Z (Neg x)) (Z.opp (NN.to_Z x))"
                ]
              },
              {
                "lemma_name": "spec_norm_pos_pos",
                "tactic_sig": "custom48 NN.spec_eqb NN.spec_0 .",
                "tactic_args": [
                  "c5_goal : forall _ : Logic.eq (if NN.eqb x NN.zero then Pos x else Neg x) (Neg y),\nZ.lt 0 (NN.to_Z y)"
                ],
                "tactic_res": [
                  "c6_goal : forall (_ : Logic.eq (NN.to_Z x) 0) (_ : Logic.eq (Pos x) (Neg y)),\nZ.lt 0 (NN.to_Z y)",
                  "c7_goal : forall (_ : not (Logic.eq (NN.to_Z x) 0))\n  (_ : Logic.eq (Neg x) (Neg y)), Z.lt 0 (NN.to_Z y)"
                ]
              }
            ],
            "custom51": [
              {
                "lemma_name": "spec_norm_pos_pos",
                "tactic_sig": "custom51 _i .",
                "tactic_args": [
                  "c8_goal : Z.lt 0 (NN.to_Z y)",
                  "c3_y : NN.t"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        }
      },
      "/Users/maxxin-admin/Documents/school/projects/dream-prover/dream-prover/copra/data/benchmarks/bignums/BigQ/QMake_comp.v": {
        "N_to_Z_pos": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "strong_spec_of_Q": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": [
            "custom28"
          ]
        },
        "spec_of_Q": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "spec_0": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "spec_1": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "spec_m1": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "spec_compare": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "spec_min": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "spec_max": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "spec_eq_bool": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "strong_spec_check_int": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": [
            "custom81",
            "custom25"
          ]
        },
        "spec_norm": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "strong_spec_norm": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "spec_red": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": [
            "custom86"
          ]
        },
        "strong_spec_red": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": [
            "custom86",
            "custom71",
            "custom70"
          ]
        },
        "spec_add": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "spec_add_norm": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "strong_spec_opp": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": [
            "strong_spec_opp_tac"
          ]
        },
        "spec_opp": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_sub": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_sub_norm": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_mul": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_norm_denum": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": [
            "custom81",
            "custom82"
          ]
        },
        "spec_irred": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_irred_zero": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "strong_spec_irred": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_mul_norm_Qz_Qq": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_mul_norm": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_inv": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_inv_norm": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_div": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_div_norm": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_square": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_power_pos": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_power": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": [
            "custom11"
          ]
        },
        "spec_power_norm": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": [
            "custom11"
          ]
        },
        "strong_spec_of_Qc": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_of_Qc": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_oppc": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_oppc_bis": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_comparec": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_addc": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_add_normc": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_add_normc_bis": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_subc": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_sub_normc": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_sub_normc_bis": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_mulc": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_mul_normc": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_mul_normc_bis": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_invc": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_inv_normc": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_inv_normc_bis": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_divc": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_div_normc": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_div_normc_bis": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_squarec": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "spec_power_posc": {
          "available_tactics": [
            {
              "name": "custom28",
              "definition": "Ltac custom28  :=  simpl; [rewrite ?ZZ.spec_of_Z; [destr_eqb; [now rewrite ?NN.spec_0, ?NN.spec_of_N | now rewrite ?NN.spec_0, ?NN.spec_of_N | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom25",
              "definition": "Ltac custom25 H0 H1 H2 :=  intros H0 H1; [unfold H2; [nzsimpl; [destr_zcompare; [ | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom81",
              "definition": "Ltac custom81  :=  qsimpl; [congruence | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  unfold H0; [apply H1 | .. ].\n"
            },
            {
              "name": "custom86",
              "definition": "Ltac custom86 H0 H1 H2 H3 H4 :=  intros [ H0 | H1 H2 ]; [ | custom51 H3 H4 | .. ].\n"
            },
            {
              "name": "custom70",
              "definition": "Ltac custom70 H0 :=  symmetry; [apply H0 | .. ].\n"
            },
            {
              "name": "custom71",
              "definition": "Ltac custom71  :=  simpl; [auto with zarith | .. ].\n"
            },
            {
              "name": "custom82",
              "definition": "Ltac custom82 H0 H1 H2 :=  unfold H0; [intros H1 H2 | .. ].\n"
            },
            {
              "name": "custom2",
              "definition": "Ltac custom2  :=  simpl; [nzsimpl | .. ].\n"
            },
            {
              "name": "custom11",
              "definition": "Ltac custom11 H0 H6 H7 H8 :=  destruct H0; [custom2 ; [red; [auto | .. ] | .. ] | apply H6 | simpl; [rewrite H7, H6; [apply H8 | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "strong_spec_opp_tac",
              "definition": "Ltac strong_spec_opp_tac := \n match goal with  |- context[NN.eqb ?X ?Y] =>\n  generalize (NN.spec_eqb X Y); case NN.eqb\n end. \n"
            }
          ],
          "examples": {
            "custom28": [
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c3_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xI y |}))\n  {| Qnum := x; Qden := xI y |}"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "strong_spec_of_Q",
                "tactic_sig": "custom28 .",
                "tactic_args": [
                  "c4_goal : eq (to_Q (of_Q {| Qnum := x; Qden := xO y |}))\n  {| Qnum := x; Qden := xO y |}"
                ],
                "tactic_res": []
              }
            ],
            "custom25": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom25 n d check_int .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nLogic.eq (to_Q (check_int n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (Qz n)) (to_Q (Qq n d))",
                  "c2_H : Logic.eq 1%Z (NN.to_Z d)",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t",
                  "c3_goal : Logic.eq (to_Q (Qq n d)) (to_Q (Qq n d))",
                  "c3_H : Z.lt 1 (NN.to_Z d)",
                  "c3_d : NN.t",
                  "c3_n : ZZ.t",
                  "c4_goal : Logic.eq (to_Q zero) (to_Q (Qq n d))",
                  "c4_H : Z.lt (NN.to_Z d) 1",
                  "c4_d : NN.t",
                  "c4_n : ZZ.t"
                ]
              }
            ],
            "custom81": [
              {
                "lemma_name": "strong_spec_check_int",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c6_goal : Logic.eq {| Qnum := ZZ.to_Z n; Qden := 1 |}\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos 1%Z |})"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom81 .",
                "tactic_args": [
                  "c3_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d))\n  (if NN.eqb d NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z n; Qden := Z.to_pos (NN.to_Z d) |})"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.mul (ZZ.to_Z n) (NN.to_Z d)) (ZZ.to_Z n)",
                  "c4_e : Logic.eq (NN.to_Z d) 1%Z",
                  "c4_H : Z.lt 0 (NN.to_Z d)"
                ]
              }
            ],
            "custom51": [],
            "custom86": [
              {
                "lemma_name": "spec_red",
                "tactic_sig": "custom86 n d z red spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Qeq (to_Q (red x)) (to_Q x)"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (red (Qz n))) (to_Q (Qz n))",
                  "c2_n : ZZ.t"
                ]
              },
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom86 n d z red strong_spec_norm .",
                "tactic_args": [
                  "c1_goal : forall x : t, Logic.eq (to_Q (red x)) (Qred (to_Q x))"
                ],
                "tactic_res": [
                  "c2_goal : Logic.eq (to_Q (red (Qz n))) (Qred (to_Q (Qz n)))",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom70": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom70 Qred_identity .",
                "tactic_args": [
                  "c3_goal : Logic.eq (to_Q (Qz n)) (Qred (to_Q (Qz n)))"
                ],
                "tactic_res": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ]
              }
            ],
            "custom71": [
              {
                "lemma_name": "strong_spec_red",
                "tactic_sig": "custom71 .",
                "tactic_args": [
                  "c4_goal : Logic.eq (Z.gcd (Qnum (to_Q (Qz n))) (Zpos (Qden (to_Q (Qz n))))) 1%Z"
                ],
                "tactic_res": []
              }
            ],
            "custom82": [
              {
                "lemma_name": "spec_norm_denum",
                "tactic_sig": "custom82 norm_denum n d .",
                "tactic_args": [
                  "c1_goal : forall (n : ZZ.t) (d : NN.t),\nQeq (to_Q (norm_denum n d)) (to_Q (Qq n d))"
                ],
                "tactic_res": [
                  "c2_goal : Qeq (to_Q (if NN.eqb d NN.one then Qz n else Qq n d)) (to_Q (Qq n d))",
                  "c2_d : NN.t",
                  "c2_n : ZZ.t"
                ]
              }
            ],
            "custom2": [],
            "custom11": [
              {
                "lemma_name": "spec_power",
                "tactic_sig": "custom11 z spec_power_pos spec_inv Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "spec_power_norm",
                "tactic_sig": "custom11 z spec_power_pos spec_inv_norm Qeq_refl .",
                "tactic_args": [
                  "c1_goal : forall (x : t) (z : Z), Qeq (to_Q (power_norm x z)) (Qpower (to_Q x) z)"
                ],
                "tactic_res": []
              }
            ],
            "strong_spec_opp_tac": [
              {
                "lemma_name": "strong_spec_opp",
                "tactic_sig": "strong_spec_opp_tac .",
                "tactic_args": [
                  "c5_goal : Logic.eq\n  (if NN.eqb y NN.zero\n   then 0\n   else {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |})\n  (Qopp\n     (if NN.eqb y NN.zero\n      then 0\n      else {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |}))"
                ],
                "tactic_res": [
                  "c7_goal : forall _ : Logic.eq true (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq 0 (Qopp 0)",
                  "c8_goal : forall _ : Logic.eq false (Z.eqb (NN.to_Z y) (NN.to_Z NN.zero)),\nLogic.eq {| Qnum := ZZ.to_Z (ZZ.opp x); Qden := Z.to_pos (NN.to_Z y) |}\n  (Qopp {| Qnum := ZZ.to_Z x; Qden := Z.to_pos (NN.to_Z y) |})"
                ]
              }
            ]
          },
          "used_tactics": []
        }
      }
    }
  }