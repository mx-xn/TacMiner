{
    "theorem_file": {
      "vagree_same": "NeedDomain.v",
      "vagree_lessdef": "NeedDomain.v",
      "lessdef_vagree": "NeedDomain.v",
      "lessdef_vagree_list": "NeedDomain.v",
      "vagree_lessdef_list": "NeedDomain.v",
      "nge_refl": "NeedDomain.v",
      "nge_trans": "NeedDomain.v",
      "nge_agree": "NeedDomain.v",
      "nge_lub_l": "NeedDomain.v",
      "nge_lub_r": "NeedDomain.v",
      "iagree_refl": "NeedDomain.v",
      "eq_same_bits": "NeedDomain.v",
      "iagree_and_eq": "NeedDomain.v",
      "iagree_mone": "NeedDomain.v",
      "iagree_zero": "NeedDomain.v",
      "iagree_and": "NeedDomain.v",
      "iagree_not": "NeedDomain.v",
      "iagree_or": "NeedDomain.v",
      "iagree_bitwise_binop": "NeedDomain.v",
      "iagree_shl": "NeedDomain.v",
      "iagree_shru": "NeedDomain.v",
      "iagree_shr_1": "NeedDomain.v",
      "iagree_shr": "NeedDomain.v",
      "iagree_rol": "NeedDomain.v",
      "iagree_ror": "NeedDomain.v",
      "eqmod_iagree": "NeedDomain.v",
      "iagree_eqmod": "NeedDomain.v",
      "complete_mask_idem": "NeedDomain.v",
      "andimm_sound": "NeedDomain.v",
      "orimm_sound": "NeedDomain.v",
      "bitwise_idem": "NeedDomain.v",
      "vagree_bitwise_binop": "NeedDomain.v",
      "and_sound": "NeedDomain.v",
      "or_sound": "NeedDomain.v",
      "xor_sound": "NeedDomain.v",
      "notint_sound": "NeedDomain.v",
      "shlimm_sound": "NeedDomain.v",
      "shruimm_sound": "NeedDomain.v",
      "rol_sound": "NeedDomain.v",
      "ror_sound": "NeedDomain.v",
      "rolm_sound": "NeedDomain.v",
      "add_sound": "NeedDomain.v",
      "sub_sound": "NeedDomain.v",
      "modarith_idem": "NeedDomain.v",
      "mul_sound": "NeedDomain.v",
      "neg_sound": "NeedDomain.v",
      "zero_ext_sound": "NeedDomain.v",
      "sign_ext_sound": "NeedDomain.v",
      "store_argument_sound": "NeedDomain.v",
      "store_argument_load_result": "NeedDomain.v",
      "maskzero_sound": "NeedDomain.v",
      "normalize_sound": "NeedDomain.v",
      "select_sound": "NeedDomain.v",
      "default_needs_of_condition_sound": "NeedDomain.v",
      "default_needs_of_operation_sound": "NeedDomain.v",
      "andimm_redundant_sound": "NeedDomain.v",
      "orimm_redundant_sound": "NeedDomain.v",
      "rolm_redundant_sound": "NeedDomain.v",
      "zero_ext_redundant_sound": "NeedDomain.v",
      "sign_ext_redundant_sound": "NeedDomain.v",
      "beq_correct": "NeedDomain.v",
      "ge_refl": "NeedDomain.v",
      "ge_trans": "NeedDomain.v",
      "ge_bot": "NeedDomain.v",
      "ge_lub_left": "NeedDomain.v",
      "ge_lub_right": "NeedDomain.v",
      "nreg_agree": "NeedDomain.v",
      "eagree_ge": "NeedDomain.v",
      "eagree_bot": "NeedDomain.v",
      "eagree_same": "NeedDomain.v",
      "eagree_update_1": "NeedDomain.v",
      "eagree_update": "NeedDomain.v",
      "eagree_update_dead": "NeedDomain.v",
      "nlive_all": "NeedDomain.v",
      "nlive_add": "NeedDomain.v",
      "incl_nmem_add": "NeedDomain.v",
      "nlive_remove": "NeedDomain.v",
      "nlive_contains": "NeedDomain.v",
      "nlive_dead_stack": "NeedDomain.v",
      "nlive_lub_l": "NeedDomain.v",
      "nlive_lub_r": "NeedDomain.v",
      "nmem_beq_sound": "NeedDomain.v",
      "eq_refl": "NeedDomain.v",
      "eq_sym": "NeedDomain.v",
      "eq_trans": "NeedDomain.v",
      "beq_correct2": "NeedDomain.v",
      "ge_refl2": "NeedDomain.v",
      "ge_trans2": "NeedDomain.v",
      "ge_bot2": "NeedDomain.v",
      "ge_lub_left2": "NeedDomain.v",
      "ge_lub_right2": "NeedDomain.v"
    },
    "custom_tactics": {
      "NeedDomain.v": {
        "vagree_same": {
          "available_tactics": [],
          "examples": {},
          "used_tactics": []
        },
        "vagree_lessdef": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ]
          },
          "used_tactics": [
            "custom18"
          ]
        },
        "lessdef_vagree": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "lessdef_vagree_list": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ]
          },
          "used_tactics": [
            "custom51",
            "custom20"
          ]
        },
        "vagree_lessdef_list": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": [
            "custom20",
            "custom98"
          ]
        },
        "nge_refl": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "nge_trans": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "nge_agree": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "nge_lub_l": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "nge_lub_r": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "iagree_refl": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "eq_same_bits": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "iagree_and_eq": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "iagree_mone": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "iagree_zero": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "iagree_and": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "iagree_not": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "iagree_or": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": [
            "custom90"
          ]
        },
        "iagree_bitwise_binop": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "iagree_shl": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "iagree_shru": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "iagree_shr_1": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "iagree_shr": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "iagree_rol": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "iagree_ror": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "eqmod_iagree": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "iagree_eqmod": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "complete_mask_idem": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": []
        },
        "andimm_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ]
          },
          "used_tactics": [
            "InvAgree",
            "custom35",
            "custom84"
          ]
        },
        "orimm_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ]
          },
          "used_tactics": [
            "custom79",
            "custom35",
            "custom73",
            "custom100",
            "custom16"
          ]
        },
        "bitwise_idem": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "vagree_bitwise_binop": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ]
          },
          "used_tactics": [
            "InvAgree"
          ]
        },
        "and_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "or_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "xor_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "notint_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "shlimm_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ]
          },
          "used_tactics": [
            "InvAgree"
          ]
        },
        "shruimm_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ]
          },
          "used_tactics": [
            "InvAgree"
          ]
        },
        "rol_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ]
          },
          "used_tactics": [
            "InvAgree"
          ]
        },
        "ror_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ]
          },
          "used_tactics": [
            "InvAgree"
          ]
        },
        "rolm_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ]
          },
          "used_tactics": [
            "custom89",
            "custom90"
          ]
        },
        "add_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ]
          },
          "used_tactics": [
            "InvAgree"
          ]
        },
        "sub_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": [
            "custom88",
            "custom0",
            "custom62",
            "custom1"
          ]
        },
        "modarith_idem": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": [
            "custom73",
            "custom18"
          ]
        },
        "mul_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": [
            "InvAgree"
          ]
        },
        "neg_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": [
            "InvAgree"
          ]
        },
        "zero_ext_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": [
            "InvAgree"
          ]
        },
        "sign_ext_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": [
            "InvAgree"
          ]
        },
        "store_argument_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": [
            "InvAgree"
          ]
        },
        "store_argument_load_result": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": [
            "InvAgree"
          ]
        },
        "maskzero_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": [
            "InvAgree"
          ]
        },
        "normalize_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "select_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "default_needs_of_condition_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "default_needs_of_operation_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "andimm_redundant_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": [
            "InvAgree"
          ]
        },
        "orimm_redundant_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": [
            "InvAgree"
          ]
        },
        "rolm_redundant_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "zero_ext_redundant_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": [
            "InvAgree"
          ]
        },
        "sign_ext_redundant_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": [
            "InvAgree"
          ]
        },
        "beq_correct": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "ge_refl": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "ge_trans": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "ge_bot": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "ge_lub_left": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "ge_lub_right": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "nreg_agree": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "eagree_ge": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "eagree_bot": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "eagree_same": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "eagree_update_1": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "eagree_update": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "eagree_update_dead": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "nlive_all": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "nlive_add": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "incl_nmem_add": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "nlive_remove": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "nlive_contains": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "nlive_dead_stack": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "nlive_lub_l": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "nlive_lub_r": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "nmem_beq_sound": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "eq_refl": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "eq_sym": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "eq_trans": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "beq_correct2": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "ge_refl2": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "ge_trans2": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "ge_bot2": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "ge_lub_left2": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        },
        "ge_lub_right2": {
          "available_tactics": [
            {
              "name": "custom18",
              "definition": "Ltac custom18 H0 :=  destruct H0; [simpl; [auto | .. ] | simpl | simpl; [auto | .. ] | .. ].\n"
            },
            {
              "name": "custom20",
              "definition": "Ltac custom20  :=  constructor; [auto with na | auto with na | .. ].\n"
            },
            {
              "name": "custom51",
              "definition": "Ltac custom51 H0 H1 :=  intros H0 H1; [inv H1 | .. ].\n"
            },
            {
              "name": "custom98",
              "definition": "Ltac custom98 H0 :=  intros H0; [constructor | .. ].\n"
            },
            {
              "name": "custom23",
              "definition": "Ltac custom23 H0 H1 H2 :=  red; [intros H0 H1 H2; [autorewrite with ints; [ | auto | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom80",
              "definition": "Ltac custom80  :=  f_equal; [auto | .. ].\n"
            },
            {
              "name": "custom1",
              "definition": "Ltac custom1 H0 :=  apply H0; [auto | .. ].\n"
            },
            {
              "name": "custom39",
              "definition": "Ltac custom39 H0 H1 :=  apply H0; [custom1 H1 | .. ].\n"
            },
            {
              "name": "custom90",
              "definition": "Ltac custom90 H0 H1 H2 :=  rewrite ! H0; [custom39 H1 H2 | .. ].\n"
            },
            {
              "name": "InvAgree",
              "definition": "Ltac InvAgree :=\n  simpl vagree in *;\n  repeat (\n  auto || exact Logic.I ||\n  match goal with\n  | [ H: False |- _ ] => contradiction\n  | [ H: match ?v with Vundef => _ | Vint _ => _ | Vlong _ => _ | Vfloat _ => _ | Vsingle _ => _ | Vptr _ _ => _ end |- _ ] => destruct v\n  | [ |- context [if Archi.ptr64 then _ else _] ] => destruct Archi.ptr64 eqn:?\n  end).\n"
            },
            {
              "name": "custom8",
              "definition": "Ltac custom8 H0 H1 H2 H3 H4 :=  intros H0 H1 H2 H3 H4; [destruct H2; [simpl in *; [auto | .. ] | simpl in * | simpl in * | .. ] | .. ].\n"
            },
            {
              "name": "custom16",
              "definition": "Ltac custom16 H0 :=  rewrite H0; [auto | .. ].\n"
            },
            {
              "name": "custom35",
              "definition": "Ltac custom35 H0 H1 H2 H3 H4 H5 H13 H17 :=  unfold H0; [custom8 H1 H2 H3 H4 H5; [unfold H13; [InvAgree; [custom1 H17 | .. ] | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom84",
              "definition": "Ltac custom84 H0 H1 H2 :=  rewrite H0 in H1; [custom16 H2].\n"
            },
            {
              "name": "custom42",
              "definition": "Ltac custom42  :=  InvAgree; [simpl | .. ].\n"
            },
            {
              "name": "custom73",
              "definition": "Ltac custom73 H0 :=  f_equal; [apply H0 | .. ].\n"
            },
            {
              "name": "custom79",
              "definition": "Ltac custom79 H0 H1 :=  apply H0; [rewrite H1 | .. ].\n"
            },
            {
              "name": "custom100",
              "definition": "Ltac custom100 H3 :=  custom42 ; [apply H3 | .. ].\n"
            },
            {
              "name": "custom89",
              "definition": "Ltac custom89 H0 H1 H2 H3 H4 H5 H6 :=  unfold H0; [intros H1 H2 H3 H4 H5 H6 | .. ].\n"
            },
            {
              "name": "custom0",
              "definition": "Ltac custom0 H0 H21 H20 H4 :=  destruct H0; [simpl in *; [auto | .. ] | simpl in * | simpl in *; [inv H21; [inv H20; [auto | destruct H4; [auto | auto | auto | auto | auto | auto | .. ] | .. ] | auto | .. ] | .. ] | .. ].\n"
            },
            {
              "name": "custom62",
              "definition": "Ltac custom62 H6 H7 H8 :=  InvAgree; [apply H6; [custom39 H7 H8 | .. ] | .. ].\n"
            },
            {
              "name": "custom88",
              "definition": "Ltac custom88 H0 H1 :=  unfold H0; [rewrite H1 | .. ].\n"
            }
          ],
          "examples": {
            "custom18": [
              {
                "lemma_name": "vagree_lessdef",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c4_goal : vagree Vundef w x",
                  "c2_x : nval"
                ],
                "tactic_res": [
                  "c5_goal : True",
                  "c5_m : Int.int"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom18 _i .",
                "tactic_args": [
                  "c2_goal : eq (modarith (modarith nv)) (modarith nv)",
                  "c2_nv : nval"
                ],
                "tactic_res": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))",
                  "c3_m : Int.int"
                ]
              }
            ],
            "custom20": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c5_goal : vagree_list (cons v1 vl1) (cons v2 vl2) nil"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom20 .",
                "tactic_args": [
                  "c6_goal : vagree_list (cons v1 vl1) (cons v2 vl2) (cons n nvl)"
                ],
                "tactic_res": []
              }
            ],
            "custom51": [
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c3_goal : forall (vl2 : list val) (_ : vagree_list nil vl2 nil),\nVal.lessdef_list nil vl2"
                ],
                "tactic_res": [
                  "c5_goal : Val.lessdef_list nil nil"
                ]
              },
              {
                "lemma_name": "lessdef_vagree_list",
                "tactic_sig": "custom51 vl2 H .",
                "tactic_args": [
                  "c4_goal : forall (vl2 : list val) (_ : vagree_list (cons a vl1) vl2 nil),\nVal.lessdef_list (cons a vl1) vl2"
                ],
                "tactic_res": [
                  "c6_goal : Val.lessdef_list (cons a vl1) (cons v2 vl3)",
                  "c6_H4 : vagree_list vl1 vl3 nil",
                  "c6_H2 : vagree a v2 All",
                  "c6_vl3 : list val",
                  "c6_v2 : val"
                ]
              }
            ],
            "custom98": [
              {
                "lemma_name": "vagree_lessdef_list",
                "tactic_sig": "custom98 nvl .",
                "tactic_args": [
                  "c2_goal : forall nvl : list nval, vagree_list nil nil nvl"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "ge_bot",
                "tactic_sig": "custom98 x .",
                "tactic_args": [
                  "c1_goal : forall x : nval, ge x bot"
                ],
                "tactic_res": []
              }
            ],
            "custom23": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom23 i H0 H1 .",
                "tactic_args": [
                  "c2_goal : iagree (Int.not x) (Int.not y) m"
                ],
                "tactic_res": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))",
                  "c3_H1 : eq (Int.testbit m i) true",
                  "c3_H0 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                  "c3_i : Z"
                ]
              }
            ],
            "custom80": [
              {
                "lemma_name": "iagree_not",
                "tactic_sig": "custom80 .",
                "tactic_args": [
                  "c3_goal : eq (negb (Int.testbit x i)) (negb (Int.testbit y i))"
                ],
                "tactic_res": []
              }
            ],
            "custom1": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom1 iagree_eqmod .",
                "tactic_args": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)"
                ],
                "tactic_res": []
              }
            ],
            "custom39": [],
            "custom90": [
              {
                "lemma_name": "iagree_or",
                "tactic_sig": "custom90 Int.not_or_and_not iagree_and iagree_not .",
                "tactic_args": [
                  "c3_goal : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom90 _i andimm_sound rol_sound .",
                "tactic_args": [
                  "c4_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c4_X : forall u : val,\neq (Val.rolm u amount mask)\n  (Val.and (Val.rol u (Vint amount)) (Vint mask))"
                ],
                "tactic_res": []
              }
            ],
            "InvAgree": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c3_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_i0 : Int.int",
                  "c4_i : Int.int"
                ]
              },
              {
                "lemma_name": "vagree_bitwise_binop",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v1 with\n  | Vint i1 =>\n      match v2 with\n      | Vint i2 => Vint (f i1 i2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": []
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shl i n) (Int.shl i0 n) m",
                  "c13_H : iagree i i0 (Int.shru m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shlimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n))",
                  "c15_H : iagree i i0 (Int.shru Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c11_goal : match\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c13_goal : iagree (Int.shru i n) (Int.shru i0 n) m",
                  "c13_H : iagree i i0 (Int.shl m n)",
                  "c13_i0 : Int.int",
                  "c13_i : Int.int"
                ]
              },
              {
                "lemma_name": "shruimm_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c12_goal : Val.lessdef\n  match v with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n))",
                  "c15_H : iagree i i0 (Int.shl Int.mone n)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "rol_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.rol i n) (Int.rol i0 n) m",
                  "c10_H : iagree i i0 (Int.ror m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "ror_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.ror i n) (Int.ror i0 n) m",
                  "c10_H : iagree i i0 (Int.rol m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "add_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.add n1 n2)\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.add n1 n2)\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.add i1 i) (Int.add i2 i0) m",
                  "c11_H0 : iagree i i0 (complete_mask m)",
                  "c11_H : iagree i1 i2 (complete_mask m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int",
                  "c11_i2 : Int.int",
                  "c11_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "mul_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.mul n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.mul n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.mul i1 i) (Int.mul i2 i0) m",
                  "c10_H0 : iagree i i0 (complete_mask m)",
                  "c10_H : iagree i1 i2 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int",
                  "c10_i2 : Int.int",
                  "c10_i1 : Int.int"
                ]
              },
              {
                "lemma_name": "neg_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match match v with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vint (Int.neg n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.neg i) (Int.neg i0) m",
                  "c10_H : iagree i i0 (complete_mask m)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.zero_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m",
                  "c11_H : iagree i i0 (Int.zero_ext n m)",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c25_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.zero_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c26_goal : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0))",
                  "c26_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c10_goal : match\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n0 => Vint (Int.sign_ext n n0)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c11_goal : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m",
                  "c11_H : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c11_i0 : Int.int",
                  "c11_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c42_goal : Val.lessdef\n  match v with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end\n  match w with\n  | Vint n0 => Vint (Int.sign_ext n n0)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                  "c43_goal : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0))",
                  "c43_H : iagree i i0 (Int.zero_ext n Int.mone)",
                  "c43_i0 : Int.int",
                  "c43_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c15_goal : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w)"
                ],
                "tactic_res": [
                  "c26_goal : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0))",
                  "c26_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))",
                  "c26_H : iagree i i0 (Int.repr 255)",
                  "c26_i0 : Int.int",
                  "c26_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c16_goal : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w)"
                ],
                "tactic_res": [
                  "c33_goal : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))",
                  "c33_H : iagree i i0 (Int.repr 255)",
                  "c33_i0 : Int.int",
                  "c33_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c17_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c40_goal : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))",
                  "c40_H : iagree i i0 (Int.repr 255)",
                  "c40_i0 : Int.int",
                  "c40_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c18_goal : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w)"
                ],
                "tactic_res": [
                  "c47_goal : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))",
                  "c47_H : iagree i i0 (Int.repr 65535)",
                  "c47_i0 : Int.int",
                  "c47_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c19_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c54_goal : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_UNDEF : list_forall2 memval_lessdef\n  (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))",
                  "c54_H : iagree i i0 (Int.repr 65535)",
                  "c54_i0 : Int.int",
                  "c54_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Val.load_result Mbool v) (Val.load_result Mbool w)"
                ],
                "tactic_res": [
                  "c15_goal : Val.lessdef (Val.load_result Mbool (Vint i))\n  (Val.load_result Mbool (Vint i0))",
                  "c15_H : iagree i i0 (Int.repr 255)",
                  "c15_i0 : Int.int",
                  "c15_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c5_goal : Val.lessdef (Val.load_result Mint8signed v)\n  (Val.load_result Mint8signed w)"
                ],
                "tactic_res": [
                  "c17_goal : Val.lessdef (Val.load_result Mint8signed (Vint i))\n  (Val.load_result Mint8signed (Vint i0))",
                  "c17_H : iagree i i0 (Int.repr 255)",
                  "c17_i0 : Int.int",
                  "c17_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c6_goal : Val.lessdef (Val.load_result Mint8unsigned v)\n  (Val.load_result Mint8unsigned w)"
                ],
                "tactic_res": [
                  "c19_goal : Val.lessdef (Val.load_result Mint8unsigned (Vint i))\n  (Val.load_result Mint8unsigned (Vint i0))",
                  "c19_H : iagree i i0 (Int.repr 255)",
                  "c19_i0 : Int.int",
                  "c19_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : Val.lessdef (Val.load_result Mint16signed v)\n  (Val.load_result Mint16signed w)"
                ],
                "tactic_res": [
                  "c21_goal : Val.lessdef (Val.load_result Mint16signed (Vint i))\n  (Val.load_result Mint16signed (Vint i0))",
                  "c21_H : iagree i i0 (Int.repr 65535)",
                  "c21_i0 : Int.int",
                  "c21_i : Int.int"
                ]
              },
              {
                "lemma_name": "store_argument_load_result",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : Val.lessdef (Val.load_result Mint16unsigned v)\n  (Val.load_result Mint16unsigned w)"
                ],
                "tactic_res": [
                  "c23_goal : Val.lessdef (Val.load_result Mint16unsigned (Vint i))\n  (Val.load_result Mint16unsigned (Vint i0))",
                  "c23_H : iagree i i0 (Int.repr 65535)",
                  "c23_i0 : Int.int",
                  "c23_i : Int.int"
                ]
              },
              {
                "lemma_name": "maskzero_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c4_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)"
                ],
                "tactic_res": [
                  "c5_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c5_H0 : eq (Val.maskzero_bool Vundef n) (Some b)",
                  "c5_H : True",
                  "c6_goal : eq (Some (Int.eq (Int.and i0 n) Int.zero)) (Some b)",
                  "c6_H0 : eq (Val.maskzero_bool (Vint i) n) (Some b)",
                  "c6_H : iagree i i0 n",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c7_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c7_H0 : eq (Val.maskzero_bool (Vlong i) n) (Some b)",
                  "c7_H : True",
                  "c7_i : Int64.int",
                  "c8_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c8_H0 : eq (Val.maskzero_bool (Vfloat f) n) (Some b)",
                  "c8_H : True",
                  "c8_f : float",
                  "c9_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c9_H0 : eq (Val.maskzero_bool (Vsingle f) n) (Some b)",
                  "c9_H : True",
                  "c9_f : float32",
                  "c10_goal : eq\n  match w with\n  | Vint n0 => Some (Int.eq (Int.and n0 n) Int.zero)\n  | _ => None\n  end (Some b)",
                  "c10_H0 : eq (Val.maskzero_bool (Vptr b0 i) n) (Some b)",
                  "c10_H : True",
                  "c10_i : Ptrofs.int",
                  "c10_b0 : block"
                ]
              },
              {
                "lemma_name": "andimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c9_goal : match\n  match v with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c10_goal : iagree (Int.and i n) i0 m",
                  "c10_H0 : iagree i i0 (Int.and m n)",
                  "c10_i0 : Int.int",
                  "c10_i : Int.int"
                ]
              },
              {
                "lemma_name": "orimm_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c8_goal : match\n  match v with\n  | Vint n1 => Vint (Int.or n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c9_goal : iagree (Int.or i n) i0 m",
                  "c9_H0 : iagree i i0 (Int.and m (Int.not n))",
                  "c9_i0 : Int.int",
                  "c9_i : Int.int"
                ]
              },
              {
                "lemma_name": "zero_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.zero_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.zero_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0 (Int.zero_ext n m)",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              },
              {
                "lemma_name": "sign_ext_redundant_sound",
                "tactic_sig": "InvAgree .",
                "tactic_args": [
                  "c7_goal : match Val.sign_ext n v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c8_goal : match Val.sign_ext n (Vint i) with\n| Vint p => iagree p i0 m\n| _ => True\nend",
                  "c8_H0 : iagree i i0\n  (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (Z.sub n 1))))",
                  "c8_i0 : Int.int",
                  "c8_i : Int.int"
                ]
              }
            ],
            "custom8": [],
            "custom16": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom16 Int.and_mone .",
                "tactic_args": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ],
                "tactic_res": []
              }
            ],
            "custom35": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom35 andimm v w x n H Val.and iagree_and .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (andimm x n)),\nvagree (Val.and v (Vint n)) (Val.and w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.and v (Vint n)) (Val.and w (Vint n))",
                  "c2_H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              },
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom35 orimm v w x n H Val.or iagree_or .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (n : Int.int)\n  (_ : vagree v w (orimm x n)),\nvagree (Val.or v (Vint n)) (Val.or w (Vint n)) x"
                ],
                "tactic_res": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))",
                  "c2_H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.not n)\n    | _ => False\n    end\n| _ => True\nend",
                  "c2_n : Int.int",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom84": [
              {
                "lemma_name": "andimm_sound",
                "tactic_sig": "custom84 iagree_and_eq _i _i .",
                "tactic_args": [
                  "c4_goal : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n))",
                  "c4_H : iagree i i0 n",
                  "c4_H : iagree i i0 n"
                ],
                "tactic_res": []
              }
            ],
            "custom42": [],
            "custom73": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom73 iagree_mone .",
                "tactic_args": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))"
                ],
                "tactic_res": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ]
              },
              {
                "lemma_name": "modarith_idem",
                "tactic_sig": "custom73 complete_mask_idem .",
                "tactic_args": [
                  "c3_goal : eq (I (complete_mask (complete_mask m))) (I (complete_mask m))"
                ],
                "tactic_res": []
              }
            ],
            "custom79": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom79 iagree_or Int.and_commut .",
                "tactic_args": [
                  "c4_goal : iagree (Int.or i n) (Int.or i0 n) Int.mone"
                ],
                "tactic_res": [
                  "c5_goal : iagree i i0 (Int.and (Int.not n) Int.mone)"
                ]
              }
            ],
            "custom100": [
              {
                "lemma_name": "orimm_sound",
                "tactic_sig": "custom100 Val.lessdef_same .",
                "tactic_args": [
                  "c2_goal : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n))"
                ],
                "tactic_res": [
                  "c3_goal : eq (Vint (Int.or i n)) (Vint (Int.or i0 n))",
                  "c3_H : iagree i i0 (Int.not n)",
                  "c3_i0 : Int.int",
                  "c3_i : Int.int"
                ]
              }
            ],
            "custom89": [
              {
                "lemma_name": "rolm_sound",
                "tactic_sig": "custom89 rolm v w x amount mask H .",
                "tactic_args": [
                  "c1_goal : forall (v w : val) (x : nval) (amount mask : Int.int)\n  (_ : vagree v w (rolm x amount mask)),\nvagree (Val.rolm v amount mask) (Val.rolm w amount mask) x"
                ],
                "tactic_res": [
                  "c2_goal : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x",
                  "c2_H : vagree v w (rol (andimm x mask) amount)",
                  "c2_mask : Int.int",
                  "c2_amount : Int.int",
                  "c2_x : nval",
                  "c2_w : val",
                  "c2_v : val"
                ]
              }
            ],
            "custom0": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom0 _i _i _i _i .",
                "tactic_args": [
                  "c3_goal : vagree (Val.sub v1 v2) (Val.sub w1 w2) x",
                  "c3_x : nval",
                  "c3_H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | All => All\n  end",
                  "c3_w1 : val"
                ],
                "tactic_res": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend",
                  "c4_m : Int.int"
                ]
              }
            ],
            "custom62": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom62 eqmod_iagree eqmod_sub iagree_eqmod .",
                "tactic_args": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                  "c6_goal : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0)",
                  "c6_H0 : iagree i i0 (complete_mask m)",
                  "c6_H : iagree i1 i2 (complete_mask m)",
                  "c6_i0 : Int.int",
                  "c6_i : Int.int",
                  "c6_i2 : Int.int",
                  "c6_i1 : Int.int"
                ]
              }
            ],
            "custom88": [
              {
                "lemma_name": "sub_sound",
                "tactic_sig": "custom88 Val.sub _i .",
                "tactic_args": [
                  "c4_goal : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend",
                  "c3_H1 : eq Archi.ptr64 true"
                ],
                "tactic_res": [
                  "c5_goal : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend"
                ]
              }
            ]
          },
          "used_tactics": []
        }
      }
    }
  }